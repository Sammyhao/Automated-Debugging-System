 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  If every object added to a java.util.HashSet implements Object.equals() and Object.hashCode() in a deterministic fashion, is the iteration order over the HashSet guaranteed to be identical for every identical set of elements added, irrespective of the order in which they were added?  Bonus question: what if the insertion order is identical as well?  (Assuming Sun JDK6 with same HashSet initialization.)  Edit: My original question was not clear. It is not about the general contract of HashSet, but what Sun's implementation of HashSet in JDK6 offers as guarantees concerning determinism. Is it inherently non-deterministic? What influences the order used by its Iterator?  16.2k66 gold badges5454 silver badges6262 bronze badges  2  I think Michael Borgwardt nails it: insertion-order will effect collision behaviour. Péter Török's point about initialization (e.g. size and load-factor) are important, too. Other than that it's going to be deterministic. Same JVM, same initialization, same order? How could it possibly NOT be deterministic? I've looked at the JDK6 code and it's clearly deterministic - no use of Math.random() in there!!!  It's possible to write deterministic programs which use Math.random(). Same holds true for non-deterministic programs which do not use Math.random().  9 Answers 9  The insertion order directly influences the iteration order whenever you have a bucket collision:  When two elements end up in the same bucket, the first one that was inserted will also be the first one returned during iteration, at least if the implementation of collision handling and iteration is straightforward (and the one in Sun's is)  333k7575 gold badges463463 silver badges702702 bronze badges  3  1  Great answer. I edited in a small bonus question: what if the insertion order remains identical as well? In other words: is there anything inherently non-deterministic in the implementation of the "standard" java.util.HashMap?  @eljenso: I'm pretty sure there isn't - but I don't see how to prove that conclusively.  @eljenso if there isn't today, there might be tomorrow, if the spec (Hashmap doc) doesn't say otherwise.  There is no "official" guarantee for anything like this. I would say it is most probably true for instances of the same HashSet implementation, initialized the same way. But I have seen cases for the iteration order being different between Java 5 and 6, for example.  Also, it may be different for instances of the same HashSet implementation, initialized with different size, due to rehashing. I.e. if you have 100 elements and two sets, one initialized with a size greater than 100, the other with a much smaller size, the second one will get reallocated and its elements rehashed several times while filling up. This may result in elements mapped to the same bucket being added (and thus iterated over) in different order.  In Java4 and later, you have which guarantees that the iteration order will be the order in which its elements were inserted.  Wanted to confirm / upvote earlier comments. In short, Do Not Rely on HashSet iteration in consistent order. This can and will introduce bugs in your system.  We just found and fixed a bug where the iteration order was inconsistent in HashSet even with:  Identical insertion order.  Objects of a class with a valid equals() and hashCode() method.  Here's a further discussion indicating that the GC being in a separate thread can introduce unpredictability even in completely "deterministic" scenarios: stackoverflow.com/questions/4418896/…  +1 for commenting on results even when using identical insertion order, good addition to the discussion  This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. [...] The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created  And the method :  Returns an iterator over the elements in this set. The elements are returned in no particular order.  37k44 gold badges8686 silver badges119119 bronze badges  1  My original question was not clear. Sorry for that. Your answer is correct though in a general sense.  Never ever make assumptions about the iteration order of anything you put into a HashSet because its contract explicitly says that you can't count on it in any way. Use LinkedHashSet if you want to maintain insertion order or TreeSet if you want to maintain a natural sorting order.  The order objects appear will depend on the final number of buckets of the HashSet. By changing the load factor and/or initial capacity you can change the order the elements end up in.  In the following example, you can see these confirguations each result in a different order.  First, different JVM may implement the HashSet algorithm differently (as long as it complies with the HashSet specification) so you will get different results on different JVMs.  Second, the algorithm may rely on non-deterministic factors when it builds the different buckets (part of the hash-table algorithm).  28.9k1010 gold badges8383 silver badges115115 bronze badges  1  I'm using the same JVM. I specifically mention that all hash codes are deterministic (i.e. Object.hashCode() is always overrided in a meaningful and deterministic way).  I am sure that the Java developers want you to assume the answer is "no". In particular, for hash tables, why would they make it slower for everyone else who doesn't need this property to guarantee that objects whose hashes clash (identical hashCode % size) are observed in the same order regardless of the order in which they were put in?  Such assumption cannot be made. The javadoc says that:  This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time.  The closest you can get is to use a LinkedHashSet, which maintains the insertion order.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  