 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have an iOS app with a really nasty bug: an operation in my NSOperationQueue will for some reason hang and not finish executing so other additional operations are being queued up but still not executing. This in turn leads to the app not begin able to perform critical functions. I have not yet been able to identify any pattern other than that it occurs on one of my co-workers devices every week or so. Running the app from Xcode at that point does not help as killing and relaunching the app resolves the issue for the time being. I've tried attaching the debugger to a running process and I seem to be able to see log data but any break points I add are not registering. I've added a bread crumb trail of NSLogs to try to pinpoint where it's hanging but this has not yet led to a resolution.  I originally described the bug in another question which is yet to have a clear answer I'm guessing because of the lack of info I'm able to provide around this issue.  A friend once told me that it's possible to save the entire memory stack of an app at a given moment in some form and reload that exact state of memory onto a process on a different device. Does anyone know how I can achieve that? If that's possible the next time someone encounters that bug I can save that exact state of memory and replicate to test all my theories of possible solutions. Or is there a different approach to tackling this? As an interim measure, do you think it would make sense to forcefully make the app crash when the app enters this state so actual users would be less confused? I'm have mixed feelings about this but the user will have to kill the app from the multitask dock anyway in order to use the app again. I can check the operation queue count or create some kind of timeout code for this until I actually nail this bug.  2,43211 gold badge2323 silver badges3838 bronze badges  10  Try attaching the debugger to the existing running process rather than running a new instance.  I did mention "I've tried attaching the debugger to a running process and I seem to be able to see log data but any break points I add are not registering." above. Logs don't give me much at this point and I need break points to work for this be of any help to me.  Ah ok, sorry, the build on the device needs to be a debug build and exactly the same codebase as you run locally. Is this the case?  It is, I'm not familiar as to whether or not break points are even supposed to work when attaching it to a process. Is this even possible?  Absolutely, assuming it is a debug build that you have installed from your machine (and the codebase is the same) simply attaching the debugger to an existing instance is fine.  5 Answers 5  This sounds as a deadlock on a very rare race-condition. You also mentioned using a maxConcurrentOperationCount of 2. This means that either:  some operation is blocking the operation queue and waitiong for main to release some lock and main is waiting for the operation to finish  two operations are waiting on each other to release some lock  1 seems very unlikely as the queue should allow 2 concurrent operations to be completely blocked, unless you are using some system functions that have concurency issues and block you queue instead of just one thread.  I this case my first attempt to debug would be to connect the debugger and pause execution. After that you can look at the stack traces for all threads. You should be able to find the 2 threads that are made by your operation queue after which I would review the responsible functions to find code thet might possibly wait on some lock. Make sure to take into consideration sytem functions.  I had the same issue - after close review noticed that some part of the utility code was having Mutex condition - which was used in both main thread code and also on one of the Operations run on another thread. This was causing both to wait on each other in turn deadlock. Removed the mutex logic with some other safe logic and it works now.  Well it's quite hard to solve bugs that don't crash the App but just hang a thread. If you can't find the bug by looking at your code step by step checking if there are any possible deadlock- or raceconditions I would suggest to implement some logging.  Write your log to disk everytime you add a logentry. That's not the most memory efficient way, but if you give a build with logging enabled to your co-worker you can pull the log from his iPhone when things go wrong. Even while the App is still running.  Make sure you log every step you take including the values of important variables around the code that you suspect of breaking the App. This way you can see what the App is doing and what the state of the App is.  Hope this helps a bit. I don't now about restoring the state of memory of an App so can't help you with that.  Note; If the App is crashing on the bug you could use some other tools, but if I get it right thats not the case here is it?  I read the question describing the bug and I would try to log to disk what the currently running operations are doing. It seems the operations will hang once in a while and there is a bug in there. If you can log what methods are called while running the operation this will show you what function call will hang the App and you can start looking in there.  3,59822 gold badges2222 silver badges3838 bronze badges  1  Thanks for the input. Yes, this particular bug dosen't crash the app but just makes one or a few of my threads hang. Everything the app does on the main thread runs ok but key functions that need to run in a background thread don't run so the user just thinks that the app is not responding.  You didn't say this but I presume the bug occurs while a human operator is working with the app? Maybe you should add an automated mode to this app, where the app simulates the same operations that users normally do, using randomized times for starting different actions. Then you can leave the app running unattended on all your devices and increase the chances of seeing the problem.  Also, since the problem appears related to the NSOperationQueue, maybe you should subclass it so that you can add logging to the more interesting methods. For example, each time an operation is added you should log the state of the queue, since you suspect that sometimes it is getting suspended.  Also, I suggested this on your other question as well, you may want to setup an observer to get notified if the queue ever goes into a suspended state.  59.5k1414 gold badges121121 silver badges136136 bronze badges  1  Thanks, this is a very good idea, however I am skeptical as if I can capture the bug this way because I've NEVER been able to recreate this problem manually over the course of almost 1 and a half months. My app is more or less an overcomplicated text messaging app and user behaviors include closing and opening the app multiple times during the day, coming in from push notifications, and I also have to account for poor 3G or EDGE connections. Right now, I'm leaning towards adding logging code to all possible points in related code. Which is not a bad idea but just painful.  Checking assumptions here, since that never hurts: do you actually have evidence that your background threads are hanging? From what you report, the observed behavior is that the tasks you're putting in your background thread are not achieving the outcome that you expected. That doesn't necessarily indicate that the thread has hung—it might just indicate that the particular conditions meant that the thread closed due to all tasks being completed, without the tasks achieving what you wanted them to.  Addition: Given your answer in the comments, it seems to me the next step then is to use logging when an item begins to be executed in the queue so that you can identify which items it is that lead to the queue becoming blocked. Best guess is that it is a certain class of items or certain characteristics of the items if they are all of a certain class. Log enough as the first step of executing each item that you'll have a reasonable characterization of the item, and then once you get a real device that has entered this state, check the logs and see just what conditions are leading to this problem. That should enable you to reliably reproduce the problem on a device during debugging or in the simulator, to then nail it.  In other words—I would focus your attention on identifying the problematic operations first, rather than trying to identify the particular line of code where things are stalling.  19.3k33 gold badges5151 silver badges9292 bronze badges  1  NSLogs indicate that when the app falls into this "state" new NSOperations are being added to the NSOperationQueue and the queue but the count continues to increase but not decrease which should be the case if the operations are running and finishing successfully. My NSOperationQueue has a maxConcurrentOperationCount of 2 so if there are 2 operations that have not finished, the queued operation count will just keep incrementing which is exactly the problem I'm having.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  