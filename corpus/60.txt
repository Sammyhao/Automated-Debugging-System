 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  What modification should I apply to the dynamic programming implementation of two partition problem to solve the following task:  You are given an array of positive integers as input, denote it C. The program should decide if it is possible to partition the array into two equal sum subsequences. You are allowed to remove some elements from the array, but not all, in order to make such partition feasible.  Example:  Suppose the input is 4 5 11 17 9. Two partition is possible if we remove 11 and 17. My question is what adjustments to my two partition implementation I should make to determine if two partition is possible (may or may not require to remove some elements) or output that two partition is impossible even if some elements are removed. The program should run in O(sum^2 * C) time.  Here is my two partition implementation in Python:  Start with determining how your table should be dimensioned. Your current algo calls for a C*s/2 table, and the complexity is O(C*s). The required algo should have O(C*s*s) complexity, so...  @גלעדברקן The expected output is {2,1} and {3} so it is possible to partition the array into two equal sums subarrays. We don't need to remove any elements in this case.  In that case, I would change the word, "subarrays," to "subsets" or "subsequences." I think subarray is mostly understood as contiguous.  3 Answers 3  Create a 3 dimensional array indexed by sum of 1st partition, sum of 2nd partition and number of elements. if only true if it's possible to have two disjoint subsets with sum & respectively within the first elements.  To calculate it, you need to consider three possibilities for each element. Either it's present in first set, or second set, or it's removed entirely. Doing this in a loop for each combination of sum possible generates the required array in .  To find the answer to your question, all you need to check is that there is some sum such that is true. This implies that there are two distinct subsets both of which sum to , as required by the question.  If you need to find the actual subsets, doing so is easy using a simple backtracking function. Just check which of the three possibilities are possible in the back_track functions and recurse.  2,16311 gold badge1717 silver badges2525 bronze badges  18  @גלעדברקן Whoops, the function was returning true or false so I totally missed that part. It can be easily done by backtracking on successful i & j. If T1[i][j-1] is true as well, then jth element is skipped, else it is needed. decrement j until you hit 0. Apply the same procedure in reverse for T2.  Just want to clarify what is the role of T2 and why the last loop guarantees that two partition is possible. Can you briefly explain?  @user1812 it doesn't. This function returns False for [2,3,1]. The idea is broken and cannot be fixed. Your complexity estimate is correct.  @n.m. But, the answer should be false for [2, 3, 1]. The partition is supposed to be in two subarrays, not subsets. How is that possible for [2, 3, 1]?  @user1812 The last loop guarantees that there is some sum i, such that you can find a subset among first j elements and a subset from j+1 onwards both of which equal i. Removing all the elements other than the those two subsets will lead to two subarrays with equal sum.  To determine if it's possible, keep a set of unique differences between the two parts. For each element, iterate over the differences seen so far; subtract and add the element. We're looking for the difference 0.  22.4k33 gold badges2020 silver badges5858 bronze badges  2  Dynamic programming solution is preferred. Also please justify your solution, i.e why your algorithm works and running time.  @user1812 It seems like dynamic programming to me - the overlapping subproblems are the achievable differences between the two disjoint subsets. It works because it tries to place each element either in one subset (-) or the other (+) and leaves the choice of neither in the set of seen differences. Running time is O(|C| * number-of-achievable-differences).  I quickly adapted code for searching of three equal-sums subsets to given problem.  Algorithm tries to put every item in the first bag, or in the second bag (both are real bags) or in the third (fake) bag (ignored items). Initial values (available space) in the real bags are half of overall sum. This approach as-is has exponential complexity (decision tree with 3^N leaves)  But there is a lot of repeating distributions, so we can remember some state and ignore branches with no chance, so a kind of DP - memoization is used. Here mentioned state is set of available space in real bags when we use items from the last index to inclusively.  Possible size of state storage might reach  Working Delphi code (is not thoroughly tested, seems has a bug with ignored items output)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  