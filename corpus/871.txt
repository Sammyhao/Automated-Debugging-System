 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to implement Kruskal as efficient as possible.  For runtime efficiency, is there a difference in using a heap or a sorting algorithm for sorting the edges?  What other techniques are there for making the Kruskal algorithm work more efficiently?  This is one of those questions that has only one correct answer: benchmark all options with your own data, there is no universal answer. Using a heap may have an advantage on the average case for some graphs, but heaps are very bad cache wise. And if you're trying to be "as efficient as possible", I assume you don't want cache misses slowing your code down.  1 Answer 1  It depends on the exact problem you are trying to solve. In case you are implementing a generic solution, just choose the 'fastest' sorting algorithm. I doubt that is heapsort though. I would just use whatever Java is using by default as a sorting algorithm (probably timsort, if you are sorting objects). More, in some cases sorting can be done faster than . Say your edges can only have integer weights residing in a small interval, then maybe you can go for something really similar to countsort. So if you are in one of those cases maybe a heap is far from a good choice. Also, I cannot see any reason why someone would use a heap in the context of Kruskal's algorithm solely.  To answer your second question (but you might know this already) a good speed up is given by the usage of Disjoint-set data structure for the operations on sets. It comes with all sort of advantages: easy to implement, good asymptotic behavior and low constant.  EDIT  I have reconsidered the heap/heapsort option, mainly due to the comments on my post. Using a heap might bring a huge advantage indeed if only sorting until the tree is complete. 180 degrees turn on my opinion. Here is the reason.  Consider the Erdős–Rényi model. Now, this is a very simplistic model in which one starts with an empty graph on vertices (i.e. no edges) and adds each possible edge with probability to , independent from any other edge. This is not exactly what Kruskal's algorithm does when composing the tree, but it resembles it 'pretty well' if has quadratic number of edges (in terms of the number of vertices), the edge distribution is not 'biased' and the weight assignment is not 'biased'.  Now here comes the interesting part. Under the Erdős–Rényi model, the graph becomes connected when is approximately (i.e. 'roughly' speaking, after adding edges to the graph). The result is well known for some time (check here).  Though, again, the setup is different for the Kruskal's algorithm, if has quadratic number of edges (in terms of the number of vertices), the edge distribution is not 'biased' and the weight assignment is not 'biased', it is plausible that a tree is reachable within edges. If this is true indeed, it makes using a heap and only sorting until the tree is complete better than sorting the entire set of edges using a comparison sort method before starting composing the tree.  So using a heap probably brings runtime speed up also and it might be considerable.  65433 gold badges1010 silver badges2323 bronze badges  4  1  I think the main benefit from using a heap is the ability to do a partial sort, only sorting until the tree is complete. If in your dataset the tree is usually reachable within O(V) edges, you would have a speed up using a heap. But, again, heaps have a very high constant, so the speed up must be substantial to make it worth the trouble.  Thinking again, another benefit is the better worst-case complexity of the heapsort. For real-time systems with tight time constraints, being able to deterministically predict how long an algorithm would take (no matter the input) is an advantage.  I implemented Kruskal with Heap and with a Sorting Algorithm and indeed, the Heap was faster for those instances. But today I'm testing doing it again, and now they have both the same speed. I can't really understand this.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  