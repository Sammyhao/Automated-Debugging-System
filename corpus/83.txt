 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm writing a hash table and I'm using an opaque pointer to manage this ADT. This is how my code looks like:  hash_table.h  hash_table.c  This is the code of the "for each" function that I wrote. It works great but I really don't enjoy it, I think that this isn't an elegant code.  How can I perform this in a better way? Thanks in advance  ADT? what is that, the ADT tag is for "android development tools" if it is some sort of data structure you probably need to spell it out...  I don't like that i have two functions, I would prefer a single foreach function. Maybe with a macro i could do this but i really don't know how.  1 Answer 1  There are multiple ways of supporting iterations in abstract data types. It depends on how much you want to abstract and how much control you want your users to have.  Random access  If your data type supports random access, you could let the user in charge of the iteration (like arrays):  And you use it like this:  The user of your data type have control of how and when to iterate. This is very easy to use and understand and it doesn't cost you more memory.  A variation of this would be returning a pointer to the item array instead of making them go through a function to access it.  Iterator struct  You could provide an iterator data type that knows how to iterate over hash tables. This is the C++ most used approach. I tend to like it because you could abstract any kind of iteration logic in it (i.e, only iterate on filled buckets) and have clear responsibility separation:  And you use it like this:  }  It's a lot more verbose but as I said you gain the ability of totally abstracting iteration and still supporting control over when the iteration happens. You no longer have random access, though.  Traversal callback  A third way would be to iterate over the items yourself and execute a user callback for each item:  And you use it like this:  This way is less verbose and still abstracts iteration logic but users no longer controls the iteration. You could make sensible to return value. If it's zero, it would stop iteration, to give users some control.  The pointer lets the user store state between each call, enabling them to use this code with C++ (e.g, would point to a class instance) (but if you're using C++ I'd go with lambdas).  The way you're doing not only you're mixing responsibilities for your data types but you also lose multithread iteration.  I'm not really fond of macros when you can easly creater a solution that is clear both for you and to whomever is using your code, but, in any case, here is a link to a SO question that seems to provide what you wanted with macros.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  