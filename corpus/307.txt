 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm 99% sure my problem is that I'm setting low to zero every start. But I'm not sure how to keep low consistently representative of the low index regardless of the depth of my recursion. If it accurately told me the index of the low index I don't think I would have a problem.  @Gracenotes At the time of writing this I didn't understand a lot of fundamentals about OOP. It is indeed arbitrary.  3 Answers 3  This won't work when you are trying to search in the upper half of the vector, because what you really need to create is a slice of the vector.  There is already a binary search but if you are determined to write your own, use an iterator-range in the parameters. (You can either pass in two plain iterators or a boost range).  You want -1 if not found else the iterator location, so in your slice (iterator range) you would need to specify a starting index number in case it is found.  You could also pass, as an alternative, the vector (by const reference) and the range in which you wish to search.  Your last line is unreachable. Instead it should be the terminating condition of your recursion before you do any evaluation. (If your range is empty)  The version that would iterate by passing by reference and using index numbers (simplest) would look like this:  would indicate "one past the last element" so if the vector has size 5, the first iteration would pass 0 and 5. If the vector is empty, you pass 0 and 0.  As an exercise, "can it be done with 3 parameters"?  29.6k44 gold badges5555 silver badges8888 bronze badges  4  Honestly I'm just practicing stuff out for internship interviews. The more I can avoid STL functions, the better. I guess the problem is pretty straight forward if I use four parameters, I was just curious if I could get it in three.  If you're using vector slicing, you can do it in 2 parameters. For core algorithms, though, there is nothing to be gained by golfing parameter counts.  You can do it with one parameter. Just stuff everything into a struct and pass that...  If you want to do it recursive, your method needs to take the search range as parameters. Else you can't keep track of where to search in the rucursive call assuming you always give the full vector to the function.  7,70655 gold badges2626 silver badges3232 bronze badges  6  That's not necessary. Parameter for each recursive call doesn't have to be constant thus can mark the beginning of the range. And size can be used to deduce the end of the range.  but copying the vector is actually an error if you want something "optimal" as marked in the tags.  @Tobias Langner that's what references and pointers for... You don't have to pass the vector by value.  You would have to produce a new vector though, but the index returned would be of that vector not of the original one. so if you are not at the start of the range, you wouldn't know what to add to the offset if found. If it returned bool you could do that, but the function is supposed to return the index if found else return -1.  @CashCow Good point. This can be addressed by doing something like . Anyway, my point was that it's doable with the proposed function signature (there are probably some more errors in the original code).  Binary search basically works by dividing your range in 2 halves and searching in each one of them. Your code shows that you operate on the lower half for your both branches. You need to pass to the recursive call the higher half of your vector in the second as well as instead of .  17.5k33 gold badges3737 silver badges8181 bronze badges  1  Thanks, much. I knew I would feel like an idiot reading the response I'd get, but thanks nonetheless! Just a college student trying to learn stuff in the middle of the night.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  