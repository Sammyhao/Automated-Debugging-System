 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I understand the algorithm of building heap tree (max or min) but i don't understand the code of it:  First: How does this loop build a max heap?, why we started the i with n/2-1 ?  and this is the Heapify function:  Secondly: how did we assume that largest is "i" ?  Third: why we heapify again in the last line?  The code and the algorithm i got,is from GeeksForGeeks  3 Answers 3  Last level contains at most half of all items (), so item at index always is parent of the last items at the last level. And starting from that index and traversing left we are ordering three-items mini-heaps, then traversing up and left we are ordering 7-items heaps, ans so on.  2) It is simple initialization of conditional task - if we find larger descendant, it replaces parent  3) If parent has been replaced, it moved down, and might be smaller than new decendants, so we must check (small element sinks down)  Let's do this with a very simple example of building a max heap, which I think will answer your questions. Imagine you have the array . That corresponds to this binary tree:  The idea of the algorithm is to push things down the heap to their proper place. Your first question is why we start at . The simple answer is that any node at position greater than i//2 is a leaf; it has no children and therefore cannot be pushed down. Actually, we can start at , because if is even then the first non-leaf node is there, and for an odd number, .  So in this case, . Your next question is why we assume that the element at index is the largest. We don't. We start with that, because we have to find the largest of the three items (the item at and its two children). So we just default to . You could, if you want, set to the left child, and then do the comparisons. But there's no particular reason to do it that way. You have to start with something, and the item at index is the easiest.  In this case, the item at index is 6. We examine the item's children and find that 9 is larger, so we swap. The result is:  We decrement , giving us . Looking at the item there and its children, we see that 7 is the largest, so we swap the two items, giving:  And now we're at the root. 9 is the largest among the root and its children, so we swap:  And here's the answer to your third question: why the recursive call to ? You have to push the item down the heap as far as it will go. Here, 3 is smaller than 6, so we have to swap those items to give:  but you need to include , as a node may have just one child and goes all the way to zero, as all those nodes are parent nodes. As for recursion, you need to enforce the max-heap rule after a swap.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  