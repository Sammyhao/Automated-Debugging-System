 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Suppose I am given a undirected tree and I need to find a path(the only path) between two nodes.  What is the best algorithm to do it.I probably could use a Dijkstra's algorithm but there a probably something better for trees.  9,0452828 gold badges105105 silver badges191191 bronze badges  2  You mean finding THE path. Unless you allows for a path traversing the same node multiple times then there is just one path from a node to another in a tree (this is one of the possible definitions of tree, actually)  I posted an answer assuming you're interested also in paths that are partially "upward" even if there are no links to the parent node of a node in your representation. This is not indeed clear in the question...  3 Answers 3  Assuming each node has a pointer to its parent, then simply back-track up the tree towards the root from each start node. Eventually, the two paths must intersect. Testing for intersection could be as simple as maintaining a of node addresses.  UPDATE  As you've updated your question to specify undirected trees, then the above isn't valid. A simple approach is simply to perform a depth-first traversal starting at Node #1, eventually you'll hit Node #2. This is O(n) in the size of the tree. I'm not sure there's going to be a faster approach than that, assuming a completely general tree.  @Yakov: Well, yes, that clearly makes a difference! Glad to see you've updated your question accordingly.  Breadth-first search and depth-first search are more effective then Dijkstra's algorithm.  Isn't Dijksta's algo identical to Breadth-first search if all edge weights are one (or more general identical)?  It's not. If you use Dijkstra, you have to select the closest unvisited intersection (it's slow). So, the complexity is O(E + V logV), E - edges, V - vertices, if you use Fibonacci heap to extract minimum. If you use Breadth-first search, the complexity is O(E+V) = O(V) (it's a tree, so E = V - 1).  then what could be done is traversing the whole tree starting at root keeping the whole chain during the traversal. If you find e.g. node1 then you save the current chain, if you find node2 then you check for the intersection... in code (UNTESTED):  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  