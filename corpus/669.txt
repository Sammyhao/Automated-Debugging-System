 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Is there any standard Java library class to represent a tree in Java?  Specifically I need to represent the following:  The sub-tree at any node can have an arbitrary number of children  Each node (after the root) and it's children will have string value  I need to get all the children (some sort of list or array of Strings) of a given node and it's string value(i.e. a method that will take a node as input and return all the string values of the children node as output)  Is there any available structure for this or do I need to create my own (if so implementation suggestions would be great).  5,30933 gold badges1414 silver badges44 bronze badges  2  3  If you're using Java 8, and would like to traverse your nodes with streams, filtering, etc; then you might want to take a look at Durian github.com/diffplug/durian  25 Answers 25  That is a basic tree structure that can be used for or any other object. It is fairly easy to implement simple trees to do what you need.  All you need to add are methods for add to, removing from, traversing, and constructors. The is the basic building block of the .  132k5252 gold badges292292 silver badges322322 bronze badges  19  315  Strictly speaking the class is not necessary, because every can in itself be seen as a tree.  @Joa, I like having a structure to contain the root. You can add methods to the tree class that make more sense to call on a tree rather than a single node.  @Justin: for example? That's an honest question: I can't think of a single method that makes sense on the whole tree that doesn't make sense on a sub-tree.  I agree with @Joa that the Tree class is not necessary. I prefer to leave the recursive nature of trees explicit in code by not adding a separate Tree class and consistently using the Node class. Instead I name a variable 'tree' or 'root' if it needs to be clear that you are dealing with the root Node of a tree.  2,82611 gold badge1616 silver badges1717 bronze badges  6  2  Just found your library extremely useful. Thank you. But I would like to know how to implement dynamically populating the tree structure based on reference relationship between parent and child. Example given is I have one member1 sponsor another member2, and member2 sponsor member 3 and so and so for. Already have the table records relationship but just unsure i can populate them into a tree using your library.  In my view, this answer three years after the above higher rated answer, is the cleaner one. However, I would replace the LinkedList with an ArrayList for this.children.  I could be wrong but it appears that with this implementation, you must call before each call to to get valid results. This isn't part of the spec.  There is actually a pretty good tree structure implemented in the JDK.  Have a look at javax.swing.tree, TreeModel, and TreeNode. They are designed to be used with the but they are, in fact, a pretty good tree implementation and there is nothing stopping you from using it with out a swing interface.  Note that as of Java 9 you may wish not to use these classes as they will not be present in the 'Compact profiles'.  27k1111 gold badges7171 silver badges104104 bronze badges  11  5  Yeah I used them in the past, and they will do everything you want from a tree. The only downside I can think of is the length of the names of their respective implementing classes: DefaultTreeModel and DefaultMutableTreeNode. Verbose, but not that its all that important I guess.  Good way to cope with that is to create a couple of static methods newModel() and newNode() and then static import them.  I would avoid using Swing libraries on non-Swing-related functions. This is bad coding practice. You never know how Swing implements their trees, what their dependencies are and how this could change in the future. Swing is not a utility library but a UI library.  javax.swing.tree.TreeModel is a public interface (exactly like java.util.List) and it will not have incompatible changes. An added advantage is that you could easily debug/visualize your tree while developing.  It would have been great if this class had some documentation. I don't quite understand what methods like or do and this is the time when I really could get some help on tree data structures. Even the original source of the document has no comments.  I wrote a little library that handles generic trees. It's much more lightweight than the swing stuff. I also have a maven project for it.  90k3838 gold badges209209 silver badges289289 bronze badges  1  3  I am using it now, works brilliantly. Had to change the source significantly for my own customizations, but it was a great starting point. Thanks Vivin!  18.4k33 gold badges4848 silver badges7878 bronze badges  2  1  This suggests that the parent of a tree is a tree. I believe you were trying to create a Tree Node class.  @MadhurBhargava such a "Node" also represents a subtree hence a Tree. Though to have a separate top-level Tree class, and a separate Node class has two advantages: a redundant can be kept in Tree, And with the above one has to write something like for tree manipulations.  You should start by defining what a tree is (for the domain), this is best done by defining the interface first. Not all trees structures are modifyable, being able to add and remove nodes should be an optional feature, so we make an extra interface for that.  There's no need to create node objects which hold the values, in fact I see this as a major design flaw and overhead in most tree implementations. If you look at Swing, the is free of node classes (only makes use of ), as they are not really needed.  Mutable tree structure (allows to add and remove nodes):  Given these interfaces, code that uses trees doesn't have to care much about how the tree is implemented. This allows you to use generic implementations as well as specialized ones, where you realize the tree by delegating functions to another API.  Example: file tree structure  Example: generic tree structure (based on parent/child relations):  14.1k44 gold badges5050 silver badges7272 bronze badges  9  1  I'm facing an issue when I follow this structure when I do tree.add("A", "B"); tree.add("A", "C"); tree.add("C", "D"); tree.add("E", "A"); E is a parent of A How do we go about doing this?  Hi saNicks, there was a bug in the code above which caused the last relation not to be added. It's fixed now, and I also added non-null checks and (more important): cyclic checks which prevents violating the tree structure (adding a code or one of its ancestors as a child to itself). Thanks for the hint!  I fixed the bug if anyone is looking for a fix for that bug what you have to do is see if add method returns false and if it's false just create a temp new LinkedHashSet<N> and clone the tree's nodelist into it then u can clear the tree, add the parent node which did not get added in the previous step and then addAll of the tempNode back to the parent tree... Thanks for the structure though!  You can use any XML API of Java as Document and Node..as XML is a tree structure with Strings  72211 gold badge66 silver badges1818 bronze badges  1  5  excellent Idea, We could use in memory XML schema using dom4j + jaxen xpath to search nodes.  If you're doing whiteboard coding, an interview, or even just planning to use a tree, the verbosity of these is all a little much.  It should further be said that the reason a tree is not in there like, say, a (about which the same could be said), is because you should be encapsulating your data in the class using it, and the simplest implementation looks like:  That's really it for an arbitrary width tree.  If you wanted a binary tree it's often easier to use with named fields:  Or if you wanted a trie:  Now you said you want  to be able to get all the children (some sort of list or array of Strings) given an input string representing a given node  That sounds like your homework. But since I'm reasonably sure any deadline has now passed…  Along the same lines as Gareth's answer, check out DefaultMutableTreeNode. It's not generic, but otherwise seems to fit the bill. Even though it's in the javax.swing package, it doesn't depend on any AWT or Swing classes. In fact, the source code actually has the comment  There are a couple of tree data structures in Java, such as DefaultMutableTreeNode in JDK Swing, Tree in Stanford parser package, and other toy codes. But none of these are sufficient yet small enough for general purpose.  Java-tree project attempts to provide another general-purpose tree data structure in Java. The difference between this and others are  Totally free. You can use it anywhere (except in your homework :P)  Small but general enough. I put everything of the data structure in one class file, so it would be easy to copy/paste.  Not just a toys. I am aware of dozens of Java tree codes that can only handle binary trees or limited operations. This TreeNode is much more than that. It provides different ways of visiting nodes, such as preorder, postorder, breadthfirst, leaves, path to root, etc. Moreover, iterators are provided too for the sufficiency.  More utils will be added. I am willing to add more operations to make this project comprehensive, especially if you send a request through github.  Since the question asks for an available data structure, a tree can be constructed from lists or arrays:  can be used to determine whether an element is a subtree or a terminal node.  1,85911 gold badge1515 silver badges2323 bronze badges  2  2  Quite ugly. And doesn't work, if your data objects may be arrays respectively lists.  I agree that it's ugly. The s would either be the leaf objects (for example, s) or branches (represented by arrays). And it does work: that code will compile, and it creates a small tree of s.  I wrote a small "TreeMap" class based on "HashMap" that supports adding paths:  It can be use to store a Tree of things of type "T" (generic), but does not (yet) support storing extra data in it's nodes. If you have a file like this:  Then you can make it a tree by executing:  And you will get a nice tree. It should be easy to adapt to your needs.  In the past I have just used a nested map for this. This is what I use today, it is very simple but it fits my needs. Maybe this will help another one.  You can use the HashTree class included in Apache JMeter that is part of the Jakarta Project.  HashTree class is included in the package org.apache.jorphan.collections. Although this package is not released outside the JMeter project, you can get it easily:  3) Copy on it /src/jorphan/org/apache/jorphan/collections/ . All files except Data.java  4) Copy also /src/jorphan/org/apache/jorphan/util/JOrphanUtils.java  There is no specific data structure in Java which suits to your requirements. Your requirements are quite specific and for that you need to design your own data structure. Looking at your requirements anyone can say that you need some kind of n-ary tree with some specific functionality. You can design your data structure in following way:  Structure of the node of the tree would be like content in the node and list of children like: class Node { String value; List children;}  You need to retrieve the children of a given string, so you can have 2 methods 1: Node searchNode(String str), will return the node that has the same value as given input (use BFS for searching) 2: List getChildren(String str): this method will internally call the searchNode to get the node having same string and then it will create the list of all string values of children and return.  You will also be required to insert a string in tree. You will have to write one method say void insert(String parent, String value): this will again search the node having value equal to parent and then you can create a Node with given value and add to the list of children to the found parent.  I would suggest, you write structure of the node in one class like Class Node { String value; List children;} and all other methods like search, insert and getChildren in another NodeUtils class so that you can also pass the root of tree to perform operation on specific tree like: class NodeUtils{ public static Node search(Node root, String value){// perform BFS and return Node}  Please do not just dump code - explain what it does, and especially why it differs (is better) than all the other answers.  I wrote a tree library that plays nicely with Java8 and that has no other dependencies. It also provides a loose interpretation of some ideas from functional programming and lets you map/filter/prune/search the entire tree or subtrees.  The implementation doesn't do anything special with indexing and I didn't stray away from recursion, so it's possible that with large trees performance will degrade and you could blow the stack. But if all you need is a straightforward tree of small to moderate depth, I think it works well enough. It provides a sane (value based) definition of equality and it also has a toString implementation that lets you visualize the tree!  Please check the below code, where I have used Tree data structures, without using Collection classes. The code may have bugs/improvements but please use this just for reference  "without using Collection classes" Ah? So where the Queue class comes from? And as said above, it is a binary tree, failing at first requirement (any number of children nodes).  You can use TreeSet class in java.util.*. It is working like Binary search tree, so it is already sorted. TreeSet class implements Iterable, Collection and Set interfaces. You can traverse through the tree with iterator like a set.  Your answer could be improved with additional supporting information. Please edit to add further details, such as citations or documentation, so that others can confirm that your answer is correct. You can find more information on how to write good answers in the help center.  Custom Tree implement of Tree without using the Collection framework. It contains different fundamental operation needed in Tree implementation.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  