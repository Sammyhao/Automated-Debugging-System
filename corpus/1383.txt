 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  In an algorithms course I'm taking, it's said that depth-first search (DFS) is far more space efficient than breadth-first search (BFS).  Why is that?  Although they are basically doing the same thing, in DFS we're stacking the current node's successors while in BFS we're enqueueing the successors.  3 Answers 3  Your confusion is stemming from the fact that you apparently assume that DFS algorithm can be obtained from BFS algorithm by replacing the FIFO queue with a LIFO stack.  This is a popular misconception - it is simply not true. The classic DFS algorithm cannot be obtained by replacing the BFS queue with a stack. The difference between these algorithms is much more significant.  If you take a BFS algorithm and simply replace the FIFO queue with a LIFO stack, you will obtain something that can be called a pseudo-DFS algorithm. This pseudo-DFS algorithm will indeed correctly reproduce the DFS vertex forward traversal sequence, but it will not have DFS space efficiency and it will not support DFS backward traversal (backtracking).  Meanwhile, the true classic DFS cannot be obtained from BFS by such a naive queue-to-stack replacement. The classic DFS is a completely different algorithm with significantly different core structure. True DFS is a genuinely recursive algorithm that uses stack for backtracking purposes, not for storing the vertex discovery "front" (as is the case in BFS). The most immediate consequence of that is that in DFS algorithm the maximum stack depth is equal to the maximum distance from the origin vertex in the DFS traversal. In BFS algorithm (as in the aforementioned pseudo-DFS) the maximum queue size is equal to the width of the largest vertex discovery front.  The most prominent and extreme example that illustrates the difference in peak memory consumption between DFS and BFS (as well as pseudo-DFS) is a star-graph: a single central vertex surrounded by a large number (say, ) of peripheral vertices, with each peripheral vertex connected to the central vertex by an edge. If you run BFS on this graph using the central vertex as origin, the queue size will immediately jump to . The same thing will obviously happen if you use pseudo-DFS (i.e. if you simply replace the queue with a stack). But classic DFS algorithm will need stack depth of only (!) to traverse this entire graph. See the difference? versus . This is what is meant by better space efficiency of DFS.  Basically, take any book on algorithms, find a description of classic DFS and see how it works. You will notice that the difference between BFS and DFS is far more extensive that a mere queue vs. stack.  P.S. It should also be said that one can build an example of a graph that will have smaller peak memory consumption under BFS. So the statement about better space efficiency of DFS should be seen as something that might apply "on average" to some implied class of "nice" graphs.  298k3939 gold badges502502 silver badges744744 bronze badges  12  7  Something worth noting - Pseudo-DFS should give you space, as opposed to for proper DFS, which is still better than . Seems your answer says something similar, although I think this is more brief and clear.  Note that although true DFS is often better implemented using recursion, it is not a necessary characteristic of true DFS. You can certainly implement true DFS without any recursion. The defining characteristic that separates true DFS and what you call pseudo DFS is how they use the stack. True DFS use it to store backtracking information in contrast to pseudo DFS which used the stack to store the vertex discovery front.  @Lie Ryan: I don't want to mix algorithm itself and implementation of algorithm. When I say "recursion" is refer to algorithmic recursion, not language recursion. I.e. by recursion I mean any algorithm that is based on divide-and-conquer strategy and uses non-constant-size stack (LIFO) to store postponed tasks. Such algorithm is inherently "recursive" by nature, regardless of whether it is implemented through language recursion or manual stack.  Recursion is still using a stack even if it is not explicit... (or uses the heap if your language requires it)  According to Artificial Intelligence - A Modern Approach, DFS is in fact BFS with a LIFO queue instead of a FIFO queue... The algorithm you are decribing they call backtracking search.  In DFS you need only space for linear to the depth on a fully balanced tree while BFS (Breadth-first search) needs (The widest part of the tree is the lowest depth which has in a binary tree n/2 nodes).  Example:  DFS needs space: 4 BFS needs in the second last row space 8  And it gets worse if the branching factor is higher  9,43666 gold badges3636 silver badges4848 bronze badges  3  2  For BFS, you need to store each element in the last row as well (because after visiting all elements in the second-last row, the queue will contain all elements in the last row), so it'll be 16, not 8. If you know the maximum depth of your tree beforehand, you can probably optimize this, but it doesn't happen in standard implementations.  @Dukeling: Depends a little on your implementation. If you store the nodes still to visit or the nodes you have visited but not their children. But it makes no difference in the -Notation .  "the nodes you have visited but not their children" - I don't think I've ever seen that done before, but it does actually make perfect sense (more sense, in fact, than the alternative).  In DFS, the space used is O(h) where h is the height of the tree.  In BFS, the space used is O(w) where w is the 'width' of the tree.  In typical binary trees (i.e. random binary trees), w = Omega(n) and h = O(sqrt(n)).  this Q&A suggests the expected height of a random binary tree is O(log n), not O(sqrt(n)).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  