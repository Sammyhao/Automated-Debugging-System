 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have searched throughout the web quite a bit and have found so many different examples of implementation in modern c++. I have started to update all of my code starting with into the and etc. However, with the smart pointers I don't think I understand exactly what I am suppose to be doing.  With a standard pointer I have:  Then with the new smart pointer I have:  Is this not the correct way of implementation? If so, it seems to be more typing / work to make smart pointers when I have a simple cleanup function built at the end of my program?  A big reason to use even though "you could do the cleanup yourelf" is that it clearly conveys the ownership semantics involved (i.e., it's self documenting code) as well as guarantees you don't have to worry about remembering to do any cleanup.  You should probably be using instead of directly calling the constructor to completely remove & :  If so, it seems to be more typing / work to make smart pointers when I have a simple cleanup function built at the end of my program?  As your program becomes bigger and bigger the odds that you will forget to something you created with will get bigger and bigger which is why a is there to help you. And remember, writing less lines of code doesn't mean the code is better.  A smart pointer is an RAII (Resource Allocation is Initialization) container which guarantees that the contained resource is deallocated when the the object goes out of scope. Consider a function that has multiple exit points or the situation where an exception in thrown at some point inside of the function. If cleanup is performed with an explicit call to a dedicated function, that function must be carefully called at every exit point. Furthermore, to insure that resources are not leaked if exception is thrown, that cleanup function must also be called in the exception handler (not to mention that exceptions need to be explicitly handled). With smart pointers, resources will not be leaked if an exception is called since they will be automatically handled when the stack is unwound and the objects fall out of scope.  Smart pointers create a clean abstraction which isolates messy resource management to a low level and insures that resources are not inadvertently leaked.  The initialization syntax overhead is minimal compared to the additional code which would be required to guarantee that resources would be similarly managed with owning raw pointers.  Smart pointers make C++ code safer, smaller, and more maintainable.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  