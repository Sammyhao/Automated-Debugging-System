 Rat in a Maze | Backtracking using Stack  Prerequisites – Recursion, Backtracking and Stack Data Structure. A Maze is given as N*M binary matrix of blocks and there is a rat initially at (0, 0) ie. maze[0][0] and the rat wants to eat food which is present at some given block in the maze (fx, fy). In a maze matrix, 0 means that the block is a dead end and 1 means that the block can be used in the path from source to destination. The rat can move in any direction (not diagonally) to any block provided the block is not a dead end. The task is to check if there exists any path so that the rat can reach the food or not. It is not needed to print the path. Examples:  This is the famous Rat in a Maze problem asked in many interviews that can be solved using Recursion and Backtracking. We already have discussed a Backtracking solution to this problem using recursion in Rat in a Maze | Backtracking-2. In this an iterative solution using stack is discussed. In the previous article, Recursion uses a call stack to keep the store each recursive call and then pop as the function ends. We will eliminate recursion by using our own stack to do the same thing. A node structure is used to store the (i, j) coordinates and directions explored from this node and which direction to try out next.  Structure Used:  X : x coordinate of the node  Y : y coordinate of the node  dir : This variable will be used to tell which all directions we have tried and which to choose next. We will try all the directions in anti-clockwise manner starting from Up. Initially it will be assigned 0.  If dir=0 try Up direction.  If dir=1 try left direction.  If dir=2 try down direction.  If dir=3 try right direction.  Initially, we will push a node with indexes i=0, j=0 and dir=0 into the stack. We will move to all the direction of the topmost node one by one in an anti-clockwise manner and each time as we try out a new path we will push that node (block of the maze) in the stack. We will increase dir variable of the topmost node each time so that we can try a new direction each time unless all the directions are explored ie. dir=4. If dir equals to 4 we will pop that node from the stack that means we are retracting one step back to the path where we came from. We will also maintain a visited matrix which will maintain which blocks of the maze are already used in the path or in other words present in the stack. While trying out any direction we will also check if the block of the maze is not a dead end and is not out of the maze too. We will do this while either the topmost node coordinates become equal to the food’s coordinates that means we have reached the food or the stack becomes empty which means that there is no possible path to reach the food. Below is the implementation of the above approach:  C++  Java  C#  Python3  Output:  Note: We can also print the path by just popping the nodes out of the stacks and then print them in reverse order. Time Complexity : O(). Auxiliary Space: O().  Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here.  We use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy Got It !  