 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have the tree that has a lot of nodes (millions+) and needed to be loaded into the memory. Thus, I need the most efficient way to store nodes and their relations in memory. What is the best data structure for that? By now, I have two options:  Note, that I need to perform such operations on this tree as browsing, deleting and inserting, and I need these to be fast enough.  Edit: optimal for this case is using less RAM to store the whole tree. The second criteria is fast delete, browse and insert operations - they should not take a lot more time then in data structures I wrote above. I can't formulate this criteria stricter  Your standard tree algorithms will work, but it might be a lot easier on the GC if you make your nodes structs in a single and refer to them with indexes rather than references.  Very vague question. "Optimal" does not make sense without given optimality criterion. "Fast enough" is also completely unclear.  Well, optimal for this case is using less RAM to store the whole tree. The second criteria is fast delete, browse and insert operations - they should not take a lot more time them in data structures I wrote above. I can't formulate this criteria stricter  2 Answers 2  It sounds like you have a mutating, in-memory set of data. If this is so, then knowing which operations are common will be very important. For example, when you mention "browse", is that a search, or is it a simple traversal to a parent or child from the node you are currently looking at?  If it's a search, and if that's commonly the first operation (i.e. you find a node with a value, and then you do something to it) then you might consider using a Red/Black Tree. This structure take log n time for search, insert, and delete. The rules that are imposed during insertion and deletion keep the tree optimized for searching.  If search speed is not important, then you can speed up insertion and removal using a simpler tree structure.  So far as your space concern, the Red/Black tree, like just about every other tree structure, takes n space. This is about as well as you can do for the structure itself. Take heart, though, because you can take creative measures.  For example, you are storing 3 bytes and a string in each node. Is it possible for you to store only a subset of this data in memory, and look up the rest of the data from persistent storage (a database, for example) as needed? It would have to be data unnecessary for the standard tree operations, but maybe it's doable. Alternatively, Is it possible to compress the string data in memory?  Thanks for hints. The most common operations for my case are browsing (up and down the tree) and inserting, as I often need to merge several trees. Also, search by additional info contained in those 3 bytes. Yes, I was thinking about optimization of these additional 3 bytes and a string, but actually the most of space is consumed by class references (string ref, next and firstchild refs). What I'm thinking of doing for further optimization is caching parts of the tree after loading (for instance, nodes with depth > 40 or some other criteria) and loading them again after the first request.  That will slow down search and loading, but I think its possible to find a good compromise.  It's been quite a while since I've worked directly with C++ type of structures, but when I did, I was working with btree structures. The premise is similar, but at a single node, you can have say...8 (or more) keys per level. but if you are dealing with millions of entries, might be something to look into?  The premise say at top-level node you have 8 keys... and for simplicity of mentally understanding a tree of 90k entries, the top-level node are 10k, 20k, 30k... 80k. So if the number you are looking for is less than 10k, it goes down it's leg... less than 20k goes down it's leg, etc. So by testing a few elements available at a single node level, you can basically throw out the other 80k.  So, take for example you are looking for 26,895. It starts at top node and gets the 30k which you want (less than 30k, but more than 20k). Now that loads the next node. But this node spans 20,001 to 29,999. For grins, it's key breaks are 21250, 22500, 23750, 2500, 26250, 27500, 28750, 29999. (breaks of 1250 each). So now you hit the 27500 that you are less than and it goes one more level deep. This level now spans your gap of 26250 to 27499 and you are only the second level in.  You would obviously need a book or stronger reference to complete, but btrees can be quite powerful and fast.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  