 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Can you please let me know what is incorrect in below DFS code. It's giving correct result AFAIK, but I don't know when it will fail.  Thanks for the response.. visited = [] def dfs(graph,node,visited): if node not in visited: visited.append(node) for n in graph[node]: dfs(graph,n,visited) dfs(graph1,'A',visited) print(visited)  I'm also not convinced that the output you show is generated by the data you show - I don't see where S, H and G come from? (But I could possibly be wrong here)  Hi Willem, if you checkout the link eddmann.com/posts/… there a sample code for the DFS is given but If I change the graph as given in youtube tutorial "youtu.be/iaBEKo5sM7w" I am not getting the result as mentioned. So I thought of writing my own version based on the tutorial.  9 Answers 9  I think you have an indentation problem there. Assuming your code looks like this:  I would say a couple of things:  Avoid globals if you can  Instead of a list for visited, use a set  plus:  This will not work for forests but I assume you already know that  It will fail if you reference a node that does not exist.  @Juan Leni or anyone listening: In the for loop of your code, how is variable n not stuck in values between 'B' and 'A' and how come it jumps to 'S' in the third iteration?  This is the modification for the above code because that doesn't work with in all cases. We have to specify the number of vectors and then give edges manually.  Here is a more versatile algorithm, the one asked in the question works only for undirected graphs. But this hopefully works for both them. Check it out  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  