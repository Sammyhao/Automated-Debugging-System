 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a binary tree written in c# with nodes defined with IComparable data. It all works just fine in the sense that I can populate the tree with any data type I like (although I've only tried populating it with a single type of data at a time) and perform functions like finding the depth, in-order searching, counting leaves, etc.  I'm trying to write a function to find a data value in the tree using a recursive algorithm. The algorithm finds the data, but then does not stop when the data is found. There is one exception -- when the data is in the root node. I can't figure out where it is going wrong. The function reports that it found the data, at which point it is supposed to return that node and quit, but it keeps going looking in the children nodes.  Thanks to the accepted answer, here is the working code I have:  Also, you need to compare to the current node and then search the left or right sub-tree depending on the result if this wasn't the value you were searching for.  @ciamej -- 'cause I'm a dumb dumb? I don't need the 2nd call I should just return node.  4 Answers 4  A Binary Search Tree has certain properties. The property that's important here is that for each node, everything in that node's left subtree is smaller than the node's value and everything in its right subtree is larger (according to the comparer).  You only ever have to look in one subtree. Use that property to find the item you're looking for:  Bonus: instead of a recursive method, here's an iterative Search function from my own implementation: (It's also generic)  Thanks for pointing that out. Very elegant. I've added my working code to the question.  Instead of looking down the left and right, then checking to see if it was found you should look down the left only. If it is found there, return that, otherwise look down the right. If it is there, return that, otherwise return null. Your would look something like this:  should be returning either if the value isn't found or the correct if the value is found. There's no reason to do a comparison of the values of the right and left child nodes, because the recursive call on the children nodes will check the value of the children on its own. It will also fail and throw a NullReferenceException whenever a node is encountered without both children. Lastly, your call is searching the tree twice.  I would replace your code with this:  It should also be mentioned that this doesn't qualify as a binary search tree. It will perform a depth-first search, ending only when the value is found or the entire tree has been visited.  That seems...complicated to me, what with the double calls and all.  It's important to note that every node of a tree is itself a tree. There's no difference between the root node of the tree and any other node of the tree. You just have to do the walk once. Like many recursive problems, the tree walk has two cases:  The special case: The tree is empty ().  The general case: The tree is non-empty.  Consequently, the tree walk logic is this:  The Special Case. If the root (current) node is null, the search failed. return null.  The General Case. Compare the root (current) node's payload to the desired value.  EQUAL: A Hit! Return the root (current) node.  LESS THAN: A miss. Return the results of visiting the left child.  GREATER THAN: A miss. Return the results visiting the right child.  That's all there is to it. Given a node structure like this:  The tree search code shouldn't be much more difficult than this  Further, given that this search is directed, so you've got no need to keep track of parent nodes and no need to be able to backtrack on alternatives, the code can easily be iterative and as simple as this:  63.2k1313 gold badges8787 silver badges128128 bronze badges  1  My next task is to do the algorithm where I keep track of the parent because I need to implement my delete method ;)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  