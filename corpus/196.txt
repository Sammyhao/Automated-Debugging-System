 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I've defined a class called ClusterSet that just has one field, called :  In my method, I use to allocate memory for the inner map, and store this pointer in . I defined a destructor so that I can deallocate all this memory:  When my destructor is called, it seems to deallocate all the inner maps correctly (it prints out "Deleting members for..." for each one). However, once that's done I get a runtime error that says "failed to "munmap" 1068 bytes: Invalid argument". What's causing this?  I have briefly looked at the "rule of three" but I don't understand why I would need a copy constructor or an assignment operator, or how that might solve my problem. I would never need to use either directly.  Even if you don't think you're copying your object, there are all sorts of places where you might be. And what about when you do in the future? I don't see a reason why that pointer is necessary in the first place, but at least use a smart pointer.  Note that you can create a private copy constructor and assignment operator so that the compiler can tell you where the "hidden" copies are being made.  – user406009  Aug 8 '13 at 18:01  1  "I would never need to use either directly" - maybe not, but it's very easy to write code that uses them indirectly. At the very least, you should delete them to prevent invalid copying.  Also, "I use to allocate memory for the inner map." Why on earth would you do that? Just store map objects, and all your copying woes are fixed by the Rule of Zero.  1 Answer 1  There's no good reason (and plenty of disadvantages) for dynamically allocating the inner maps. Change the outer map type to  and then you won't need to implement your own destructor and copy/move semantics at all (unless you want to change those you get from the map, perhaps to prevent copying your class).  If, in other circumstances, you really do need to store pointers to objects and tie their lifetime to their presence in the map, store smart pointers:  If you really want to manage their lifetimes by hand for some reason, then you will need to follow the Rule of Three and give your class valid copy semantics (either preventing copying by deleting the copy constructor/assignment operator, or implementing whatever semantics you want). Even if you don't think you're copying objects, it's very easy to write code that does.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  