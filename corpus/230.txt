 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Is there a way to declare a whose value type is an iterator to itself?  The above code snippet wouldn't work because the iterator type needs to know the second template argument, marked as . (which would be itself).  The intent is to avoid doing unnecessary operations to access the element that is pointed to by another element — as opposed to using .  No, it is not possible. The definition of the iterator of such map would be infinitely recursive. Maybe using some indirection trick, this could be effectively simulated.  its basically equivalent to a , the only difference is that finding the key string for a value is logarithmic instead of constant, I have no clue what you want to do, but I would suggest to consider whether using anything more complicated than a is worth the effort  2 Answers 2  Such definition is not possible, since the value type and the iterator type would be mutually infinitely recursive.  It is possible to work around this using a bit of indirection. It is even possible to avoid the dynamic allocation of , and the fact that is undefined unless is complete.  But the solution is a bit tricky, and relies on some assumptions which are reasonable, but not specified by the standard. See comments in the implementation. The main trick is to defer definition of a member variable type until after definition of the enveloping class. This is achieved by reusing raw storage.  Usage first:  Definition  Old answer; This assumed that it was not an important feature to avoid lookups while traversing stored mappings.  It appears that the data structure that you attempt to represent is a set of keys (strings), where each key maps to another key of the set. Easier way to represent that is to separate those two aspects:  Note that these two data structures do not automatically stay in sync. An element added to the set doesn't automatically have a mapping to another, and an element erased from the set leaves dangling iterators to the map. As such, it would be wise to write a custom container class that enforces the necessary invariants.  204k1111 gold badges156156 silver badges278278 bronze badges  5  Wouldn't it be better to use ? Otherwise, to find a certain element's "match", one would first have to it in the set, and then the corresponding iterator in the map. But as a compromise, there would be duplicate strings...  @Anakhand depends on what kinds of operations you want to perform. On the other hand, why not just ?  I did use initially, but I am trying to see if I can improve the performance by avoiding unnecessary operations (i.e., accessing the element pointed to by another element). But I guess logarithmic time is not so bad if it can simplify the program...  @Anakhand I think it may be possible (as I mentioned in comment to question), but it requires something clever, and plenty of work. I'll investigate when I have free time.  Only through type erasure. For example, you could use  EDIT: The following also seems to work (clang-7.0.0 and gcc-8.2), but it is illegal (basically does not specify that incomplete types are allowed):  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  