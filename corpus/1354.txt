 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Seems they both let you retrieve the minimum, which is what I need for Prim's algorithm, and force me to remove and reinsert a key to update its value. Is there any advantage of using one over the other, not just for this example, but generally speaking?  90733 gold badges1212 silver badges1414 bronze badges  3  1  Note that a does not require you to remove and reinsert a key to update its value. A call will update the value for a key if it (or an "equal" key value) is already in the map.  hmm, then that means i can't have values with the same key, whereas in a priority queue i think i can.  You can use a custom comparator to solve this and wrap your key in an object (maybe solve ties by edge id for example.)  9 Answers 9  Generally speaking, it is less work to track only the minimum element, using a heap.  A tree is more organized, and it requires more computation to maintain that organization. But if you need to access any key, and not just the minimum, a heap will not suffice, and the extra overhead of the tree is justified.  254k5353 gold badges378378 silver badges475475 bronze badges  4  11  "it is less work to track only the minimum element, using a heap" - More specifically a PriorityQueue allows you to peek at the head element in constant time. A TreeMap requires O(logn) to peek. They both require O(logn) anytime you actually pop that element off.  @JMess "A TreeMap requires O(logn) to peek.": Incorrect. TreeMap/TreeSet does that using .first() or .last() in O(1) stackoverflow.com/a/14379571/5649620  @VyshnavRameshThrissur JMess was correct stating that heap is constant time for access to the head, while tree is log(n). What Pete was pointing out in his answer is that a constant number of comparisons (zero) are performed during the traversal to first or last; traversing to the head unconditionally takes the “left” node. But the traversal time still scales as log(n). Comparisons matter because they can take so much longer than tree traversal, but they don’t negate the time complexity difference for a peek at the head.  Looking at the source code of TreeMap and TreeSet we see TreeSet.first() calls TreeMap.firstKey() which as @erickson correctly points out does no comparisons, but does have to traverse to the leftmost leaf node.  (1) PriorityQueue can have duplicates where as TreeSet can NOT have dups. So in Treeset, if your comparator deems 2 elements as equal, TreeSet will keep only one of those 2 elements and throw away the other one.  (2) TreeSet iterator traverses the collection in a sorted order, whereas PriorityQueue iterator does NOT traverse in sorted order. For PriorityQueue If you want to get the items in sorted order, you have to destroy the queue by calling remove() repeatedly.  I am assuming that the discussion is limited to Java's implementation of these data structures.  34111 gold badge44 silver badges1010 bronze badges  1  1  Is there a standard data structure that provides log(N) time for removing as TreeSet does but also allows equal (from the method prospective) elements?  Totally agree with Erickson on that priority queue only gives you the minimum/maximum element.  In addition, because the priority queue is less powerful in maintaining the total order of the data, it has the advantage in some special cases. If you want to track the biggest elements in an array of , the time complexity would be and the space complexity would be . But if you do it in a map, the time complexity is and the space is . This is quite fundamental while we must use priority queue in some cases for example is just a constant like 10.  good note, but you could mimic this behavior for space with a TreeMap too. Just manually remove biggest elements after a certain size is reached.  TreeMap maintains all elements orderly. (So intuitively, it takes time to construct it)  PriorityQueue only guarantees min or max. It's less expensive but less powerful.  It all depends what you want to achieve. Here are the main points to consider before you choose one over other.  PriorityQueue Allows Duplicate(i.e with same priority) while TreeMap doesn't.  Complexity of PriorityQueue is O(n)(when is increases its size), while that of TreeMap is O(logn)(as it is based on Red Black Tree)  PriorityQueue is based on Array while in TreeMap nodes are linked to each other, so contains method of PriorityQueue would take O(n) time while TreeMap would take O(logn) time.  49511 gold badge55 silver badges1212 bronze badges  1  interesting, the only answer that points out a real big O disadvantage for TreeMap. Do you have a source for the space complexity of a TreeMap?  One of the differences is that remove(Object) and contains(Object) are linear O(N) in a normal heap based PriorityQueue (like Oracle's), but O(log(N)) for a TreeSet/Map.  So if you have a large number of elements and do a lot of remove(Object) or contains(Object), then a TreeSet/Map may be faster.  So my answer would be, look at the use-case, and see if that could be done without key and value, if yes, go for PQueue else move to TreeMap.  It depends on how you implement you Priority Queue. According to Cormen's book 2nd ed the fastest result is with a Fibonacci Heap.  I find TreeMap to be useful, when there is a need to do something like:  find the minimal/least key, which is greater equal some value, using ceilingKey()  find the maximum/greatest key, which is less equal some value, using floorKey()  If the above is not required, and it's mostly about having a quick option to retrieve the min/max - PriorityQueue might be preferred.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  