 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am facing a problem while converting a given 2D matrix containing both invalid and valid points into a graph with only valid nodes. The problem goes like this. I have a 2D matrix like  I want to find the shortest distance from S to E keeping in mind that I have to cover all 'C' and '#' acts as a wall and '.' acts as free path. Now I want to convert this matrix into a graph containing only the valid nodes. Kindly help me out.  Approach: Finding the all pair shortest path in the resulting graph. Floyd Warshall (I guess). The maximum number of nodes can go to 1000. But the maximum number of C nodes is 20. What would be the best algorithm for this.  You will have to at least show an attempt at solving the problem youself before people will help you  4 Answers 4  A 2d matrix of the characters is a perfectly fine graph representation for this problem.  Each matrix element (i,j) is a node. Assuming you can only step East, West, North, South, there exist 0 to 4 undirected edges from this node to its neighbors (i +or- 1, j +or- 1) as determined by simply testing the character in each location.  You could also test for i,j values that are out of range (negative or too big), but if there is always a "wall" around the border as you have shown, this is not needed. The wall serves as a sentinel.  Building a general purpose structure to represent a graph embedded in a grid is a waste of time and memory.  In order to make the graph, you have to generate a node for each non-wall space. Go through the 2D matrix (assuming it's just a char array) and create nodes and add edges:  With a 2D array of nodes, you can then go through and add neighbors with findNeighbors:  Now, after all that code, you have a 2D array of Node objects that represent a graph. You could store the Start node in an instance variable to keep a handy reference to it and easily access its neighbors.  With the code I wrote, the Node class will need a method that adds the argument node to a list of nodes.  +1 I was writing similar answer. Though, I wouldn't make it 's responsibility to remember what type it is. Instead, I would store the start and end nodes in variables (possibly in an object) and the coverables in a set.  This looks like a homework but for the sake of conversation (time/space complexity) I would do something different. First I would create a Graph that only contains valid edges between nodes that can be a path (e.g. not a wall). This minimize the space needed. I won't use a matrix because it uses too much space in real graph (sparse) and the time complexity is ROW*COL (V^2 for a square matrix).  With this in-place the creation of the graph follows the idea of previous post,  Now the only thing left is to find the Shortest Path...using BFS of this undirected-graph with no negative weighed edges...  I would either create a node struct, or a node class. For example:  As far as filling this data structure, I would start at the 'S' block. And make a recursive call kind of like:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  