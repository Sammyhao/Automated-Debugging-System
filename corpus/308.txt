 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm now implementing Barnes-Hut Algorithms for simulating N-body problem. I only want to ask about the building-tree part.  There are two functions I made to build the tree for it.  I recursively build the tree, and print the data of each node while building and everything seems correct, but when the program is back to the main function only the root of the tree and the child of the root stores the value. Other nodes' values are not stored, which is weird since I printed them during the recursion and they should have been stored.  Here's some part of the code with modification, which I thought where the problem might be in:  Here's the function set_root_and_build():  I've set the child pointers to NULL, but didn't show it at first.  And build:  Nodes in the tree may have 1~2 children, not all have 2 children here.  The program prints out the correct data when it's in function recursion, but when it is back to main function and calls , it fails due to a segmentation fault.  I tried to print everything in and found that only the root, and root.child1, root.child2 stores the value just as what I've mentioned.  Since I have to called several times, and even in parallel, new1 and new2 can't be defined as global variables. (but I don't think they cause the problem here).  Thanks you guys, I'll change the tag. but my code is .cpp file, is it still ok if I use malloc like this?  2 Answers 2  You may not be properly setting the children of when the condition does not hold. You might want this instead:  Of course, you should be checking the return values of malloc() and handling errors too.  Also, your traversal is a bit strange as it recurses by copy rather than reference. Do you have a good reason for doing that? If not, then maybe you want:  Thanks, I did set default value for each new node. You're right, I always allocate two child nodes, but not ensure that it should be kept in the tree. But I think that would be okay... As for the malloc, I do print the data in it so I think it worked.  @cshushu That's good, but you don't link your children to their parent unconditionally. In your code, move the n->child1 = new1; and n->child2 = new2; outside of the if (condition).  Not all nodes have 2 children, I'm sorry that I didn't show what I actually mean , I've edit the code and add the comment.  What should happen to children when their condition does not hold? Are you free'ing them as they will be lost / leak otherwise?  I just left it and didn't link it to any node, I modified it so that they're freed , but didn't change anything :(  The problem in your tree traversal is that you certainly process the tree until you find a node pointer which is NULL.  Unfortunately when you create the nodes, these are not initialized neither with nor with (it would be initialized with but this practice in cpp code is as bad as ). So your traversal continues to loop/recurse in the neverland of random pointers.  I propose you to take benefit of cpp and change slightly your structure to:  And later get rid of your old mallocs. And structure the code to avoid unnecessary allocations:  Be aware however that poitners allocated with should be released with and note with .  Edit: There is a mismatch in your code snippet:  Check that you didn't overllok some warnings from the compiler, and that you have no abusive cast in your code.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  