 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  It was suggested to me to use pointers to add a vector that I wanted to pass from some existing function to another function. I am really stuck on how to get the information back out of that pointer though. I've tried a number of things I've read here and there so let me demonstrate what I'm talking about.  primary program:  secondary program (track, calculate)  back to primary, unless I messed up something above, here's some things I've tried  1  2  and a bunch of stuff that just plain didn't compile. I'm quite stuck as I'm not sure how to get the specific values out of that vector in the main program. I even thought it might be the if(! (dvertex==NULL)) bit, so I changed it to if(dvertex==NULL) but still no joy. Any help would be greatly appreciated.  *Edit/Update*Thanks so much everyone for the help, but I fear I'm still doing it wrong.  So following the suggestions that I just pass a reference: I did this:  primary  secondary stayed the same (with !Null check)  primary  (among other attempts to actually use the data)  Thanks a lot for any thoughts on what I'm still doing improperly. Everything compiles, the program just freezes when it gets to a point that the data from dvertex is used.  75311 gold badge66 silver badges1818 bronze badges  4  3  Not to throw more suggestions at you, but you should pass it in as a reference. Then there's no need to dereference anything, and you get all of the same benefits.  @jonsca is right, you should do something like track::caclulate(irrelevant stuff, vector<float> & dvertex), then is as simply as treat dvertex as a normal vector and the work made with it will still be available outside the method.  Sometimes I do like to pass by pointers if the container will be modified. At the call site that usually requires the use of the address operator: This is a small reminder that the function actually modifies the container. If you always pass by reference, you can't distinguish between modifying and non-modifying calls without looking at the function declaration. However, this is purely a matter of style, there is no performance benefit.  @dappawit: Then the function should be better named. I don't need to look at the signature to know is going to modify the arguments.  3 Answers 3  I'm not sure why these didn't compile for you, because they're valid as long as the pointer is valid and not null:  But never mind that. Use a reference if you must change the vector, and a const reference if you must not. There's rarely if ever a need to take a container by pointer.  Also, I suggest you check pointers against , not , because sometimes is defined as as per C compilers. But some people may argue otherwise here.  54.6k2020 gold badges9292 silver badges128128 bronze badges  4  C compilers may define NULL as , but C compilers ≠ C++ compilers. A conforming C++ compiler must define NULL as "an implementation-defined C++ null pointer constant" (C++03 standard §18.1/4). Since 0 is also a valid null pointer constant, there is no technical reason to prefer either 0 or NULL—the choice is purely stylistic. I personally prefer NULL because it explicitly conveys that you are dealing with a pointer, whereas with 0 it's not always clear from context whether you're dealing with an integer or a pointer.  I prefer the check for NULL it is visually more distinctive (waiting for nullptr)  @AdamRosenfield If 0 is not implementation defined and is, isn't that a technical reason good enough to choose 0 over ?  But I really didn't mean to start this argument. I said in my answer that I reckon some will disagree. I just respectfully disagree back.  If you're going to modify the vector, you probably just want to pass it by reference. If you do use a pointer, however, you need to define a vector in main, and then pass the address of that vector:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  