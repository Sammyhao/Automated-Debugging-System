 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to make a hashtable using vectors, or would be it best to use a table with a struct ?  because this is how I have to do it...without using std::map or std::unordered_map  As the previous commenter said, try to use an associative container. The way you are trying to implement the hash is neither good C++ style in my opinion nor efficient I think. Chances are you won't beat an existing library in performance and I think you should maybe do a training or work a good C++ book. Maybe try another approach?  Note: Asking about homework is not a bad thing (much rather you ask than fail) but it's useful for us to know because it often changes how the question will be answered. There are things that must be done for school that would raise eyebrows, if not outright laughter and employment termination, in industry.  3 Answers 3  The question can be rephrased better as: there are two values that exist in both tables. It seems like you're trying to make T3HS hold indices of found elements.  yes this is what I am trying to do. T3HS to hold indices of found elements, if not found I put -1. T2.length() or T2[0] is the same thing  There are or hash table vectors, but you're only looking at of them.  Incidentally, your search pattern loop will access past the end of the array with when is .  Then when that is done, my first loop will iterate to the second row and look trough it until it finds matches elements with the one im looking for. etc. isnt this how it should be ?  Sorts the numbers into bins and stores them. Groovy. No problems here. But this:  Doesn't look in those bins for the numbers. It's looking all over the place. What you want to do is look in the right bin.  After this there are a ton of little improvements:  Start with the range-based for loop  Next, cut the search algorithm out and put it in its own function. This gets rid of chaff like . The function returns whether or not the value was found. A function should do one thing and one thing only. Sometimes that one thing is aggregating a number of other functions. For one thing, consider whty you are building the hash table inside a search function. Makes more sense to have a function to make a hash table and another to search it. Both functions do one and only one thing. As an added bonus, splitting them up means you can re-use the hash table for multiple searches.  and call it  Then you range a little further out and fill all of the memory leaks like  and  with . Never unless you absolutely have to because everything you you have to , and figuring out when and where to delete things can be a pain in the butt. Let the compiler do it for you.  Next up, you have a grouping of functions and data that describe the hash table. Might as well bundle all of that up into a class.  And finally think on how you are using . You want to make it easy and obvious. You don't want a page-long comment explaining that contains the length of the list and must always be no greater than one less than the length of the list. You just know someone is going to read it wrong. You sucked 1201ProgramAlarm into making that mistake, and they're no dummy. You are much better off with another variable that contains the length or, once again, use a because it knows how long it is.  The easier you make something to use, the less likely it will be misused. Make everything as obvious as possible.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  