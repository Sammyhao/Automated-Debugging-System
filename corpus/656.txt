 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have one problem with my solution for finding longest path in graph. My Programm works very slow when vertices are close to each other. Here is my code please help me.  19922 gold badges44 silver badges1616 bronze badges  1  I am curious about what you are trying to do? Can you elaborate a bit. Is this for a game?  1 Answer 1  As brz mentioned, this is an NP-complete problem; you won't be able to find a solution that is both efficient and guaranteed optimal. (Or, if you do, every programmer in the world will buy you a beer.)  That's not to say you can't do anything about it. Concentrate on the general shape of your particular use case, and any peculiarities, and decide how much inaccuracy you're willing to deal with.  The first thing you can do is look for a bottleneck -- a pair of adjacent traversable cells such that there is no path between them other than the direct one, and the start and goal nodes are on opposite sides of the pair. For the grid case, you can look at the cells which have exactly two neighbors, and then check for bottlenecks against those two neighbors. If you find a bottleneck, congratulations -- you've cut your problem into two subproblems, each of which will be much faster to solve.  You can also try randomized approaches, such as simulated annealing. Start with the shortest path, then perform some simple localized perturbation on it to make it longer, such as changing a straight line into a C-shape if the two nodes to one side of a part of the path are both unused by the path. Keep doing that until you can't make it any longer, then pick two nodes from your path at random, replace the path between them with the shortest path, re-elongate it, and consider taking that as the new path.  Ultimately, you need to remember that this is not a problem you can solve in its most theoretical, general form. You can concentrate on special cases, and you can relax your requirement of exact optimality. Theoretical CS has abandoned you; you need to turn to practical engineering instead.  +1: "Theoretical CS has abandoned you; you need to turn to practical engineering instead." I'll have to remember that one, a rather interesting way of putting things.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  