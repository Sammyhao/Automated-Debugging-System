 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  For Simplification, the problem could be reduced to:  Given an m * n matrix, with a bunch of special points, find an optimal path from point A to point B in this matrix. The optimal path is a path which passes fewest special points. If there are multiple paths with fewest special points, choose the shortest one. If there are still multiple paths, select one randomly among them.  This problem could definitely be solved by BFS. To hold a queue, record information of each point. If a better path is found, update information and put this point into the queue. Output information at point B at last.  The tricky part is a point may be revisited multiple times and I cannot estimate the time complexity in this case. Can anyone help me with it?  1 Answer 1  The ultimate goal is to not hit any special points or as less as possible. You can use Dijkstra for that with following settings: Ordinary edge costs 1. The edge between special point and all other costs more than (therefore even if you go through the whole maze without special node, its better than go one step, but through special node).  Then you run Dijsktra and you have it. As you have graph with maximum amount of edges per node (its matrix, so 4 directions at maximum) the number of edges is approximatelly 4*m*n which is .  So your and and Dijkstra is . Just put it there and you get  19.9k99 gold badges3737 silver badges7575 bronze badges  3  Yes, your answer is so good, thanks! So if I don't use Dijkstra, just use a normal queue instead of heap, how could it be for the complexity? Should it be O(E^2) in the worst case?  @HanLi - Dijkstra use min-priority queue, not a heap. Its basically BFS alghorithm that continues only in directions that makes sense. Are you sure that your "simple" algorithm will actuallly work? If you use some brute force with backtracking you can end in (3 because you have usually 3 paths to go, so each step the amount of possibilites is 3x bigger than last time). Thats something that is almost unusable  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  