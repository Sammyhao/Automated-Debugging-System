 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Suppose I have a doubly-linked list defined by the class  If I wanted to make a destructor for this list do I have to explicitly delete the value?  Would the above work to ensure that no memory is leaked? Or do I have to do:  I'm confused as to how I can make sure that no memory is leaked in this case. How do I deal with the pointers in the nodes specifically? If I delete move does it automatically take care of these?  3,5221414 gold badges3737 silver badges5555 bronze badges  1  Having a node that points to the value is prone to errors and undefined behaviors... What if you add a node pointing to a local variable in a function? After the function returns that pointer is no longer valid.  3 Answers 3  You need to pair each with exactly one . That is, you probably don't want to (this node already was deleted) but you want to . Well, I'd embed the into the object and not point to it:  If the absolutely needs to be a pointer, I'd use a (or, if you need to use C++ 2003, a ).  144k1313 gold badges206206 silver badges368368 bronze badges  1  You should delete value only if you do new, if the user of the class does the allocation, the user should do the deletion  For each successful expression, call exactly once on that object.  For each successful expression, call exactly once on that object.  That means that neither of your cleanup functions are OK:  The first function forgets to the , which means a memory leak.  The second function, by deleting both and at each node in the list, risks deleting most nodes twice, which is Undefined Behavior.  To avoid the memory leak for the first function, simply store the integer directly instead of allocating it dynamically.  Whether you have to delete the memory pointer by the member - only you can know. It is a question of memory ownership, a question of your design. If the list owns the data memory pointed by the members, then you have to delete it in the list destructor (i.e. when the list dies, the data it owned dies with it).  If the list does not own the memory, then you are not supposed to delete it. Again, only you can answer the question of whether your list is supposed to own the memory. It is a matter of your intent.  Now, as for the memory occupied by objects, it is obviously owned by the list, so it has to be carefully deallocated in the destructor. The first version of your destcructor is close to being correct (the second makes no sense at all), except that it written in a slightly obfuscated fashion. This should be sufficient  (Again, if you have to delete , then should be added to your cycle before .)  P.S. Once you get this, you might want to look into various smart pointer classes, which allow you to explicitly express memory ownership relationsips, thus making them known to the compiler. When used properly, they will make memory management almost automatic.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  