 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  So my code is below. I'm not getting any errors and it places everything in the node just fine. But based on my debug statements Everytime anything is inserted it's finding the root. I'm not sure if that is right. But according to output file for the assignment, my answers are different when it comes to the height of the tree, the traversals, and I just flat am still having troubles with my leaf count function. Another story though.  Based on the debug statements it looks like everything is going right where they should. But I figure I might need fresh eyes. I don't see how my traversals could change at all since it is really only a matter of where I'm proccessing the node that should effect the Inorder, preorder, and postorder.  My height function is as follows just in case my insert is actually fine.  3 Answers 3  You need to change the wording of your debug statements  Really it should read (not Root node)  It is only the root when it is first called after that any call with node->left or node->right makes it an intermediate node.  242k8080 gold badges318318 silver badges538538 bronze badges  2  so you think my insert is correct? I mean based on my debug prints... and physically writing this down... everything seems to match.  Yeah your height gave me the same value as mine. It looks cleaner and is more effecient though so I appreciate it.  You need to start off with your root init'd to null. Also, you are passing *&node in; it should be *node. Else you're passing a pointer to the address(or reference, I'm not sure which in this context, but both aren't going to be right). You should be passing a pointer to Node in, not a reference.  38.3k2828 gold badges111111 silver badges206206 bronze badges  1  No he needs the reference to make the assignment work correctly. Though it is ugly I will give you that.  @Vlion: It should be a pointer to the left/right/root pointers (i.e. a double pointer), so the posted code is correct, although somewhat unclear.  @Doug: Consider changing your insert function thus:  It makes clear your intention that you'll be changing the pointer passed as the first parameter (or rather, the pointer whose address will be passed as the first parameter.) It will help avoid confusion such as the one that just happened.  The calls to this insert(), such as:  will also reflect your intention of changing the pointer's value. This is a matter of style, though, so I can't argue if you don't want to change.  As for checking whether the tree is "correct," why not draw it out and see for yourself? Something along the lines of:  42.5k1010 gold badges7070 silver badges7676 bronze badges  3  Thanks for the help. So I'll try changeing it around like you said, but technically our code is doing the same things though right?  I also forgot to add that while I didn't go as far as you did in making a function to drawing out the tree, Based on the debug prints, and my own drawing of the pre defined hard coded numbers that are inserted.. It appears to be doing it correctly. I sent it off to my TA in hopes he can clarify.  Yes, they both are doing the same thing; the difference is cosmetic. The code looks correct, the problem is (as Martin York has pointed out) printing "root found" while the node is actually just the root of the new subtree. (i.e. a leaf)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  