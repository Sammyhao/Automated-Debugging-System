 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm trying to accelerate a specific linked-list operation by hashing some of the node pointers. This is the code I'm using:  In Visual Studio 2012, I get an "error C2338: The C++ Standard doesn't provide a hash for this type", since the compiler doesn't know how to hash iterators. Therefore, I need to implement my own hash function for list iterators like so:  I'm having trouble figuring out what members of the iterator guarantee uniqueness (and, therefore, the members that I want to hash). Another concern is that those members may be private.  One solution that comes to mind is re-implementing and list::iterator, but that seems like a hack and introduces more code to maintain.  74711 gold badge66 silver badges1212 bronze badges  3  4  That's no iterator! Your future, shrouded is. Iterators, confused are. hashing [iterators] leads to anger, anger leads to hate, hate leads to gdb.  @kfsone: I don't particularly like iterators either (after implementing one). Sometimes I miss the days of writing good old C. I don't see any alternatives to iterators in C++, though.  option a) I close my stackoverflow account, option b) I reply "the force be with (*youIt)".  4,33133 gold badges1818 silver badges1717 bronze badges  3  @KonradRudolph The iterator may be passed by value, but the address is of the thing it's pointing to.  You can use pointers to the element in place of iterators. Let's say you had a list of structs . You can use  and the C++ standard library already implements for any pointer.  So if you ever need to insert or search then use which will get the pointer of type .  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  