 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  the compiler said something about bad access. I tried to set breakpoint to debug it. If the linked list is [3, 2, 1], it first delete the 3, then 2 and 1, and then jump back to 2, then encountered exception. Can someone tell me what is the problem?  With the exception of the use of , wouldn't this be more of a C problem, rather than C++? (I don't recall if is valid in the newer C standard). Theoretically, if you are using C++, why would you not use or one of the other STL containers?  5 Answers 5  The destructor for the Node struct already calls delete on "next". Therefore, it goes to "next" and calls its destructor, and so on. All nodes following in the linked list will then be deleted just by calling (where p is a Node*).  I recommend you get rid of the Node's destructor to prevent this chain destruction from occurring.  As a side note, while I don't know the rest of your code I don't see a reason as to why deleteList(Node* p) should return a Node* (as it will always be nullptr, no interesting results are returned).  If the linked list is: , when you call , the following things happen:  , , was deleted by Then the destructor was called, so would delete and recursively.  then after in function, was called again, so this time: , , since was already deleted in the previous step, it would corrupt when you call again.  So please remove the in .  Actually I don't see reason why should be used, because it would always return and delete all the nodes. So why not remove the function, and keep the in . You can delete the created object directly.  I would wager a guess that you are experiencing being called multiple times on an instance that has already been deleted. When you call , 's destructor is getting called, and it is deleting the next node in the list. You then recursively call , passing it the node that was just deleted by 's destructor, making the pointer you are holding invalid.  What you need to do is determine whether the owns the that follows it in the list (that is, is it responsible for cleaning it up), or will some outside code take care of that. You cannot do both.  Edit:  As an aside, what you really want is not to have a recursive delete function, but rather a loop within your function. Something like ...  In this case, the instance does not own its sibling (Node.next), and takes no responsibility for deallocating it; that is up to the function.  3,12044 gold badges2828 silver badges3838 bronze badges  3  but before I delete p, I pass the next to pNext. So deleteList can actually get the next node, isn't it?  what it is receiving is that next node, but p's destructor delete's it on you, so that pointer you store in pNext is no longer valid - it points at memory that has already been deleted.  I get the impression that you think the pointers are reference-counted (that is, it isn't actually deleted until the last reference is deleted). That would be the case in Java or C#, for example, but not C++. There are libraries that provide similar support, and there are STL classes that give you reference-counted shared pointers, but using standard, run-of-the-mill pointers do not work that way.  @RSahu: actually he got it from you and I, but for some reason, feihu was awarded the best answer, even though he answered what we both already said almost 10 minutes before he did.  @Will, I can understand why feihu's answer was chosen as the best answer. My answer was not too explanatory even though it was correct. While your answer has more explantion, feihu's answer is easier to follow the sequence of events that leads to the item containing 2 being deleted twice.  @RSahu: I guess the visual was what the OP was looking for. My point was that he came along after we answered and apparently didn't take much effort into answering the question himself. He even edited his response to include what I commented to the original question above (the use of std::list). I mean, really? Maybe I'm just being nit-picky; I get that way at this hour of the night/morning. :)  I think there may be two choices for you. first, as R Sahu said, remove the in destructor.  second, just delete the head node of the link in , but not delete nodes recursively.  One drawback to this approach is that is actually a misnomer; it should be called , as you are only deleting a single node, not the entire list.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  