 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have tried solving it using dynamic programming but i am getting error.I want to know why i am getting runtime error?  The idea i have used is that :  if n becomes equal to m i am not required to press any more buttons;  if n becomes greater than m then the only way i can get to m is by subtracting 1 everytime. Thus (n-m) moves.  and for n < m, i have recursively called min of both moves possible+1  The error i am getting is - Runtime error: exit code is -1073741571  @DeiDei Yes you provided 10 1 where n > m initially therefore runs fine as returns abs(n-m) at the very first call...give 4 6 as input it will exceed time limit.Probably going in some endless recursive loop.I am not able to figure why is it so .  . never changes but is decreased by one. Entering value 4 and 6 will keep going until rolls around to . Thus probably causing the stack overflow  I didn't consider the exit condition of . Still, if the user were to enter this code would be a problem.  Most likely, the stack overflow results from your recursion being too deep: Each recursive function call stores some data on the stack (registers, return address, etc.), which after a huge number of recursions is just to much. This is why, you should prefer to avoid recursion where possible.  A solution might be, to try to reformulate your solution using an iterative approach (i.e. a or loop.  Yes i understand that the function is going in some endless recursive calls thus occupying the stack. But the constraint are not that large and my function should certainly get into some if and should return from its call.Can you figure why it is not so?  Coming to the issue with the algorithm that causes the stack overflow:  At some point, you will call , which in  will call , which returns immediately due to n==0, and . This will call , which we ignore for now, and , which brings is a state you already have been in. This is the endless recursion.  You might want to consider to avoid pushing blue if except if . Maybe, some special handling for might also doe the trick instead.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  