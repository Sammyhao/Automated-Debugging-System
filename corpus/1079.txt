 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am working on a large Fortran code, where parts are written in FORTRAN77. There is a piece of code, which causes debugger to raise errors like:  but when compiled without debugging options runs and does not crash the program. Debugging options used:  The logic of the problematic piece of code is following: in file I declare  Variables and are initialized in procedure :  is declared in another procedure as:  and lets look at procedure :  In both and procedures there are different bounds for dimensions of arguments than the actual input array size (for it is 1 and 19, respectively). I printed out after calling in no-debugger compilation setup:  My questions are:  Is notation : DIMENSION TRIGS(1) something more than setting bound of an array?  Why is the program even working in no-debugger mode?  Is setting: DIMENSION TRIGS(*) a good fix if I want variable trigs be a result of the procedure?  Some small remarks: 1) signals indeed array but also its upper limit. 2) no boundary checking performed 3) why not use the real dimension (6*n)  @albert maybe then 4th question is in order: 4) where values in trigs with code run in a normal mode are coming from? Are they some random junk, or there is some connection of with what happens in procedure ? @3)Unfortunately I cannot use dimension 6*n because is also used for other arguments with different dimension.  @Maria 1) I think it is a very old trick to avoid explicitly specifying the size of a dummy array, and "1" has little meaning (and the upper bound of an actual array argument is usually not 1). 3) Yes, I think setting is a good fix (according to your comment above).  2 Answers 2  In f77 statements like the DIMENSION TRIGS(1) or similar or ..(*) with any number, if pertaining an argument of the procedure just tells the compiler the rank of the array, the length in memory must be assigned to the array which is given in the call of the subroutine, normally f77 does not check this! My recommendation either use (*) or better reformat (if necessary) the f77 sources to f90 (the bits shown would compile without change...). and use dimension computed using n in the declaration within the subroutines/procedures. Fortan passes arguments by address (i.e. trigs(i) in the subroutine just will refer on the memory location, which corresponds to the address of trigs(1) + i*size(real*8).  A more consisted way to write the subroutine code could be:  real(kind=8) is not necessarily the same as real*8 DON'T use it! There are multiple warnings around about this in stackoverflow.  plenty of nits to pick here. dimension trigs(1) is not Fortran 77. It is a violation of standard carried over from a widely used work-around for missing feature in Fortran 66. You have no guarantee what various compilers will do with it when bounds check is turned on. real*8 is a non-standard carry over from IBM proprietary extended f66.  To answer your question, I would change TRIGS(1) to TRIGS(*), only to more clearly identify array TRIGS as not having it's dimension provided. TRIGS(1) is a carry over from pre F77 for how to identify this.  Using TRIGS(:) is incorrect, as defining array TRIGS in this way requires any routine calling FFTRIG to have an INTERFACE definition. This change would lead to other errors.  Your question is mixing the debugger's need for the array size vs the syntax excluding the size being provided. To overcome this you could pass the array TRIGS's declared dimension, as an extra declared argument, for the debugger to check. When using "debugger" mode, some compilers do provide hidden properties including the declared size of all arrays.  It does nod need an INTERFACE block, it can also be put into a module, whech can be as simple as a single INCLUDE statement for all subroutines in the file.  The point is that using "CALL FFTRIG (TRIGS, N, 3)" by itself would no longer work, but will lead to a program crash. Using (:) would require a change to all other uses of FFTRIG. It is not a minor correction to a large code.  I don't think so, if you keep N in the argument list. But the explicit interface must be available, that is correct.  What I was attempting to say is that if the only change is "TRIGS(1)" to "TRIGS(:)" in the routine FFTRIG; this can be a risky change to the code. It is not a change that is easy to recognise when checking code (like changing the argument list) but it does require a change to be made to all calls to FFTRIG, throughout the code. Not all compilers will recognise and report this requirement. N is not related to how (:) is implemented.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  