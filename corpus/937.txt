 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I came across this question during an interview - Convert a number source to target in the minimum number of operations.  Multiplied by 2.  Addition by 1.  subtraction by 1.  I tried going the naive recursive route(O(3^n)) ie. subtract 1, add 1 and multiply by 2 at each level to try and find a solution that I could extend to Dynamic Programming but couldnt because of an infinite loop.  Any ideas on how I can tweak my solution? Or possibly a better way to solve it?  It does not, I have an example in the code where I think it fails by going into an infinite loop.  4 Answers 4  If you think about your solution like a graph traversal, where each node is an intermediate value you can produce, your recursive solution is like a depth first search (DFS). You'll have to fully expand until you've tried all solutions from that "branch" of the search space before you can proceed anywhere else. If you have an infinite loop, this means it will never terminate even if a shorter path exists, and even if you don't have an infinite loop, you still have to search the rest of the solution space to make sure its optimal.  Instead, consider an approach similar to breadth first search (BFS). You expand outward uniformly, and will never search a path longer than the optimal solution. Just use FIFO queue to schedule which node to access next. This is the approach I've taken with my solver.  4,55622 gold badges1212 silver badges3434 bronze badges  1  Although for completeness you probably want path.length/ size (or however its invoked in Python)  One way in which you can speed up(and possibly fix) this code, while maintaining the recursive implementation, is to use .  The issue here is that you are recalculating the same value many times. Instead you can use a to store the results that you already calculated, and reuse them when you need it again.  This problem can be solved constructively. First, the easy cases. If s=t, the answer is 0. If s > t, the answer is s-t because subtraction by 1 is the only operation that lowers s, and the other two can only increase the number of subtractions required.  Now let's assume s < t. Since s>0 is given, doubling will always be the fastest way to increase (if s is 1, it's tied with incrementing). So if the challenge was to make s >= t, the answer would always be the number of doublings required to do that. This procedure may overshoot t, but the first doubling greater than t and the last doubling not greater than t must be within a factor of 2 of t.  Let's look at the effect of when we do an addition or subtraction. First, look only at addition:  vs:  Putting an addition before n doublings makes the final result 2^n bigger. So consider if s is 3 and t is 8. The last double not bigger than 8 is 6. This is 2 off, so if we put an addition 1 double before the last double, we get what we want: (3+1) * 2. Alternatively we could try overshooting to the first double greater than 8, which is 12. This is 4 off, so we need to put a subtraction two doublings before the last : (3-1)*2*2 = 8  In general if we are x below the target, we need to put a at n doublings before the last if the binary representation of x has a 1 at the nth place.  Similarly, if we are x above the target, we do likewise with 's.  This procedure won't help for the 's in x's binary representation that are at a position more than the number of doublings there are. For example, if s = 100, t=207, there is only 1 doubling to do, but x is 7, which is 111. We can knock out the middle one by doing an addition first, the rest we have to do one by one .  Here is an implementation that has a debug flag that also outputs the list of operations when the flag is defined. The run time is O(log(t)):  Short BFS algorithm. It finds the shortest path in graph where every vertex x is connected to x + 1, x - 1 and x * 2; O(n)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  