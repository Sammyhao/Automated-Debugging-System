 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  The following code gives me a segmentation fault when run on a 2Gb machine, but works on a 4GB machine.  The size of the array is just 4Mb. Is there a limit on the size of an array that can be used in c++?  7 Answers 7  You're probably just getting a stack overflow here. The array is too big to fit in your program's stack region; the stack growth limit is usually 8 MiB or 1 MiB for user-space code on most mainstream desktop / server OSes. (Normal C++ implementations use the asm stack for automatic storage, i.e. non- local variables arrays. This makes deallocating them happen for free when functions return or an exception propagates through them.)  If you dynamically allocate the array you should be fine, assuming your machine has enough memory.  But remember that this will require you to the array manually to avoid memory leaks, even if your function exits via an exception. Manual new/delete is strongly discouraged in modern C++, prefer RAII.  A better solution would be to use (cppreference). You can reserve space for 1000000 elements, if you know how large it will grow. Or even it to default-construct them (i.e. zero-initialize the memory, unlike when you declare a plain C-style array with no initializer), like  When the object goes out of scope, its destructor will deallocate the storage for you, even if that happens via an exception in a child function that's caught by a parent function.  50k1212 gold badges122122 silver badges138138 bronze badges  6  4  Thanks for the answer, but could you explain me why arrays are allocated on the stack and why not in the main program memory.  The given code allocates on the stack because it's specified as an array with a constant number of elements at compile time. Values are only put on the heap with malloc, new, etc.  All automatic varables are allocated on the stack. If you look at the disasseble you will see the size of your local variables subtracted from the stack pointer. When you call malloc or calloc or any of the memory fuctions the fuctions go and find blocks of memory large enough to sataisfy your reqest.  @Charles why we could allocate more memory from heap, not from stack? from my understanding, both stack and heap moves in opposite direction in allocated address space in the memory.  @saurabhagarwal The heap doesn't move. It's not even a contiguous memory region. The allocator simply returns a free memory block that fits your size requirement What and where are the stack and heap?  In C or C++ local objects are usually allocated on the stack. You are allocating a large array on the stack, more than the stack can handle, so you are getting a stackoverflow.  Don't allocate it local on stack, use some other place instead. This can be achieved by either making the object global or allocating it on the global heap. Global variables are fine, if you don't use the from any other compilation unit. To make sure this doesn't happen by accident, add a static storage specifier, otherwise just use the heap.  This will allocate in the BSS segment, which is a part of the heap. Since it's in static storage, it's zero initialized if you don't specify otherwise, unlike local variables (automatic storage) including arrays.  A non-zero initializer will make a compiler allocate in the DATA segment, which is a part of the heap too. (And all the data for the array initializer will take space in the executable, including all the implicit trailing zeros, instead of just a size to zero-init in the BSS)  This will allocate at some unspecified location in the heap:  28.6k66 gold badges6464 silver badges101101 bronze badges  3  1  If you use the third pattern, allocating on the heap, don't forget to delete[] the pointer at some stage or you'll leak memory. Or look into smart pointers.  @meowsqueak Of course it is good practice to everywhere you allocate with . But if you are sure you allocate memory only once (like in main) it is strictly not needed - the memory is guaranteed to be freed at the exit of main even without explicit .  'at'drhirsch (how do you do an at-character anyway?) - yes, fair comment. As the OP appears new to the language I just wanted to make sure that they, and anyone else seeing your good answer, were aware of the implications of the third option if used generally.  Also, if you are running in most UNIX & Linux systems you can temporarily increase the stack size by the following command:  But be careful, memory is a limited resource and with great power come great responsibilities :)  2,12133 gold badges3232 silver badges5454 bronze badges  5  1  This is the solution but I advise all to be extremely cautious when removing this default limits on the program's stack size. You will experience not only severe performance drop but your system might crash. For example I tried to sort an array with 16 000 000 integer elements with quicksort on a machine with 4GB RAM and my system was almost killed. LOL  @rbaleksandar I think you ~16MB program almost kill your machine because you were working with several copies of the array (may be one per function call?) try a more memory aware implementation ;)  I'm pretty sure the array handling is okay since I'm passing by reference and not by value. The same thing happens with bubblesort. Hell, even if my implementation of quicksort sucks bubblesort is something that you cannot possibly implement incorrectly. LOL  You array is being allocated on the stack in this case attempt to allocate an array of the same size using alloc.  Because you store the array in the stack. You should store it in the heap. See this link to understand the concept of the heap and the stack.  Your plain array is allocated in stack, and stack is limited to few magabytes, hence your program gets stack overflow and crashes.  Probably best is to use heap-allocated std::vector-based array which can grow almost to size of whole memory, instead of your plain array.  Then you can access array's elements as usual and/or get its size (number of elements).  If you want multi-dimensional array with fixed dimensions then use mix of both std::vector and std::array, as following:  In example above you get almost same behavior as if you allocated plain array (except that vector allocates on heap instead of stack), you can access elements as same as in plain array. This example above also allocates array on heap meaning that you can have array sizes up to whole memory size and not limited by stack size.  To get pointer to the first element in vector you use or just .  there can be one more way that worked for me! you can reduce the size of array by changing its data type:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  