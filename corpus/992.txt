 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I usually program in java and recently watching some c codes. I came up across this program and I don't know how this pointer thing is working. I know pointer stores the address and all but couldn't make it through the program. Please tell how is the output coming as 8 ?  @philippe lhardy: When you write a recursive function that needs large amounts of intermediate temporary data that does not need to be preserved as a local context and/or over the nested recursive call, then this is actually how you should do it. Create a "global" context in the caller and pass it to all recursive levels through a pointer parameter. That way all recursive levels will use the same "global" data, instead of instantiating that data locally again and again on each level of recursion. This technique will allow you to reduce stack usage and avoid stack overflow.  However, in this case it is used for a different purpose: to return a second value from the lower level to upper level. So it is not really a "context" per se. There's was no real need to use the same variable at all levels of recursion.  @AndreyT i agree with your both comments. i nethertheless stick to the fact that two lines of comments in the code would perhaps have saved a SO post :-).  4 Answers 4  What you have here is a recursive function that calculates the i-th element of a Fibonacci sequence (indexing from ). Each recursive iteration returns two values: the i-th Fibonacci number and the (i-1)-th (previous) Fibonacci number. Since a function in C can only return one value (well, unless you use a struct as return type), the other value - the previous Fibonacci number - is returned to the caller through a pointer parameter .  So, when you call , the function will return , which is the 5-th Fibonacci number, and it will also place into , which is the previous (4-th) Fibonacci number.  Note that the initial value of does not matter. That does not play any role in this program. Apparently it is there as a red herring.  If you know what a Fibonacci sequence is, you know that the next element of the sequence is the sum of the two previous elements. This is why the function is written to "return" two elements of the sequence to the caller. You might not care about that previous value in the top-level caller (i.e in ), but the nested recursive calls do need it to calculate the next number. The rest is pretty straightforward.  fun calls fun with a 4 and f_p, which is the x address  fun calls fun with a 3 and f_p, which is the x address  fun calls fun with a 2 and f_p, which is the x address  fun calls fun with a 1 and f_p, which is the x address  fun got called with a 1 so the if condition is true, puts a 1 in the variable pointed by f_p(x) and returns 1  this returned value is assigned to the t of the fun(2,f_p), f is which is 1+1 -> f=2; the variable pointed by f_p is set to t so x=1, returns f so it returns 2  this returned value is assigned to the t of the fun(3,f_p), f is which is 2+1 -> f=3; the variable pointed by f_p is set to t so x=2, returns f so it returns 3  this returned value is assigned to the t of the fun(4,f_p), f is which is 3+2 -> f=5; the variable pointed by f_p is set to t so x=3, returns f so it returns 5  this returned value is assigned to the t of the fun(5,f_p)(the first call to fun), f is which is 5+3 -> f=8; the variable pointed by f_p is set to t so x=5, returns f so it returns 8, which is what the printf prints  Another answer revealed this to calculate the fibonacci numbers using a useful technique for returning an extra value. I've rewritten the code in what I think is a much more understandable and maintainable manner. Hope this prevents people thinking you need to write terrible code to do something like this  As these things go, it's technically straightforward, but...stupid, in the sense that nobody should do things like this. It's a bad use of recursion and badly-written recursion, given the side effects.  The original call of isn't going to trip the condition. So, it'll recurse four times (5-1, 4-1, 3-1, 2-1). That's your base condition, which has the effect of setting the pointed-to location (the original ) to and returning .  Then we unroll the four calls, each time adding the returned value to the thing at the pointer and changing the thing at the pointer to be that sum.  In simple English, you're doubling one three times.  Edit: As pointed out, I misread the code as assigning to rather than . That makes it a Fibonacci counter.  @AndreyT, a mis-read of as . That would return 1, then double it three times by adding the value to itself then storing it at the pointer.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  