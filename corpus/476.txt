 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I've looked around, but most of the answers here are to questions where the heap corruption is obvious from the code, or where the asker has already identified the source.  I have a C program (simulating a car race) that is dynamically allocating memory for a linked list. It then copies values from one or more nodes from the list into a dynamically allocated 2D array, based on a value in the node. Each node is freed after it is copied, and the list head is updated. This repeats until there are no more nodes in the list (the end of the race).  A pointer to the array is returned to main and stored in a 3D array.  The whole process then repeats (new linked list, new array).  At the end of the second iteration (second race), I am getting a heap corruption error, and I can't figure out what is causing it.  This told me the address was 0x596EBC5C, which doesn't appear to contain anything I allocated, so I'm not sure if that's meaningful somehow.  The best I can tell, I'm getting the error in this block of code, but I'm not even sure of that, and I don't know how that would help me find the source of the problem.  if you were using Linux, I'd say that Valgrind would probably be able to see when you are doing the bad access. Is it possible for you to compile on a Linux environment?  "At the end of the second iteration" If that's predictable and repeatable with a small number of entries, then you should be able to find it with a debugger.  In the second race, won't that start off with the wrong value (not zero but rather the number of cars in the last race)? Because it is static. In any case, you probably should bounds check this:  No worries. Keep your answer. It's to be encouraged when anyone puts in the effort to solve their own problems. Good work!  1 Answer 1  I finally figured it out. Unfortunately, I still wasn't able to find the problem throught the debugger, but rather just looking at the code.  Anyways, the issue was with this:  I declared it static because I needed it to maintain state within a single race.  However, after the first race, I was not resetting the counter, so this was actually starting to store values in unallocated memory:  The fix was as simple as adding this to the end of the function:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  