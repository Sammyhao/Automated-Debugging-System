 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am using luabind as my lua to C++ wrapper. Luabind offers a method to use my own callback function to handle exceptions thrown by lua, set_pcall_callback(). So I paraphrased an example from the documentation, the changes being the logger->log() function and putting the function in a class called 'Engine', so instead of it being a regular global function it is now a member function, which is where my problem seems to be.  Here are the relevant code snips:  Here is what the compiler says during compilation:  So it seems that the error is that the function expects a regular function pointer, not a class member function pointer. Is there a way to cast or use an intermediate function pointer to pass to the set_pcall_callback() function?  4 Answers 4  No. A member function is not a free function. The type is entirely different, and a pointer to a member function (PTMF) is a completely different, incompatible object from a function pointer. (A PTMF is usually much bigger, for example.) Most importantly a pointer-to-member must always be used together with an instance pointer to the object whose member you want to call, so you cannot even use a PTMF the same way you use a function pointer.  The easiest solution for interacting with C code is to write a global wrapper function that dispatches your call, or to make your member function static (in which case it becomes essentially a free function):  The conceptual problem here is that you have an engine class, although you will practically only have one single instance of it. For a genuine class with many objects, a PTMF wouldn't make sense because you'd have to specify which object to use for the call, whereas your engine class perhaps is essentially a singleton class which could be entirely static (i.e. a glorified namespace).  440k8787 gold badges834834 silver badges10451045 bronze badges  7  1  That's definitely not the easiest solution. The easiest is to make the method static.  @Let_Me_Be: It depends on your class, doesn't it -- if your class is really just an wrapper for what should be global functions anyway, then is the way to go. But that may not always be an option.  The engine class wraps the graphics and event pointers so I don't have to pass a global context struct everywhere.  Not suitable for your LUA problem, but maybe on other libraries: If a function requests a a function pointer like func(void* param, ...) and you can ensure that the lifetime of your object is greater than the stored function pointer, then you could technically also use a method pointer (looks the same on the stack), but C++ prevents direct casting of method pointers to function pointers.  But with a little trick, you can also cast method pointers to function pointers:  Using that, you can use method pointers for example with libmicrohttpd:  But be aware of it. You must take care of the lifetime of that object. Also the calling conventions must match.  An important note to my answer: The user-defined parameter (param called above) must be the first parameter of the callback function to get this to work. On member functions the this pointer is always the first parameter on the stack. So if we cast a member function to a non-member function then we must ensure to pass the this pointer as the first argument.  Explicit conversion from method pointer to function pointer is illegal in C++ - period.  But there is a hack. We have to first convert the (const) method pointer to (const) void* and then to (const) function pointer. And it works. And why wouldn't it? Everything and I mean everything can be pointed to by a because everything has an address.  WARNING: The below is DAAEINGEROUS hack territory. If you're developing software for a fighter jet or whatnot, you should know better than to use this. I'm not responsible! I'm just providing this here for educational purposes.  The trick is we must convert between method pointer and function pointer through an intermediate conversion to, potentially cv (const-volatile) qualified, .  This way we are able to call a member function (pointer) through a function pointer, with the first argument being a pointer to the target class object, which is equivalent to the member function call's .  Given a:  then  or to make it more explicit use two of the following in sequence, for non-const and const member functions:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  