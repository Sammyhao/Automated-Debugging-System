 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a program which currently throws MSMQ transaction has not been started. MSQM will throw messages into the deadletter queue if this transaction is used to send without any warning or exception! exception. I am not sure what I have done wrong, so is there anyway to debug / log the current status of message queue transaction?  Ok. I can get the current transaction context with TransactionContext.Current. The MessageQueueTransactionStatus is Committed. So I don't know why it is not cleaned up?  and what does DoSomething() do if you say it may cause problem, have you tried to avoid it?  Is the exception thrown on the line? Could you possibly code a repro and send it to me?  I figure out. It is the DTC... An example will be you write to a Database which is different from the subscription storage, then do a bus publish which will automatically prompt the transaction. And the status of the TransactionContext in Rebus will become Committed and disposed. Then if you start a new scope and publish message, it will fail.  1 Answer 1  I've "successfully" reproduced the issue on my machine, but I must admit that I am in the dark with regards to how to fix it.  It seems like MSMQ somehow enlists in the ambient transaction even though I take care to create a manually, which I use for all send/receive operations.  My belief was that you had you specify for MSMQ to auto-enlist, which I am absolutely sure that I don't.  I'll poke around some more and I might even see if I can make MSMQ stop behaving like that, but I cannot promise that I can fix your issue.  Thanks for reporting it though, and thanks for the thorough reproduction.  17.7k22 gold badges3737 silver badges6363 bronze badges  2  Thanks for taking time to investigate this. I currently work around this by requesting a new transaction scope every time for publishing messages. I am just curious how this behaves in RabbitMQ?  I'd be very surprised if RabbitMQ had any kind of problem with - all of Rebus' interaction with the ambient transaction is coded by me, and I explicitly avoid auto-enlistment in order to avoid DTC escalation of the queue transaction. All of Rebus' queue guarantees are based on the fact the the queue transaction always surrounds whatever kind of work your code is doing, which is how the at least once-guarantee is achieved  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  