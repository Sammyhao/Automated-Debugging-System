 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm trying to implement a simple DFS on a directed graph using homemade data structures (HashMap and LinkedList) to learn C++, but for some reason the DFS method is infinitely recurring.  I think it's infinitely recurring because for some reason the nodes stored in the hashmap (the graph) are not actually being marked visited during the DFS. I thought I understood pointers and references but apparently I do not. I would appreciate it if someone could help me see what I'm doing wrong.  Here's the infinitely recurring DFS method:  Here's the HashMap class find() method  Here's the Graph class  Here's the Main method where I construct and populate the graph, and then call the DFS method.  This looks super weird to me, you would be better off having and have HashMap add the pointer qualifier where it makes sense.  also: This looks like pure evil, and a guaranteed memory leak. Any reason not to just call ?  And more related to your actual question: I don't know how that template is implemented, but if it's anything like standard containers, this will create copies of graph inside of each edge reference instead of refering to nodes, resulting in a massive DAG that might look like it's infinitely large if you suspend execution after a while .This is a case wherre would make a lot more sense.  @Frank Thank you, I changed to and that fixed it. But to be honest I don't understand why that fixed it.  @Frank I didn't want to just call because I thought I need to call the destructor to delete all of the Nodes in the adjacency list.  1 Answer 1  If anything your use of pointers looks almost random and arbitrary. You have pointers where they don't make sense: , and lack of pointers where there should be: .  You also use dynamic allocation in places that make no sense, like the afformentioned member of , and your cleanup is either non-existent ( has no destructor, when it should have one), or completely broken ( will lead to a guaranteed memory leak).  Furthermore, nothing ever cleans up your flag, so only one call to DFS will ever work.  Bluntly put, there are a LOT of problem with your code, both design-wise, and implementation-wise.  Your specific DFS issue probably comes from using instead of for the adjency list, because that likely causes the graph to become a massive DAG with subgraphs copied into the adjency list, but it's hard to tell without knowing how is implemented.  Edit I feel kinda bad for just bluntly saying "this is bad accross the board", here's how I'd implement your code correctly (using the stl instead of your custom containers):  Notice how all the memory management is handled through RAII, not a or in sight.  17.5k11 gold badge2222 silver badges4545 bronze badges  2  You are absolutely correct, thanks a lot for your insight. I wasn't thinking at all about why and where to use pointers, I just used them for no particular reason. I'll now try to be more aware of when and where I use pointers and dynamic memory allocation.  static allocation is a completely different thing. I think you mean allocating using value semantics, in which case yes in general, unless you are dealing with polymorphism or shared ownership. Remember that datastructures like or will allocate their content in the heap, so the containers themselves are actually really small. Adding a level of indirection only serves to make the code harder to read, slower to execute, and more error-prone.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  