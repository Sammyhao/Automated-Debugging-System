 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  My problem is as follows. Given I want to remove node 14 from this:  I expect it to find the largest value in the left nodetree, which in this case is 13. Then I expect that node with value 14 to now contain value 13, and that node with value 13 should be removed from the node tree.  However, I don't see how the code I copied above is doing that. First, we pass value 14 to the remove function. We pass the root node (8) and the value 14 to the remove_from_parent function. Since the value is greater than the parent's value, we call remove_from_parent recursively passing in the right child (10) and the value 14. Since the value is greater than the parent's value again, we call remove_from_parent again passing in the right child (14) and the value 14. Now we have an equal match, so we call parent.delete which returns the left node (13). So now the callstack had three recursive iterations, in the last sequence it returns node with 13, in previous sequence it returns node with 10 and the initial sequence it returned node with 8. So since the initial call did the following: @root = remove_from_parent(@root, value), I assume @root is now the node with value 13, after all, we are doing assignment "=" so the last call in the recursion overwrites the others. But something seems wrong here. Because node with 13 is not the root. Node with value 8 is the root. What am I missing?  3,77244 gold badges5353 silver badges8585 bronze badges  8  The code you copies is not doing that. All it is doing is defining classes. It is not clear what you're asking. do you want us to debug it for you?  @shx2 did you see the link I added? github.com/heineman/python-algorithms/blob/master/… It's from "Working with Algorithms in Python - O'Reilly Media". It contains a complete running example. I don't follow how the code implements the binary search tree algorithm, since the code seems to be returning the wrong parent.  ah checked that. in any case, removeFromParent always returns the parent node, so eventually it is meant to return the (new) root.  2 Answers 2  At the very last step (when you come to node 14) you get back the output of "delete" which substitutes the to-be-deleted node with one of its children and returns its parent. That means, the node 10 will be returned, and eventually its own parent as well (i.e. node 8).  UPDATE (after looking closer at a bit confusing naming): what "delete" does is substituting the node value (in your case, 14) with one of the children (in this case, 13). Then it returns back the modified node (13). Now remember that this call was made from the previous iteration, and the returned result will simply be the new value for one of the children of the parent node (which will be returned to the previous call). Eventually you'll get to the first call which started with the root.  The confusion in the naming (for me) comes from the word "parent" which actually means node itself.  UPDATE 2: removeFromParent does one of the following things:  if the node on which it was called, was None, it returns None.  if the node on which it was called, had the value to be removed, it returns the result of "delete" which will only return None if that node had no children, otherwise it will return the node with the values shifted around (node value substituted with one of the branches).  otherwise, it changes one of the node's children and returns the node.  When you get to node 10, this is exactly what will happen: it returns node 10, with the modified left branch (which will store the result returned by "delete", i.e. 13). the rest is simply bubbling up.  12k22 gold badges3030 silver badges3636 bronze badges  4  That's what I don't understand: the removeFromParent function is returning three nodes recursively: 13, 10 and then 8. Obviously 8 is the root node. So with this line right here: "self.root = self.removeFromParent(self.root, value)", notice how we are doing assignment, it seems like it is assigning all three values returned from the recursive function to self.root. But obviously assignment will only result in 1 value. I thought it would be the last value (node with 13). I don't understand how the recursion is working here with that assignment.  After I look at it again, it is correct it does not appear to be returning an accumulation of nodes to self.root. During the last recursive call, the result of it is assigned to parent.left: parent.left = self.removeFromParent(parent.left, value). And the returned recursive call before that is also assigned to parent.left. At the bottom of the stack (the first recursive call), it appears that is only what is returned to self.root.  The algorithm implemented by this code is a bit more complicated that it really needs to be. Only the last recursive call to can ever return anything other than the value it was passed in. And it will only do that if is the value to be returned, and it is a leaf node.  It might be simpler to understand if you used a iterative algorithm instead:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  