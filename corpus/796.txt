 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I know about Dijkstra's agorithm, Floyd-Warshall algorithm and Bellman-Ford algorithm for finding the cheepest paths between 2 vertices in graphs.  But when all the edges have the same cost, the cheapest path is the path with minimal number of edges? Am I right? There is no reason to implement Dijkstra or Floyd-Warshall, the best algorithm is Breadth-First search from source, until we reach the target? In the worst case, you will have to traverse all the vertices, so the complexity is O(V)? There is no better solution? Am I right?  So, are all those people stupid? Or am I stupid? Why do they recommend so complicated things like Dijkstra to beginners, who just want to move their enemies to the main character in a regular grid? It is like when someone asks how to find the minimum number in a list, and you recommend him to implement heap sort and then take the first element from sorted array.  2,03122 gold badges2525 silver badges4040 bronze badges  1  2  A* uses a heuristic to get to the target faster, so it's faster than BFS. Dijkstra's doesn't, so I'm not sure why you'd use Dijkstra's algorithm here.  3 Answers 3  BFS (Breadth-first search) is just a way of travelling a graph. It's goal is to visit all the vertices. That's all. Another way of travelling the graph can be for example DFS.  Dijkstra is an algorithm, which goal is to find the shortest path from given vertex v to all other vertices.  Dijkstra is not so complicated, even for beginners. It travels the graph, using BFS + doing something more. This something more is storing and updating the information about the shortest path to the currently visited vertex.  If you want to find shortest path between 2 vertices v and q, you can do that with a little modification of Dijkstra. Just stop when you reach the vertex q.  The last algorithm - A* is somewhat the most clever (and probably the most difficult). It uses a heuristic, a magic fairy, which advises you where to go. If you have a good heuristic function, this algorithm outperforms BFS and Dijkstra. A* can be seen as an extension of Dijktra's algorithm (heuristic function is an extension).  But when all the edges have the same cost, the cheapest path is the path with minimal number of edges? Am I right?  Right.  There is no reason to implement Dijkstra or Floyd-Warshall, the best algorithm is Breadth-First search? Am I right?  When it comes to such a simple case where all edges have the same weight - you can use whatever method you like, everything will work. However, A* with good heuristic should be faster then BFS and Dijkstra. In the simulation you mentioned, you can observe that.  So, are all those people stupid? Or am I stupid? Why do they recommend so complicated things like Dijkstra to beginners, who just want to move their enemies to the main character in a regular grid?  They have a different problem, which changes the solution. Read the problem description very carefully:  (...) The catch being any point (excluding A and B) can have an obstacle obstructing the path, and thus must be detoured.  Enemies can have obstacles on the way to the main character. So, for example A* is a good choice in such case.  19.1k44 gold badges6565 silver badges107107 bronze badges  4  "When it comes to such a simple case where all edges have the same weight - you can use whatever method you like, everything will work." - I don't think so. It would be stupid to use DFS. "Enemies can have an obstacles on the way to the main character. So, for example A* is a good choice in such case." - still don't see why is should be better than BFS.  Because A* with good heuristic is much faster. Put some obstacles and test it here.  I made several tests there and if I look at milliseconds, BFS is the fastest. But if you are talking about speed, you should not talk about any tests, but about complexity and math.  When it comes to speed or complexity (which are equal if we assume that operations have the same cost, the same speed of execution) - A* is better choice then breadth first search. In the tests probably you have chosen Best-first search not Breadth-first search. It's intuitive - A* have a heuristic which (when it's good) directs processing towards goal. Which in most cases reduces drastically number of operations. BFS doesn't have such feature, it just does a full search.  BFS is like a "brute-force" to find the shortest path in an unweighted graph. Dijkstra's is like a "brute-force" for weighted graphs. If you were to use Dijkstra's on an unweighted graph, it would be exactly equivalent to BFS.  So, Dijkstra's can be considered an extension of BFS. It is not really a "complicated" algorithm; it's only slightly more complex than BFS.  A* is an extension to Dijkstra's that uses a heuristic to speed up the pathfinding.  But when all the edges have the same cost, the cheapest path is the path with minimal number of edges?. Yes  If you really understood the post that you linked, you would have noticed that the problem they want to solve is different than yours.  1,10555 gold badges1919 silver badges3434 bronze badges  2  how is it different? because of obstacles? So you just can remove edges and vertices in regular grid.  There are two different problems here. In one problem, there are entire links/roads that can be chosen or avoided because of say obstacles. In the second problem, the links containing obstacles can still be chosen, but the obstacles must be detoured.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  