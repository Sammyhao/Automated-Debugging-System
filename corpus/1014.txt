 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I need to implement a priority queue where the priority of an item in the queue can change and the queue adjusts itself so that items are always removed in the correct order. I have some ideas of how I could implement this but I'm sure this is quite a common data structure so I'm hoping I can use an implementation by someone smarter than me as a base.  Can anyone tell me the name of this type of priority queue so I know what to search for or, even better, point me to an implementation?  5 Answers 5  Priority queues such as this are typically implemented using a binary heap data structure as someone else suggested, which usually is represented using an array but could also use a binary tree. It actually is not hard to increase or decrease the priority of an element in the heap. If you know you are changing the priority of many elements before the next element is popped from the queue you can temporarily turn off dynamic reordering, insert all of the elements at the end of the heap, and then reorder the entire heap (at a cost of O(n)) just before the element needs to be popped. The important thing about heaps is that it only costs O(n) to put an array into heap order but O(n log n) to sort it.  I have used this approach successfully in a large project with dynamic priorities.  A standard binary heap supports 5 operations (the example below assume a max heap):  As you can see, in a max heap, you can increase an arbitrary key. In a min heap you can decrease an arbitrary key. You can't change keys both ways unfortunately, but will this do? If you need to change keys both ways then you might want to think about using a a min-max-heap.  12k1212 gold badges5959 silver badges123123 bronze badges  2  1  I don't see how a binary heap could efficiently support increase-key if you first need to search for the element you wish to increase. Since there is no ordering in the heap, it will take linear time to find the element.  You must to have a reference to the element in order to make increase-key and decrease-key efficient. This is implemented with handles in the Boost.Heap C++ library boost.org/doc/libs/1_55_0/doc/html/heap/…  I would suggest first trying the head-in approach, to update a priority:  delete the item from the queue  re-insert it with the new priority  In C++, this could be done using a , the important thing is that the object must remember where it is stored in the structure to be able to delete itself efficiently. For re-insert, it's difficult since you cannot presume you know anything about the priorities.  262k4141 gold badges398398 silver badges665665 bronze badges  1  Thanks Matthieu, I thought about using that approach but due to the frequency of update it wasn't efficient enough for my needs. I ended up using an implementation that included a dictionary mapping items to their indexes in the queue, then having a method on the queue, UpdatePosition(Item item), that looks up the items index and then bubbled it to its new position. The queue then has an event that the items register against so that they notify the queue when their priorities change. That seems to work well.  However, this sounds like something that would be a homework problem, so if it is, I'd suggest trying to work through the ideas yourself first, then potentially referencing someone else's implementation if you get stuck somewhere and need a pointer in the right direction. That way, you're less likely to be "biased" towards the precise coding method used by the other programmer and more likely to understand why each piece of code is included and how it works. Sometimes it can be a little too tempting to do the paraphrasing equivalent of "copy and paste".  465k7878 gold badges605605 silver badges537537 bronze badges  2  1  Thanks Dav but this is a standard priority queue. If I add an item to the queue and it's priority is changed (outside of the queue), the order of the queue might be incorrect. In other words, a standard priority queue only sorts items when they are added to teh queue and not later. I need to implement a queue that updates as the priority of its items updates. P.S. It's not a homework problem, I need to implement this as part of some simulation software. I have some ideas of how I can implement it but want to see if there is a better way of doing it.  Ah. Okay. In that case, I'd suggest looking for example implementations of Dijkstra's Algorithm, which (if implemented in its most efficient form) requires a reorderable priority queue, and thus should probably have what you're looking for.  Since a priority of an item keeps changing, it's meaningless to sort the queue before retrieving an item.  So, we should forget using a priority queue. And "partially" sort the container while retrieving an item.  And choose from the following STL sort algorithms: a. partition b. stable_partition c. nth_element d. partial_sort e. partial_sort_copy f. sort g. stable_sort  partition, stable_partition and nth_element are linear-time sort algorithms, which should be our 1st choices.  BUT, it seems that there is no those algorithms provided in the official Java library. As a result, I will suggest you to use java.util.Collections.max/min to do what you want.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  