 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  My code consists of a recursive, memoized function to calculate the length of Collatz sequences followed by a loop to find the maximum. Please see the code below:  This worked fine in Clozure, but caused a heap overflow in Lispworks. As it exited ungracefully, I couldn't find out what happened. Actually, I don't understand why this consumes so much heap space—the biggest recursion sequence is 300-something calls. Did I miss some inefficiency in the code?  Any input is appreciated. Further comments on the code are appreciated as well.  PS: I'm using Lispworks Personal Edition, which imposes a limit on heap size.  UPDATE I did try compiling as Rainer Joswig suggested, but it didn't help.  Regarding coredump's and sds's comments, is indeed better than in this case, but I can't substitute the hash table for a vector because the collatz sequence goes up about 50% of the time. After running the code, the hash table has some 2.5 million entries.  Finally, and strangely, I managed to reproduce the bug while testing the syntax of a longish loop (a million iterations) that just juggled some variables and didn't collect anything at all. I lost the code unfortunately—LispWorks just went poof, alas. My best guess is that there's some leak or other memory management glitch in LispWorks' entrails.  I cannot reproduce the overflow (no Lispworks here); all I can say is that is also written as  Are you using LispWorks Personal Edition? If so, then remember that hash tables are usually implemented upon arrays with lots of unused slots, so your hash table might grow enough to make LispWorks Personal Edition blow up on its heap limit, followed by its signature prompt exit without a chance to recover.  UPDATE: I did try compiling as Rainer Joswig suggested, but it didn't help. I'm wondering if there's any way of making Lispworks compile stuff more aggressively.  LispWorks just went poof, alas. My best guess is that there's some leak or other memory management glitch in LispWorks' entrails.  You are using the personal edition of LW, which has a memory limit, and this stuff reaches this limit. It raised a dialog that says that, and then quits.  The commercial editions of LW run it without any problem.  You are using a hash table indexed by a contiguous integer sequence. You should probably be using an (extensible) vector instead.  Your recursion is not tail-recursion; you might prefer to optimize that.  Admittedly, none of these could explain a heap exhaustion.  I think there might be a problem with having to resize the hash table each time you call  (setf (gethash n collatz))  with a number n higher than the current table size. When you call make-hash-table without a size parameter, the system chooses an implementation dependent value. Every time that this value is exceeded, the table has to be resized during execution time, which consumes a lot of resources and might lead to the crash you mention. To solve this issue, you can create the table with a value that you know will not be exceeded:  I'm running LispWorks 7.1.1 64bit on a Mac, using the interpreter  So above shows a 'stack overflow', not a 'heap overflow'. Notice that one can resize the stack and continue.  Now I tried it again in a fresh LispWorks, but compiling the function:  The compiled code works fine without the need to grow the stack.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  