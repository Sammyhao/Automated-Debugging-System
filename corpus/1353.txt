 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Printed out the address of head and &head: head:0x603050 &head :0x7fffffffe4b8: what does this signify?  Main function where all other functions are called from link list is 8,4,2 main function  > Printed out the address of head and &head: head:0x603050 &head :0x7fffffffe4b8: what does this signify? 0x603050 is a pointer to the first node which is in the heap, 0x7fffffffe4b8 is a pointer to head which is on the stack. In order to change the address in head, you need to change the address stored in 0x7fffffffe4b8.  3 Answers 3  Why do we need to pass it by reference of reference such as in push(node* &head, int key)  Otherwise it won't work to set the given as current :  What you have is a reference to a pointer () that will be 'returned' from the function, and set the pointer passed from the caller correctly:  Don't forget to all the instances you have created with . In a different context as you're showing, this might lead to memory leaks.  That's not a "reference of reference"; it's a reference to a pointer.  It means that, once the pointer has been set to point to the new element, within the function, this change also affects the pointer you originally passed in to the function.  It probably should do, actually, if the function performs a sort over all elements of the list.  After this call, now points to the new head of the list. This would not be possible if you'd passed by value.  An alternative implementation might the new head pointer, instead of using this "out parameter" convention.  The reason you must pass to the function is because your function is expecting to modify the value of the pointer. If you don't pass it by reference, any changes to it will only be available within the function call. For example, if it was not passed by reference, and you passed (initialized to ), to the function, a new item would be created, but your value for would only be updated inside the function. Once you left the function, it will still be (because you passed the pointer by copy).  Note that this can go away if you create a linked list class instead of treating your nodes as a linked list themselves (that is, encapsulate the nodes under a list interface - which is what the standard library does).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  