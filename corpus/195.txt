 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  When calling 'exit', or letting my program end itself, it causes a debug assertion:  .  Pressing 'retry' doesn't help me find the source of the problem. I know that it's most likely caused by memory being freed twice somewhere, the problem is that I have no clue where.  The whole program consists of several hundred thousand lines which makes it fairly difficult to take a guess on what exactly is causing the error. Is there a way to accurately tell where the source of the problem is located without having to comb line for line through the code?  2,51133 gold badges2424 silver badges5757 bronze badges  3  Why doesn't "Retry" help? Have you tried running from the debugger from the start? Have you checked all your destructors? You follow the rule of three?  Going through it step by step leads me to an exit(mainret); call inside crtexe.c, which causes the exception. Clicking 'retry' leaves me with a 'msvcr120d.i386.pdb not loaded' screen and an empty callstack. I usually always make sure to destruct all of my objects properly, but since I'm getting this error, I assume I must've messed up somewhere, my problem is that I have no clue where.  Like I said, check all your destructors, but more importantly read about the rule of three, and remember that the default copy-constructors and copy-assignment operators only does a shallow copy.  4 Answers 4  this kind of errors usally appear if you delete already deleted objects.  this happens if one object is given to multiple other objects that are supposed to take ownership of that first object and both try to delete it in their destructor.  As the messagebox already suggests, you're probably corrupting your heap in some way. Either you free/delete some memory block that you should not or you're trying to write to some memory block that has already been freed/deleted.  The callstack suggests that this is probably happening when stepping over the last line of your function. If that is the case, then the problem is probably in the cleanup routines of some user defined types of which you create instances inside the function. Try setting breakpoints inside the destructors of your own classes and investigate.  It is possible that you are corrupting the heap during the program operation, but it is not being detected until the end of the program, in which case the stack trace would only point to the memory checking routine  There may be a function you can call during operation that checks if the heap is valid, which may bring the fail closer to the point of corruption  HeapValidate is an example of such a routine, but it would depend on what platform you are using  45k1717 gold badges6666 silver badges7777 bronze badges  2  I've tried calling it right at the end of my program, the return value was 1, so the heap's fine until that point. It would help me if I could get a list of objects that haven't been destructed yet at that point but I assume that's not possible.  @Silverlan By that point you should have already deleted all the objects you allocated on the heap. The only objects left should be ones you allocate on the stack, and you can force those to be deleted before you call exit by putting them inside a separate function  This error can also happen when you use instead of . However, as mentioned, this is only one of many causes.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  