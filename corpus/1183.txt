 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  You need to sort a queue in a new member method you add to the queue.  The rules are:  You can not use any loops. Only recursion is allowed.  You can create as many private methods as you wish.  You may create and use two auxiliary queues of the same kind (call it Queue - has a default constructor).  You don't know anything about the internal structure of the queue.  The only methods given to you are:  returns null if the list is empty, ignores null inputs.  The sorting order needs to be ascending (front of queue should have the smallest value).  The comparable value is in integer inside the structure, called .  I know it can be solved. I have yet to find an answer for this. Any ideas would be appreciated.  @userunknown Yes this is homework. What I have so far is an auxiliary method which takes a queue to sort, and splits it to 2 new queues, high and low, by each time taking 2 elements off the queue and putting them in the right auxiliary queue. This works well with even-length queues, but not with odd-length ones.  Well a) show us the code. b) What is the problem with odd-length queues? If this is your only problem - maybe you can add the last element twice, and remove one of them in the end?  5 Answers 5  Now - after solving this - improve the solution to sort N+1 Elements if N elements are sorted.  update:  Now, after you solved your homework, I can show an alternative solution in scala:  It works without an explicit second queue. The insert is a sortedInsert.  I used a List to implement the Queue, but use it only for creating a new Queue and for debug reasons. Avoiding it would not be a big deal, but it was faster, and I wanted to start with the sorting. :)  33.6k1111 gold badges7272 silver badges116116 bronze badges  1  I believe there's a bug in your use of sorted insert. I think it has to do with peeking and then enqueuing where you should have "pushed". In other words I believe it doesn't work very well with a queue. The idea was very nice, though. If you care to try again and come up with a correct answer, I'll accept your answer.  look at merge sort. It was used for sorting data on tapes. I believe you can esily adopt it for queue.  First of all, thanks for the answers. They pointed me to the right solution. I voted them up to give credit, but since I managed to solve this question, I'll accept my own answer (at least until a better one comes).  So first of all, the homework was about "Taxies" (you know how homework is...) and a TaxiQueue, in Java.  The solution was:  I hope that other students may find it useful some day!  @Yam Marcovic: Your answer is fine. Although you end up creating as many queues as there are elements in the original queue. May be that's something you would not like to do. Instead you could try a simpler approach where you would have to create only 2 new queues altogether ( call them originalQ, Q1, Q2 ).  Ill describe the recursive step.  Assume Q1 has n1 elements already sorted.  let new element from originalQ be s. If s can't be positioned correctly in Q by one enqueue operation then keep popping elements from Q1 ( compare them with s ) and put them correctly in Q2.  Now your Q2 is sorted with n1+1 elements, Q1 is empty. originalQ has one element less.Keep repeating the above steps.  The following method would aim to solve this problem using just one additional queue.  The algorithm uses Recursion to sort the queue.  Assume we have a function copy_from that can copy from one queue over to another queue as follows :-  The main sort function is as shown :-  When we initially call the sort function, we can call it as follows :-  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  