 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a simple recursive function that provides a depth first search of each possible combination of a list of options:  The ouput (shortened due to length) looks as follows:  And that is all well and good and works how i want it. But I am interested in converting this from depth first to breadth first so the output looks more like:  I have been somewhat able (only a hard-coded fixed length list) to do it iteratively, but desire a recursive solution so it can work for any length of options. I am also purposely avoiding python libraries that provide the functionality i seek because i would like to understand how things work and build my own stuff as a learning exercise.  I feel like there is a simple solution, but i am having trouble conceptualizing the breadth first algorithm into my code.  UPDATE  Before attempting a recursive BFS solution i wanted to create an iterative BFS solution as it appears to be easier to implement. As it turns out, i am also having trouble doing that.  This achieves my desired output (listed above), but only works for a set where i know the length. I want to expand it for a list of an arbitrary length, but am having trouble doing that. I imagine if I can get the iterative solution working, a recursive solution isn't far behind.  3,27122 gold badges2626 silver badges3333 bronze badges  6  6  I don't know if BFS makes sense as a recursive function. The basic difference between DFS and BFS is that DFS uses a stack to track unvisited nodes and BFS uses a queue. Recursive DFS implementations are basically just using the call stack as that stack. Try writing a non-recursive DFS (hint: python lists can be treated like stacks), and then try replacing the stack in that implementation with a queue (You can use for a FIFO queue)  @PatrickHaugh That is a good tip. wanted to flex my recursive muscles, but going to a non-recursive DFS then from there to a non-recursive BFS is a good learning process for me  Agree with @PatrickHaugh 100%, implementing a BFS as a recursive function would require jumping through some complicated hoops. BFS is much more naturally implemented with loops.  That insight about DFS "using the call stack" as the data structure itself is great.  @Turksarama: It's not really complicated hoops; there's languages where recursion is the only available looping construct, and they obviously still can implement BFS. The problem is more that Python does not (and never will) support Tail Call Optimisation, so you can't do it without wasting a ton of memory.  2 Answers 2  Edit: I did't notice from the example that all permutations was required. Follows a function that uses a list as a queue:  Which works like this (64 lines, truncated):  Also,  this version returns a list instead of printing.  Follows the previous answer, not considering permutations:  As already said by others in the comments, it's not natural. Follows a "recursive" function:  The in the last line requires Python3, but you can remove that.  Brilliant. I had the same concept of using a level but got stuck on trying to implement a separate dict/list similar to OP's DFS. Now I can sleep... thanks.  This is a good start to the solution, but one thing: Order is relevant, so I need every possible combination. For example: [q,w] and [w,q] should appear in the list. The key i think i was missing was tracking the level. I will try to build off this today...  @MatteoT. Yes, that is more of less what I am looking for. It is not recursive, but after reading more about DFS and BFS i am content with using an iterative solution as a recursive BFS doesn't make a whole lot of sense. I ended up modifying your solution for more my coding style but yours works and will be marked as such. Thanks!  I am posting an answer for my own question to offer some clarity regarding depth first search and breadth first search. My initial goal was a recursive breadth first version of my recursive depth first function. This came from a lack of understanding of the fundamental difference between DFS and BFS: DFS uses a stack and BFS uses a queue. (Thanks to @Patrick Haugh for the insight as well as this post: Performing Breadth First Search recursively).  The fact that DFS uses a stack lends itself well with a recursive function because you can use the call stack as your operating stack. But This doesn't work for the queue style of a BFS. Breadth First Search can be done recursively, but ends up resembling a bit of a mangled depth first search. It is much cleaner and intuitive to keep BF as an iterative function.  Never a fan of copy/pasting code without understanding why it works, @Matteo T. correct answer guided me to the iterative BFS solution without enumeration which i am currently implementing:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  