 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am relatively new to Java, and often find that I need to sort a on the values.  Since the values are not unique, I find myself converting the into an , and sorting that array through array sort with a custom comparator that sorts on the value associated with the key.  A map is not meant to be sorted, but accessed fast. Object equal values break the constraint of the map. Use the entry set, like and it that way.  A case where this might arise when we try to make use of a Counter in Java (Map<Object, Integer>). Sorting by number of occurrences would then be a common operation. A language like Python has a built in Counter data structure. For an alternate way of implementation in Java, here is an example  There are plenty of use cases for sorted maps, that's why you have TreeMap and ConcurrentSkipListMap in jdk.  TreeMap and ConcurrentSkipListMap sort by key. The question is about sorting by value.  I'd like to add that depending on your use case, it may be reasonable to simply keep a duplicate TreeMap that maps your value to your keys. For example, your regular map may have "a" -> 5, "b" -> 7". And your "sorted" map can have 5 -> "a", 7 -> "b". You would just use whichever map is appropriate in different places and make an effort to always modify the two maps together. It's not pretty and there are many caveats and assumptions, but for some cases it can be a straightforward and efficient answer compared to all the top answers here which rely on actively sorting your values.  62 Answers 62  Glad this helps. John, the LinkedHashMap is important to the solution as it provides predictable iteration order.  @buzz3791 True. That's going to be the case in any sorting algorithm. Change the value of nodes in a structure during a sort creates unpredictable (and nearly always bad) results.  @Sheagorath I tried it in Android and it works too. It is not a platform specific problem, considering you are using the Java 6 version. Have you implemented Comparable correctly in your value object?  Shouldn't the Java 8 version use instead of , since the docs of states: "The behavior of this operation is explicitly nondeterministic."?  totally ripped this, but credited @CarterPage in the comments (it'll be in an open source project anyway). thanks so much.  Important note:  This code can break in multiple ways. If you intend to use the code provided, be sure to read the comments as well to be aware of the implications. For example, values can no longer be retrieved by their key. ( always returns .)  It seems much easier than all of the foregoing. Use a TreeMap as follows:  @Stephen: No. In this case all keys equal by value are dropped (difference between equals and comparion by reference). Additionally: Even this code has problems with the following sequence  The comparator used for the treemap is inconsistent with equals (see the sortMap javadox). This means retireving items from the tree map will not work. sorted_map.get("A") will return null. That means this use of treemap is broken.  Just in case it's not clear to people: this solution will probably not do what you want if you have multiple keys mapping to the same value -- only one of those keys will appear in the sorted result.  Louis Wasserman (yes, one of the Google Guava guys), actually dislikes this answer quite a bit: "It breaks in several really confusing ways if you even look at it funny. If the backing map changes, it will break. If multiple keys map to the same value, it will break. If you call get on a key that isn't in the backing map, it will break. If you do anything whatsoever that would cause a lookup to happen on a key that isn't in the map -- a Map.equals call, containsKey, anything -- it will break with really weird stack traces." plus.google.com/102216152814616302326/posts/bEQLDK712MJ  Java 8 offers a new answer: convert the entries into a stream, and use the comparator combinators from Map.Entry:  This will let you consume the entries sorted in ascending order of value. If you want descending value, simply reverse the comparator:  If the values are not comparable, you can pass an explicit comparator:  You can then proceed to use other stream operations to consume the data. For example, if you want the top 10 in a new map:  It will work in parallel, however, you may find that the cost of merging maps to combine the partial results is too expensive and the parallel version may not perform as well as you'd hope. But it does work and produce the correct answer.  Thanks for your useful advice. It was exactly what I was wondering, though it depends on what type of key you use and so many parameters... The important thing is "it does work and produce the correct answer".  @Benj it will work in terms of extracting the top-10, but the resulting map will no longer be ordered.  I would use Google Collections Guava to do this - if your values are then you can use  Which will create a function (object) for the map [that takes any of the keys as input, returning the respective value], and then apply natural (comparable) ordering to them [the values].  If they're not comparable, then you'll need to do something along the lines of  NB: If you are going to use a TreeMap, remember that if a comparison == 0, then the item is already in the list (which will happen if you have multiple values that compare the same). To alleviate this, you could add your key to the comparator like so (presuming that your keys and values are ):  = Apply natural ordering to the value mapped by the key, and compound that with the natural ordering of the key  Note that this will still not work if your keys compare to 0, but this should be sufficient for most items (as , and are often in sync...)  Implementation  So now that we've got a comparator that does what we want, we need to get a result from it.  Now this will most likely work work, but:  needs to be done given a complete finished map  Don't try the comparators above on a ; there's no point trying to compare an inserted key when it doesn't have a value until after the put, i.e., it will break really fast  Point 1 is a bit of a deal-breaker for me; google collections is incredibly lazy (which is good: you can do pretty much every operation in an instant; the real work is done when you start using the result), and this requires copying a whole map!  "Full" answer/Live sorted map by values  Don't worry though; if you were obsessed enough with having a "live" map sorted in this manner, you could solve not one but both(!) of the above issues with something crazy like the following:  Note: This has changed significantly in June 2012 - the previous code could never work: an internal HashMap is required to lookup the values without creating an infinite loop between the -> and ->  When we put, we ensure that the hash map has the value for the comparator, and then put to the TreeSet for sorting. But before that we check the hash map to see that the key is not actually a duplicate. Also, the comparator that we create will also include the key so that duplicate values don't delete the non-duplicate keys (due to == comparison). These 2 items are vital for ensuring the map contract is kept; if you think you don't want that, then you're almost at the point of reversing the map entirely (to ).  Hi @Stephen , can you give an example how to use Ordering ? I look into Ordering's source code , and totally cannot figure out what .natural().onResultOf(...) returns! The source code is "public <F> Ordering<F> onResultOf" , I even don't know how it compiles ! Most important , how to use "<F> Ordering<F>" to sort a map ? Is it a comparator or something ? Thanks.  is simply a rich . I've tried commenting each example (the italics underneath each one). "natural" indicates that the objects are ; it's like apache common's ComparableComparator. applies a function to the item being compared. So if you had a function that added 1 to an integer, then would end up doing  ImmutableSortedMap.copyOf throws IllegalArgumentException if there are duplicate values in the original map.  @Ibalazscs Yes it will - You should be able to use or to contain the collection of duplicate variables.  Thanks for this, I used your solution in one project. I think there's a problem in put though: to behave like a map it needs to return the value previously associated with the key, if it exists, but like this it will never do. The solution I used is to return the removed value if it exists.  The list to be sorted is "new LinkedList"?? Gee. Thankfully Collections.sort() dump the list to an array first, to avoid precisely this kind of error (but still, dumping an ArrayList to an array should be faster than doing the same for a LinkedList).  @gg.kaspersky I'm not saying "it's bad to sort a LinkedList", but that LinkedList itself is a bad choice here, regardless of sorting. Much better to use an ArrayList, and for extra points, size it at exactly map.size(). Also see code.google.com/p/memory-measurer/wiki/… average cost per element in ArrayList: 5 bytes average cost per element in LinkedList: 24 bytes. For an exactly sized ArrayList, the average cost would be 4 bytes. That is, LinkedList takes SIX times the amount of memory that ArrayList needs. It's just bloat  using above values has been sorted in ascending order. How to sort in descending ?  With Java 8, you can use the streams api to do it in a significantly less verbose way:  I think I see a typo there -- shouldn't the " toMap " be called as " Collectors.toMap() " ?  Sorting the keys requires the Comparator to look up each value for each comparison. A more scalable solution would use the entrySet directly, since then the value would be immediately available for each comparison (although I haven't backed this up by numbers).  Here's a generic version of such a thing:  There are ways to lessen memory rotation for the above solution. The first ArrayList created could for instance be re-used as a return value; this would require suppression of some generics warnings, but it might be worth it for re-usable library code. Also, the Comparator does not have to be re-allocated at every invocation.  Here's a more efficient albeit less appealing version:  Finally, if you need to continously access the sorted information (rather than just sorting it once in a while), you can use an additional multi map. Let me know if you need more details...  The second version can be more concise if you return List<Map.Entry<K,V>> This also makes it easier to iterate and get both the keys and the values without having to do a lot of extra gets to the map. This is all assuming you are ok with this code being thread-unsafe. If the backing map or sorted list are shared in a multithreaded environment, all bets are off.  The commons-collections library contains a solution called TreeBidiMap. Or, you could have a look at the Google Collections API. It has TreeMultimap which you could use.  And if you don't want to use these framework... they come with source code.  You don't have to use the commons-collection. Java comes with its own java.util.TreeMap.  yes, but TreeMap is far less flexible when sorting on the value part of the mapentries.  The trouble with BidiMap is that it adds a 1:1 relation constraint between keys and values in order to make the relation invertible (ie. both keys and values need to be unique). This means you can't use this to store something like a word count object since many words will have the same count.  I've looked at the given answers, but a lot of them are more complicated than needed or remove map elements when several keys have same value.  Here is a solution that I think fits better:  Note that the map is sorted from the highest value to the lowest.  PROBLEM: if you want to use the returned map later, for example to check if it contains a certain element, you will always get false, because of your custom comparator! A possible solution: replace the last line with: return new LinkedHashMap<K,V>(sortedByValues);  This looks a clean solution to me , except the fact that @ErelSegalHalevi pointed out , checking whether the values exist in the Map will not be possible as you specified the comparator. map.put("1", "One"); map.put("2", "Two"); map.put("3", "Three"); map.put("4", "Four"); map.put("5", "Five"); map.containsKey("1") will always return false , if you return new object in the function sortByValues() like return new TreeMap<K, V>(sortedByValues); solves the problem . Thanks Abhi  pretty much the same as user157196's and Carter Page's answer. Carter Page's contains the LinkedHashMap fix  4th line of the solution should be int compare = map.get(k1).compareTo(map.get(k2)); if you need ascending order  To accomplish this with the new features in Java 8:  The entries are ordered by their values using the given comparator. Alternatively, if your values are mutually comparable, no explicit comparator is needed:  The returned list is a snapshot of the given map at the time this method is called, so neither will reflect subsequent changes to the other. For a live iterable view of the map:  The returned iterable creates a fresh snapshot of the given map each time it's iterated, so barring concurrent modification, it will always reflect the current state of the map.  In the case the values are equal, I changed the "return 1" line to compare the keys: "return ((String) o1).compareTo((String) o2);"  It works but I don't understand how the order of elements comes in play in a HashMap?  If you mean pure HashMap, the order does not come in play. But in LinkedHashMap, the insertion order is preserved.  While I agree that the constant need to sort a map is probably a smell, I think the following code is the easiest way to do it without using a different data structure.  }  And here is an embarrassingly incomplete unit test:  }  The result is a sorted list of Map.Entry objects, from which you can obtain the keys and values.  This method is much easier and more intuitive than creating a Map<V, List<K>> object with pretty much the same effect. The values are not really supposed to be keys in a Map object, what you're really looking for is a list in this situation, IMHO.  This solution doesn't work with lots of values, it screwed with my counts (the value associated with each key)  That's strange. Could you elaborate? What was your output and what was the output you expected?  The answer voted for the most does not work when you have 2 items that equals. the TreeMap leaves equal values out.  the exmaple: unsorted map  results  So leaves out E!!  For me it worked fine to adjust the comparator, if it equals do not return 0 but -1.  in the example:  class ValueComparator implements Comparator {  Map base; public ValueComparator(Map base) { this.base = base; }  } }  now it returns:  unsorted map:  as a response to Aliens (2011 nov. 22): I Am using this solution for a map of Integer Id's and names, but the idea is the same, so might be the code above is not correct (I will write it in a test and give you the correct code), this is the code for a Map sorting, based on the solution above:  and this is the test class (I just tested it, and this works for the Integer, String Map:  here is the code for the Comparator of a Map:  and this is the testcase for this:  of cource you can make this a lot more generic, but I just needed it for 1 case (the Map)  you were right, there was some error in the code I gave at first! i Hope my recent edit will help you.  Instead of using as some do I'd suggest using . Actually what does is something like this:  It just calls on the list and then uses . This way all the map entries will be copied three times: once from the map to the temporary list (be it a LinkedList or ArrayList), then to the temporary array and finally to the new map.  My solution ommits this one step as it does not create unnecessary LinkedList. Here is the code, generic-friendly and performance-optimal:  This is a variation of Anthony's answer, which doesn't work if there are duplicate values:  Note that it's rather up in the air how to handle nulls.  One important advantage of this approach is that it actually returns a Map, unlike some of the other solutions offered here.  It's incorrect, my method works if there are duplicate values. I've used it with maps having more than 100 keys with "1" as value.  With the advent of Java-8, we can use streams for data manipulation in a very easy/succinct way. You can use streams to sort the map entries by value and create a LinkedHashMap which preserves insertion-order iteration.  Thanks for this commented version. One question: What is the difference of using (as assylias answer above stackoverflow.com/a/22132422/1480587) or that you used? I understand you also compare keys if values are identical, right? I noticed that the sorting keeps order of elements with the same value - so is sorting by keys necessary if the keys happen to be already sorted before?  Major problem. If you use the first answer (Google takes you here), change the comparator to add an equal clause, otherwise you cannot get values from the sorted_map by keys:  Now when you add two entries with equal values they will be merged you should only return 0 if you are sure that the objects are the same (equal)  There are a lot of answers for this question already, but none provided me what I was looking for, a map implementation that returns keys and entries sorted by the associated value, and maintains this property as keys and values are modified in the map. Two other questions ask for this specifically.  I cooked up a generic friendly example that solves this use case. This implementation does not honor all of the contracts of the Map interface, such as reflecting value changes and removals in the sets return from keySet() and entrySet() in the original object. I felt such a solution would be too large to include in a Stack Overflow answer. If I manage to create a more complete implementation, perhaps I will post it to Github and then to it link in an updated version of this answer.  Not sure if I understand your use case, maybe you can elaborate. If the object you wish to use as a value is not Comparable then you would need to convert it to an object that is.  Depending on the context, using which rememebers the order in which items are placed into the map. Otherwise, if you need to sort values based on their natural ordering, I would recommend maintaining a separate List which can be sorted via .  I don't see why this was -1, so far LinkedHashMap is probably the best solution for me, I'm just trying to figure out how expensive it is to throw away and create a new LinkedHashMap.  Since TreeMap<> does not work for values that can be equal, I used this:  You might want to put list in a LinkedHashMap, but if you're only going to iterate over it right away, that's superfluous...  This is just too complicated. Maps were not supposed to do such job as sorting them by Value. The easiest way is to create your own Class so it fits your requirement.  In example lower you are supposed to add TreeMap a comparator at place where * is. But by java API it gives comparator only keys, not values. All of examples stated here is based on 2 Maps. One Hash and one new Tree. Which is odd.  Based on @devinmoore code, a map sorting methods using generics and supporting both ascending and descending ordering.  Then again maybe a better solution would be to just use a self sorting map, in the case use org.apache.commons.collections.bidimap.TreeBidiMap  Some simple changes in order to have a sorted map with pairs that have duplicate values. In the compare method (class ValueComparator) when values are equal do not return 0 but return the result of comparing the 2 keys. Keys are distinct in a map so you succeed to keep duplicate values (which are sorted by keys by the way). So the above example could be modified like this:  For sure the solution of Stephen is really great, but for those who can't use Guava:  Here's my solution for sorting by value a map. This solution handle the case where there are twice the same value etc...  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  