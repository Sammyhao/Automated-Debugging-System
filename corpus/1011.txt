 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I've got a bunch of items I'm storing in a min-heap (via ), and I have a need to efficiently delete arbitrary items. I know that in a standard min-heap implementation, deleting an arbitrary element (given that you know the position of that element in the heap) takes O(log n) time, while finding the position is O(n). So, basically, I need to keep a separate data structure which holds each item's position in the heap.  I more-or-less know how I'd implement this from scratch, but I'm wondering if there's a smart way to utilize/subclass (which has other useful features) to accomplish this.  To clarify, I need the O(1) peek-min that a PQ/Min-Heap affords.  @ead That won't give me O(1) remove-min or peek-min operations, though, which I need. Updating question to clarify.  I'm not aware of such a possibility and would be surprised if there would be one, but who knows...  remove-min is not O(1). peek is O(1), but remove-min is O(log n). If you want O(log n) removal of arbitrary nodes, you need to update that separate data structure every time a node is moved in the PQ array. I don't see where Java's PQ implementation has a notification that you could tie into. Probably your best bet would be to get the Java PQ source code and modify it to meet your requirements. Or, use something like a Paring heap, which makes this kind of thing pretty easy.  Does a balanced BST, with an additional reference to the minimum do this? Any time you insert, you know if it's smaller than the minimum and can update, any time that you delete the minimum, you can locate the new minimum in O(log n) which doesn't change the complexity of deleting it. Seems like it should work. Also gets you find in O(log n). To be fair, deleting the minimum, that you already have a reference to in a well balanced BST should actually be O(1) if there are strict enough requirements on the balancing, I think, and you should find new min during that. Not sure, and out of chars.  2 Answers 2  TreeMap does not support O(1) for deletion, however, it performs deletion operation in O(logN). Far better than O(N) support by PriorityQueue. It also returns the head of the collection ( min or max element depending on the comparator just like PriorityQueue ). Along with that it also returns the tail of the collection ( max or min ). Tail functionality is not supported by PriorityQueue and hence you sometimes end up keeping two queues to track both head and tail.  Definitions  A Red-Black tree based NavigableMap implementation. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.This implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations. Algorithms are adaptations of those in Cormen, Leiserson, and Rivest's Introduction to Algorithms.  A red–black tree is a kind of self-balancing binary search tree in computer science. Each node of the binary tree has an extra bit, and that bit is often interpreted as the color (red or black) of the node. These color bits are used to ensure the tree remains approximately balanced during insertions and deletions.  Runtimes:  I also needed fast (log N) heap deletion for timeout handling. Java's standard PriorityQueue is pretty ineffective when you have tens of thousands of elements in the queue which you have to delete very often.  So basically it maintains an extra hash map with element-to-heap index which allows fast O(log N) deletion. It comes with a cost of slower insertion though.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  