 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I got a program which is using an and that type T also implements . I need to keep that list sorted.  For now, when I insert a new item, I add it to the and then invoke .  Is sorting with every time I insert a new item seriously hurt run time complexity?  Is there a better suited data structure I can use to always keep the list sorted? I know of a structure called a but I also need to be able to get the list's elements by index.  EDIT: In my specific case, inserting a new item happens much less than geting an already existing item, so eventually a good advice could also be to stay with the since it got a constant time complexity of getting an item. But if you know of anything else...  Any particular reason you are not able/permitted to insert any new element into its sorted location?  instead of Collections.sort, you could use a binary search to find the insertion point - that would be more efficient.  4 Answers 4  It seems like is actually the way to go here since when the collection is already almost sorted, the sorting will take not longer than O(n) in the worst case.  Instead of using after every insertion you might want to do something a bit smarter as you know that every time you insert an element your collection is already ordered.  takes 0(nlogn) time, you could do an ordered insert in an ordered collection in O(n) time using . If the collection is ordered in ascending order returns the index of the element you are looking for if it exists or . Before inserting an element you can look for it with (O(logn) time). Done that you can derive the index at which inserting the new element. You can then add the element with in O(n) time. The whole insertion complexity is bounded by the so you can do an ordered insert in an ArrayList in O(n) time.  From the documentation of : "This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted."  "far fewer than n lg(n)" does not necessarily mean O(n) in the worst case. Moreover, as far as I know merge sort also requires a temporary copy of the collection that you do not need with binarySearch (I might be wrong).  As you noted yourself, the list is already sorted but for one element. The worst-case behavior of does not apply. "If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays ..."  So from Andy's comment, I understand that Collections.sort() (how do you mark a code in grey like you do in an answer or question? ctrl+k doesn't work here), is actually not that bad since when it's almost sorted it's gonna be O(n) in the worst case? which is similiar if I just iterate over the list and look for the index.  From Java 7 implements a modified version of Python's TimSort which for partially ordered collections needs less than lg(N!) comparisons and as few as N-1. Since your array is always sorted but one element we can soundly assume that the worst case for is O(n).  List is an ordered collection, which means you need to have the ability to access with index. If a collection internally shuffles or sorts the elements, the insertion order wont be same as the order of the elements in the internal data structure. So you cannot depend on index based access anymore. Hence Sun didn't provide a SortedList or a TreeList class. That is why you use Collections.sort(..)  A single data structure cannot provide both sorting and index based retrieval. If the input set is limited to a few hundreds or thousands, you can keep two data structures in parallel.  For example, ArrayList for index based retrieval and TreeMap (or priority queue) for sorting.  -1 a simple binary tree can easily support O(log n) index-based retrieval by keeping track of how many children are in each sub-tree. Or a sorted array-list with O(1) retrieval but O(n) inserts.  There are 20 items in the left subtree and 30 items in the right subtree, and the user wants index 25. Since the tree is ordered, items 1-20 are in the left subtree, 21-50 are in the right. So recurse into the right subtree, looking for index 5. I use exactly this method for my weighted item randomizer (specifically here)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  