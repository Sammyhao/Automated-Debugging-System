 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  When addressed the Binary_Search in chapter 2(2.4.4),the author mentioned that "  Notice that the variables cannot be declared unsigned(why?).In cases where the unsigned qualifier is questionable, we will not use it. As an example, if the unsigned qualifier is dependent on an array not beginning at zero, we will discard it. we will not use it. As an example, if the unsigned qualifier is dependent on an array not beginning at zero, we will discard it. We will also avoid using the unsigned type for variables that are counters in a for loop, because it is common to change the direction of a loop counter from increasing to decreasing and the unsigned qualifier is typically appropriate for the former case only. For example, the code in Exercise 2.10 does not work if i is declared unsigned. ".  The code as follow:  Q: I can't understand that the variable cannot be declared unsigned.Why the unsigned qualifier is questionable? And how does unsigned qualifier change the direction of a loop counter from increasing to decreasing?  Answer to your last question: ; when you reverse it, you can easily make a mistake: (decent compiler may give you a warning).  2 Answers 2  If is 0, you want the line to set to -1, which will cause the loop to stop.  If the variables were unsigned, would wrap around to the maximum unsigned value which would cause a read past the end of the buffer and a likely crash.  As for for loops which count down, the following loop will never end:  Because is unsigned, the condition will always be true.  The author of the book is wrong and it seems he is a weak programmer.:)  First of all it is a bad idea to use the type as the size of an array. He should use the type or at least the type defined in the header because the value of size of an array can be greater than the value that the type can accommodate.  Take into account that all C standard functions (as for example string functions) that deal with array sizes define corresponding parameters as having the type .  Here is the declaration of the standard function .  The both parameters, and , have type .  The problem is not with signed or unsigned int type used as the type of the array size. The problem is how the algorithm is implemented.  For example he could implement the algorithm the following way as it is shown in the demonstrative program  The program output is  As you see if a value is not found in the array then the function returns the index that is equal to the size of the array.  Usually the binary search algorithm that returns the index of the target element is defined as the lower bound algorithm.  Here is an example of an implementation of the binary search algorithm that returns the lower position where the target element is present or could be inserted.  The program output might look like  As you see neither signed type is used in the implementation of the algorithm.  As for the loop shown in the other answer like this  then again it is just written incorrectly. Instead of the loop in this case there should be used loop as for example  @user58697 Oh. it seems I have understood you. You mean that the expression low + high can yield an overflow do not you?  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  