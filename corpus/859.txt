 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Can anyone provide either code, pseudocode, or even provide good links to implementing DFS and BFS in plain JavaScript (No JQuery, or any helper libraries)? I've been trying to understand how to implement either traversal, but I can't seem to really distinguish the difference of a BFS and DFS implementation.  If we want a concrete problem as an example: I want to traverse down the DOM at a given node, and get all the class names.  (The only way I can think to traverse is to go through each parent node, get what I need from that node which in this example is the class name, then see if they have children, recurse for each child. I believe this is DFS? Again, I'm having a hard time understanding the differences in a DOM traversal implementation!)  Finally, sorry if this is a repeat. I've searched everywhere for good, clear examples but haven't found any great answers! If there's already a good answer out there, please let me know :)  you probably didn't find anything on SO because questions like this are usually closed  @AmitKumar—please do not reference w3schools, it is full of errors. Far better to reference MDN.  I can't see that depth–first or breadth–first are necessarily recursive or linear. It would help if you explain what you think the difference is in regard to DOM traversal.  Do you know the TreeWalker API, no need to write it yourself, you won't get better results than what's already there.  3 Answers 3  DFS will always go to the next level of nodes first, and only if there are no more un-traversed child nodes will it step to a next node on the current level.  A DFS would traverse the nodes of the example in the following order:  BFS will always traverse all the nodes in the current level first and only after that will it go to the next level of nodes.  A BFS would traverse the nodes of the example in the following order:  There isn't a definite answer which one of these you should use. Usually it depends on your needs.  This code will go until there is any nodes in the stack. In each step we get the top node in the stack and if it's not null and if we haven't visited it before than we visit it and add all its children to the stack.  This code will go until there is any nodes in the queue. In each step we get the first node in the queue and if it's not null and if we haven't visited it before than we visit it and add all its children to the queue.  Note that the main difference between the two algorithm is the data type we use.  The two pseudo code is just generally about the algorithms. Of course you have to think how you define "children" in your current context. If you only need the class names you don't even need the text nodes though.  They are important because there's no point to adding a node that has no child nodes to the stack (other types of node don't have children either but text nodes make it obvious).  Of course there is. The pseudo code I provided visits the node when it pops it. So if you don't add a node to the stack because it has no child nodes means you won't visit any nodes that has no child nodes. That's not the general algorithm and I don't see the point of it anyway. We can argue what is the most optimal implementation of a BFS and where should we put our domain specific checks, but I don't see that's the point of this question. You are welcome to provide a pseudo code where you determine if a node should be visited some other place though.  @RobertF. awesome answer on explaining how the DOM would look with each traversal and walking through the difference between both!  This loops through all elements, and for each element through each child's and so on.  BFS:  This loops through the elements, pushes their children onto a stack, and starts again with each of them. As you can see, this consumes much more space (the child's array) which is not the best...  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  