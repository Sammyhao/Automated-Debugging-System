 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I was recently reading about stack & heap corruption in C & C++. The author of the website demonstrates stack corruption using below example.  I tested above program on visual studio 2010 compiler (VC++) & it gives me runtime error that says:  stack around variable a gets corrupted  Now my question: is stack corrupted for lifetime or it is only for the time during when above erroneous program was being executed?  Same way, I know that deleting same pointer twice might do really bad things like heap corruption. The following code:  When the above code fragment executes the VC++ shows heap corruption error at runtime.  You are getting technical answers but maybe you want a simple answer. As soon as your program has experienced stack or heap corruption, it's bad. You can't trust it to work any more. Unlike other errors, such as failing to read a file, stack or heap corruption is never an error that can be tolerated in released code.  @meet They can't be trusted to work. If you have stack or heap corruption, the program should be terminated, fixed and restarted.  To allow faster code. Other languages perform background checks against many common mistakes to help the programmer, but these have an overhead. C and C++ were first developed at a time when computers were much slower than today, and speed was important. But you CAN get these checks in C++, they are just optional. Use and instead of C-style arrays and new and delete. They offer you better protection against corruption. Try in Visual Studio debugger and see what happens.  3 Answers 3  It is Undefined Behaviour. You cannot know what will happen if you do 'forbidden' things. You have no guarantee that your program will work well.  I mean : you cannot know what will happen. Your program may continue to work seamlessly. But it may crash in the most unimmaginable way you cannot even think about. But it also could crash instantly.  You have to be careful with terminology here. Will the stack be "corrupted" for the remainder of your program's life? It may be; it may not be. In this instance you've only corrupted data within the current stack frame, so once you're out of that function call, in practice your "corruption" will have gone.  But that's not quite the whole story. Since you've overwritten a variable with bytes that aren't supposed to be there, what knock-on effects might that have on your program? The consequences of this memory corruption could feasibly be logically passed on to other function scopes, or even other computers if you're sending this data over a network connection and the data is no longer in the expected form. (Typically, your data protocol will have safety features built into it to detect and discard unexpected forms of data; but, that's up to you.)  The same is true of heap corruption. Any time you overwrite the bytes of something that is not supposed to be overwritten, and any time you do so with arbitrary or unknowable data, you run the risk of potentially catastrophic consequences that may logically last well beyond the lifetime of your program.  Within the scope of C++ as a language, this condition is summed up in a specific phrase: undefined behaviour. It states that you can't really rely on anything at all after you've corrupted your memory. Once you've invoked UB, all bets are off.  The one guarantee that you usually have in practice is that your OS will not allow you to directly overwrite any memory that does not belong to your program. That is, corrupting the memory of other processes or of the OS itself is very difficult. The memory model of modern OSs is deliberately designed that way in order to keep programs isolated and prevent this kind of damage from broken programs and/or viruses.  C++ as well as C does not have array boundary overflow or underflow check. However, you can abstract out, you may define an array with overloaded index operator (operator []) where you can check for array index out of bounds and act accordingly. When you delete a pointer using delete ptr (when ptr is allocated through new), the space allocated before is returned back to heap space, however the value of the pointer becomes same as before. So, it;s a good programming practice that you should make the ptr NULL after delete, e.g.  However, stack or heap corruption, if at all, lies confined within the program space and when the program terminates, normally or abnormally, all memory occupies are released back to the operating system  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  