 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to implement the function that trys to see if a word matches any word in a pre-sorted dictionary. Below is my current implementation:  The function works properly (this just stores a matching word into the array ensuring no duplicate words are stored.  The function will only match select words from the dictionary but not others.  Any ideas as to why this may not be working properly?  For reference, this implementation works, but is horribly inefficient and causes stack overflow errors.  @FeiXiang just edited to add this. It won't match certain words, but does work for others. My other algorihtm works for all words in dict.  Try using a debugger. Do you mean that if you give it certain words, the algorithm doesn't find the word? Are you sure the array is sorted lexicographically? Try making a minimal reproducible example which we can use to reproduce the problem.  Binary search which works for some values but not for others - sounds familiar. From my experience, the algorithm may have errors or better inaccuracies i.e. some border cases are not handled correctly, off by 1 mistakes, or something like this. I would try to find a non-working example for a not too big dictionary size and then debug this step by step to see where it goes wrong. For your luck, even for 1000 dict. entries, binary search should terminate after 10 recursions - the power of ld (logarithm dualis), you know? ;-)  Btw. did you ensure correct sorting? Did you ensure that sorting provides the exact same order as assumed in binary search? Yet another experience of mine: it's hard to find errors in code if you search at the wrong lines... ;-)  1 Answer 1  I made my own little sample. (Thereby, I re-designed the code a little bit as I felt unlucky about how the OP did.)  Every length from 1 to size of is tested. For each length, any entry of is searched.  Every length from 1 to size of is tested. For each length, the empty string is tested (before any other entry) as well as any entry with a modification. (The modification grants that it would be between unmodified entry and its successor or after any entry for the last.)  Output:  Everything went well.  Then I replaced  with  to resemble what is (in my feeling) wrong with OP's code.  Well. Actually, this doesn't prove anything concerning the code of OP.  However, this shows  that "off by 1" can break binary search essentially.  how a brute force test can be designed to uncover such errors.  So, this will hopefully help the OP to find the error in his algorithm on his own (which is actually even more valuable for him).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  