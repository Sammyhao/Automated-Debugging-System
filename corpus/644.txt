 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  My app crashes (repeatably) after I have moved from VS2005 to VS2008 (win32).  If I step in the debugger, I get:  Firstly, I see that the class object at the crash line, has a NULL _vptr. But some other objects of the same class have non-NULL _vprt :)  Secondly, if I change the order of the member object declarations, the crash moves to some other line.  So I guess this must be a corrupt heap problem.  Do you agree? if yes, could the number of allocations in the stack such as "char buffer[8192]" be a problem?  I have tried purify, application verifier without luck. My app is a plugin (dll) living in a proprietary application. I can only attach with a debugger.  2,28455 gold badges3131 silver badges4545 bronze badges  1  Do you link to C++ libraries that you don't control ? If they're compiled for VS2005, they will likely work incorrectly in VS2008.  3 Answers 3  Do you agree? if yes, could the number of allocations in the stack such as be a problem?  Yes, Heap corruption can be caused by an array of huge sizes allocated on Heap(by using new or malloc). If you are creating an huge sized array on Stack, If the adjacent memory is allocated to another object, the program will overwrite that object's data, resulting in crashes. So both might be hazardous but due to different problems. If you are talking about an stack array, No it cannot cause heap corruption simply because stack or heap(rather free store in C++) are two different memory entities.  Heap corruptions can be very frustrating and difficult to diagnose. And there are not definite steps to solve such a problem though there are number of methods which one can try to debug such errors.  @Als, assume I'm dumb for a moment, but what do large stack allocations () have to do with heap corruption?  If the damaged object is allocated on the stack, the issue is not a heap corruption but a stack corruption. If the object is allocated on the heap, stack allocations can't damage it. It's unclear from the question what's the case, but since Paul asks about heap corruption, I don't think on the stack would matter.  @Als: You realize that the penalty for running out of stack space is not randomly trashing heap, it's an access violation at the affected address (not ). I'd almost say that it's impossible for this to corrupt heap, and even if it did, your process is going down anyway, so it wouldn't matter.  This definitively looks like a heap corruption - at some point, your code write zeros on the top of the object, and that kills the vptr. The reason it happens after moving from VS2005 to VS2008 is probably because the heap layout has somewhat changed. The bug was probably in VS2005 as well, but its damage was unnoticed.  Using the tools you mention usually solves such problems. What kind of no luck have you had when using them?  Since you say your app repeatedly crashes in the same way, you can add checks in your code. Continuously verify the damaged object (make sure its beginning wasn't zeroed), and break when you observe a damage. Looking at the activity between the latest successful validation and the break would help you focus. Just have in mind that any change in heap usage might hide the problem, namely corrupt some other location.  This turned out to be an issue related to preprocessor defines being different between my app and some of its dependencies (libs).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  