 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Problem 1: Given the array [ 22 | 25 | 71 | 24 | 18 | 5 | 27 | 32 | 104 | 8 | 23 | 66 ] Build a max-heap for the array. Show all steps without skipping any details.  This is my understanding about the max-heap from researching on the internet:  The max heap is an array that could be more easily represented with a binary tree where the parent node is always greater than it's children and "every time you add a child you added it towards the left so that every time the tree increases it's height it is a full tree"  I thought that was the right answer until I read question 2 of my homework that say:  Problem 2: Using the same array as in problem 1, sort the array using Heapsort. Show all steps without skipping any details.  Now I am confused. Maybe I answered problem number 2...  1 Answer 1  You're building the tree but you're not adjusting your array. The array reflects the heap structure. The first element being the largest element in the array and the following two elements are the left and right child of that one.  The idea is after you build the heap that you swap the last and the first element in the array and then work on the same array but only using the elements 0 ... array.size - 2. The heap-condition is invalid and you call heapify to get a correct heap structure on the smaller array. This gives you again the largest element in that smaller array at the first position. You swap the first and last element in the smaller array and build the heap on the array which has 2 elements less. But you have two elements at the end which are sorted (the biggest element from the whole array and the next biggest element (which is the biggest element from the first smaller array)). You'll do this until you'll have an rest array which has no elements left.  Take a look at Heap Sort diagram in the german wikipedia. First you'll see the unsorted array. The smaller black box indicates the position in the array. The first tree is a heap.  The invariant is that your tree is a heap before and after each iteration. That's why it works. Because you'll swap always the largest element to the end of the heapified array.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  