 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Within the following you will see a data structure, which is quite similar to a simplified version of a feature model (for them have a look here) and is some version of a tree. I've implemented the data structure in Java and now I'm tryin to analyze it. In specific I want to get all combinations of elements which are possible if a specific feature model was given.  Let's assume we have the following feature model:  The elements are the boxes. The circles which are not filled stand for optional elements (remember the o for Optional), the filled ones for mandatory. The root element has to be included. Because of these rules the following combinations or lists of elements are possible:  [1,3,5,6]  [1,2,3,5,6]  [1,3,4,5,6,7]  [1,2,3,4,5,6,7]  Now, I want to get them not via visual searching, but via a Java program. For that I've implemented several classes:  stores the whole feature model (graphic).  is one of the rectangles.  describes the lines and circles.  holds one possible combination (list of combinations).  Within the class I've implemented a function to get all combinations called :  Explanation of the algorithm: It's called with an list of combinations of one element, which is an empty list. The function is called on the root element . It adds with the first for loop the to the combinations (it uses a DFS to go through the tree). Secondly, the method calls itself starting from element , passing the original list (containing ). From there it returns a configuration consisting of element and . The returned list is treated depending on the type of the edge (mandatory or optional and added accordingly to the original list). In that specific case the list should consist of two combinations and . When sub-tree under the first edge (in that case only element ) is finished, the next sub-tree (,,) is processed.  The following is not important anymore, please have a look under the horizontal bar.  But at the moment I'm confused with the recursion, because when I call this the returned list of is empty. I believe that this is connected to the way of treating the leafs. Because these are not treated properly at the moment (see bold text above). Does someone has an idea? Of course, I'll try to explain the problem in more detail if necessary and thanks for the thoughts you put in this question.  Specification to the original question: Let's assume the algorithm works in general (I've checked it several times). So I guess my understanding of Java is incorrect in some part of the program. Two thinks might be interesting:  After I turned on all compiler warnings (thanks Prune) one is left, and it's showing for the line . Might this be a problem?  Is it possible that the variable which is always passed to the function is changed within the second/third/... recursive call directly instead of after return?  At the moment the output produced by the program returns the following combinations (which is obviously not right):  53111 gold badge77 silver badges1919 bronze badges  5  Please read and follow the posting guidelines in the help documentation. Minimal, complete, verifiable example applies here. We cannot effectively help you until you post your MCVE code and accurately describe the problem. We should be able to post your given code into a file, run that file, and reproduce the problem.  @Prune: I'm aware about the guidelines MCVE. Moreover, I was trying to debug the code as described in the blog post. Nevertheless, the question is asking for help with designing the algorithm and not about fixing a programming error. The result of execution is not as wished and I'm stuck with it. I've added a explanation of the algorithm and marked the problem more specific. Thanks for the feedback.  So a node marked as mandatory is not really mandatory, but if you include its parent, then you have to include the node too.  2 Answers 2  I think your logic of adding the node to each combination in the list at the beginning is wrong, it should be done afterwards.  The correct algorithm could look like this:  Call your recursive function with the root node. Return a list of combinations.  If it is a leaf node, return a list of combinations with only that node inside.  For each edge: call the recursive function with the child node and save the results.  Create all possible combinations of the mandatory children. E.g. with two mandatory children, one has 11 combinations, the other has 7, you get 11 * 7 = 77 combinations. You basically build the cross product of all mandatory combinations, this is the simpler step. If the node has no mandatory children then it is a list of combinations with one empty combination inside (to which the current node will be added later).  Combine with the combinations of the optional children. E.g. with two additional optional children with 3 and 5 combinations, you get 77 + 77 * 3 + 77 * 5 + 77 * 3 * 5 = 1848 combinations. Here you have the possibility to chose whether you take an optional branch or not and therefore it is exploding pretty quickly, with 3 branches a, b, c and x mandatory combinations, you get x + ax + bx + cx + abx + acx + bcx + abcx (all combinations of taking and not taking a, b or c).  Add the node the function was called with to each combination and return the result.  Because I was not able to explain the problem clearly you were not able to post the solution. Now I will post the solution. Firstly, spoiling of the surprise: The algorithm was correct as I understood it, but the same variable was changed during the whole recursion process. Because of that also the same combination was produced four times.  The solution is to use the method and therefore change to .  53111 gold badge77 silver badges1919 bronze badges  2  In practice, there is only one real life case for -- when you perform many insertions/deletions in the middle of a huge list. In other sutuations, prefer . To make a copy, use instead of , as the latter is very rarely used today and poorly supported in custom implementations.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  