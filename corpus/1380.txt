 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  In this code below I try to access the '-1'th element of an array, I don't get any runtime error.  When I run the code, it outputs that means it is adding 12 to the non-existent A[-1]. Till today whenever I had tried to access an out-of-bounds element, I had got a runtime-error. I had never tried it on a simple code before.  Can anyone explain why does my code run successfully?  I ran it on my computer and also on ideone, in both the cases it ran successfully.  1,13733 gold badges1212 silver badges3131 bronze badges  4  Undefined behaviour. You could if was a pointer to not the first element, though, but that's more of a negative index thing than an out of bounds thing.  @A.06: Yes. "Undefined behavior" includes "it ran successfully". Undefined behavior also includes "horribly crashing" and "unicorns fly out from your computer screen". It literally means you can't reason about its behavior with any kind of reliability, which is why UB is exactly what you don't want to do.  3 Answers 3  You see, when you allocate a variable like this, it lands on the stack. Stack holds small packages of information about local variables in each function you call, to say it in simple words. The runtime is able to check, whether you exceed the bounds of allocated stack, but not if you write some data in the invalid place on the stack. The stack may look like the following:  [4 bytes - some ptr][4 bytes - A's first element][4 bytes - A's second element] ...  When you try to assign to -1th element of an array, you actually attempt to read four bytes preceding the array (four bytes, because it's an int array). You overwrite some data held on stack - but that's still in valid process's memory, so there are no complaints from the system.  Try running this code in release mode in Visual Studio:  Edit: in response to comments.  I missed the fact, that A is global. It won't be held in stack, but instead (mostly probably) in .data segment of the binary module, however the rest of explanation stands: A[-1] is still within process's memory, so assignment won't raise AV. However, such assignment will overwrite something, that is before A (possibly a pointer or other part of the binary module) resulting in undefined behavior.  Note, that my example may work and may not, depending on compiler (or compiler mode). For example, in debug mode the program returns 0 - I guess, that memory manager inserts some sentry data between stack frames to catch errors like buffer over/underrun.  23.7k1414 gold badges8383 silver badges151151 bronze badges  3  3  Except the definiton (in the OP's code) is outside the body of any function so i doubt is created on the stack in that case :)  Ah, you're correct. However I guess, that it's still a matter of writing inside process's memory, what makes this code not to crash.  @Spook, It's a reasonable explanation. Just don't count on that being the reason. It could just be the compiler being in a tricky mood :)  C and C++ does not have any bounds checking. It is a part of the language. It is to enable the language to execute faster.  If you want bounds checking use another language that has it. Java perhaps?  @A.06, It still exists in memory, but trying to speculate on what undefined behaviour does is pretty pointless.  @chris But i have got runtime error for accessing out of bounds element before in C/C++.  In C++ (and C), the arrays don't check out of range indices. They're not classes.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  