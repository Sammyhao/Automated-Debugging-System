 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am having a huge problem with this. I don't have any idea how to make Huffman tree since it is being built bottom-up (from the liefs to the root).  I am new to Haskell and functional programming. I have seen there are other posts similar to mine, but they did not help me.  This is my code  I am thinking about this data structure for Huffman tree  but i have no idea how to make Huffman tree from min heap.  After this line of code in ghci min heap is made from input string  In Huffman tree You will still need frequency of characters to properly group together the leafs. And I don't know why leaf would need to store a list of Chars. The data structure has to look differently.  1 Answer 1  You need to make a Huffman Tree with a min heap, and you said "I have no idea how to make Huffman Tree from min heap". Let's figure out what you need to do before you start coding, especially in a language that you might not be familiar with.  The simplest construction algorithm uses a priority queue where the node with lowest probability is given highest priority:  Create a leaf node for each symbol and add it to the priority queue.  While there is more than one node in the queue:  Remove the two nodes of highest priority (lowest probability) from the queue  Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.  Add the new node to the queue.  The remaining node is the root node and the tree is complete.  You already have code in place to find the frequency of each symbol in a given string - that's your function.  All you need now is a priority queue! You can definitely find a way to implement a priority queue using a min heap.  I hope this helps you piece the logic together.  If you want to deal with the problem step-by-step, why don't you start by trying to make a Huffman Tree using a working implementation of a priority queue (http://hackage.haskell.org/package/PSQueue)?  Once you're done with that, you can try to replace this readymade module with a small queue module of your own using a working implementation of a min heap (http://hackage.haskell.org/package/heap).  Finally, you can write a barebones min heap module by yourself (you have a lot of the code already) and replace the external heap module with that.  Update: Some more concrete suggestions on how to build the tree. This requires a little setup, so please bear with me. Suppose you have a module that allows you to work with binary trees:  and you also have a module which lets you work with priority queues (I'm assuming you have a working min-heap module)  Then this is how you might try to make a module using the tools at your disposal.  Since the types check out, I successfully compiled a stack project with these modules. When you think you have the Huffman Tree-building code you want, you can just fill in the functions with what they're actually supposed to do and you're good!  First of all, thank you for answering. I thought this is over, since i posted question 3 days ago. All of the things you have said in the post i already know. I have implemented my min heap (that's how i learn, first i implement my functions and after i use dose from some modules or whatever). The thing is that i dont know how to make tree from leafs to the root. 1. Create a leaf node for each symbol and add it to the priority queue. And where should i store those leafs? In some list or what? In c and python i have done this task successfully, but in haskell... Much more complica  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  