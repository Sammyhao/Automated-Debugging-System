 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Let's say you wanted to implement a breadth-first search of a binary tree recursively. How would you go about it?  Is it possible using only the call-stack as auxiliary storage?  6,23988 gold badges2727 silver badges2121 bronze badges  4  16  very good question. this is not straightforward at all. basically you're asking to implement a BFS using only a stack.  If i use BFS on a Max heap , i wonder if solutions given below work properly ? Any thoughts ?  22 Answers 22  (I'm assuming that this is just some kind of thought exercise, or even a trick homework/interview question, but I suppose I could imagine some bizarre scenario where you're not allowed any heap space for some reason [some really bad custom memory manager? some bizarre runtime/OS issues?] while you still have access to the stack...)  Breadth-first traversal traditionally uses a queue, not a stack. The nature of a queue and a stack are pretty much opposite, so trying to use the call stack (which is a stack, hence the name) as the auxiliary storage (a queue) is pretty much doomed to failure, unless you're doing something stupidly ridiculous with the call stack that you shouldn't be.  On the same token, the nature of any non-tail recursion you try to implement is essentially adding a stack to the algorithm. This makes it no longer breadth first search on a binary tree, and thus the run-time and whatnot for traditional BFS no longer completely apply. Of course, you can always trivially turn any loop into a recursive call, but that's not any sort of meaningful recursion.  However, there are ways, as demonstrated by others, to implement something that follows the semantics of BFS at some cost. If the cost of comparison is expensive but node traversal is cheap, then as @Simon Buchan did, you can simply run an iterative depth-first search, only processing the leaves. This would mean no growing queue stored in the heap, just a local depth variable, and stacks being built up over and over on the call stack as the tree is traversed over and over again. And as @Patrick noted, a binary tree backed by an array is typically stored in breadth-first traversal order anyway, so a breadth-first search on that would be trivial, also without needing an auxiliary queue.  5,10622 gold badges2424 silver badges2828 bronze badges  4  11  This is indeed just a thought exercise. I can't really imagine a situation in which you'd actually want to do this. Thanks for the well thought out answer!  "but I suppose I could imagine some bizarre scenario where you're not allowed any heap space for some reason": dunno, I can imagine an embedded environment where only the stack (along with any read-only memory space) is available (it's actually quite easy and efficient to write software without using the heap at all if you know exactly what your program is going to do, which is usually the case in embedded software). So it's not that "bizarre" to me. Unusual, maybe, but not bizarre.  If the only constraint is to use "stacks" and "no queue" - Use two stacks to mimic a queue  If you use an array to back the binary tree, you can determine the next node algebraically. if is a node, then its children can be found at (for the left node) and (for the right node). A node's next neighbor is given by , unless is a power of  Here's pseudocode for a very naive implementation of breadth first search on an array backed binary search tree. This assumes a fixed size array and therefore a fixed depth tree. It will look at parentless nodes, and could create an unmanageably large stack.  Nice. I overlooked the fact that we are dealing with a binary tree. The indexes can be assigned using a DFS. BTW, you forgot a return false at the first case.  Clever. The idea of storing the nodes in an array and referencing them algebraically hadn't occurred to me.  I couldn't find a way to do it completely recursive (without any auxiliary data-structure). But if the queue Q is passed by reference, then you can have the following silly tail recursive function:  Completely disagree - I find it more natural - and also more useful; you can extend this method to pass down working state as you go through layers  The following method used a DFS algorithm to get all nodes in a particular depth - which is same as doing BFS for that level. If you find out depth of the tree and do this for all levels, the results will be same as a BFS.  Please pay a little bit more attention to your code formating. I did some changes.  But, hold on... is this a DFS rather than BFS? Because PrintLevelNodes does not return until is zero.  @HerringtonDarkholme, Correct. It does DFS search but the outputs values as if it did a BFS for a level. Thanks for pointing out that.  @Sanjay , this indeed is a good demonstration of how one might perform some action on nodes in DFS-order. It is not necessarily how one would actually "touch" nodes in DFS-order, but will certainly allow to recursively "act" on nodes in DFS order, in this case printing their values.  A simple BFS and DFS recursion in Java: Just push/offer the root node of the tree in the stack/queue and call these functions.  1,65411 gold badge1616 silver badges1717 bronze badges  1  5  It's a bit weird to pass stack as a parameter for DFS, because you already have implicit stack there. Also the question was to use only call stack as a data structure.  I found a very beautiful recursive (even functional) Breadth-First traversal related algorithm. Not my idea, but i think it should be mentioned in this topic.  +1 for the beautiful algorithm. However, I found it still using a queue. The left side of "Rule 3" itself is actually the dequeue and enqueue operations.  Idea of using return value as accumulator is well suited. Can be implemented in other languages in similar way, just make sure that your recursive function process list of nodes.  Here is a BFS recursive traversal Python implementation, working for a graph with no cycle.  I would like to add my cents to the top answer in that if the language supports something like generator, bfs can be done co-recursively.  To begin with, @Tanzelax's answer reads:  Breadth-first traversal traditionally uses a queue, not a stack. The nature of a queue and a stack are pretty much opposite, so trying to use the call stack (which is a stack, hence the name) as the auxiliary storage (a queue) is pretty much doomed to failure  Indeed, ordinary function call's stack won't behave like a normal stack. But generator function will suspend the execution of function so it gives us the chance to yield next level of nodes' children without delving into deeper descendants of the node.  The following code is recursive bfs in Python.  The intuition here is:  bfs first will return the root as first result  suppose we already have the bfs sequence, the next level of elements in bfs is the immediate children of previous node in the sequence  5,57111 gold badge2323 silver badges4141 bronze badges  1  I don't know Python but I think your code translates to this C# code. It does the BFS traversal but crashes with a stackoverflow exception. I haven't figured out the why so far. However, I modified the algorithm so that it stops (and performs better probably). You find my working sample here.  Here's a Scala 2.11.4 implementation of recursive BFS. I've sacrificed tail-call optimization for brevity, but the TCOd version is very similar. See also @snv's post.  The following seems pretty natural to me, using Haskell. Iterate recursively over levels of the tree (here I collect names into a big ordered string to show the path through the tree):  I had to implement a heap traversal which outputs in a BFS order. It isn't actually BFS but accomplishes the same task.  4,13644 gold badges2222 silver badges4747 bronze badges  1  2  For other viewers: this is an example of implementing a complete tree in an array; Specifically, @Justin is doing a pre-order traversal, during which he saves node values (in BFS order) in an array at the appropriate BFS index. This allows the calling function to iterate linearly through the array, printing values in the BFS order. See this general description Note: the calling function must handle the case of non-complete trees.  I think this might get stuck in an infinite loop -- the vertices are being marked as visited, but they are never tested for visited-ness before recursing again.  BFS for a binary (or n-ary) tree can be done recursively without queues as follows (here in Java):  An example traversal printing numbers 1-12 in ascending order:  Here is a JavaScript Implementation that fakes Breadth First Traversal with Depth First recursion. I'm storing the node values at each depth inside an array, inside of a hash. If a level already exists(we have a collision), so we just push to the array at that level. You could use an array instead of a JavaScript object as well since our levels are numeric and can serve as array indices. You can return nodes, values, convert to a Linked List, or whatever you want. I'm just returning values for the sake of simplicity.  Here is an example of actual Breadth First Traversal using an iterative approach.  Following is my code for completely recursive implementation of breadth-first-search of a bidirectional graph without using loop and queue.  If you want algorithm to work not only with binary-tree but with graphs what can have two and more nodes that points to same another node you must to avoid self-cycling by holding list of already visited nodes. Implementation may be looks like this.  I have made a program using c++ which is working in joint and disjoint graph too .  I think this can be done using pointers, without using any QUEUE.  Basically we are maintaining two pointers at any point, one is pointing to the parents, the other is pointing to the children to be processed ( linkedlist to all which have been processed )  Now you simply assign the pointer of the child & when parent processing finishes you just make the child to be parent for processing next level  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  