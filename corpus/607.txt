 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Your DFS w/o a stack is completely broken. You need the stack (or, alternatively, a queue – but let’s ignore that for now), there’s no way around it.  Most people use a binary tree to do an efficient insertion sort. Otherwise, they would use a collection. To print in sorted order, you should iterate left, print the node, then iterate right.  6 Answers 6  First rule: The first node in the tree is the leftmost node in the tree.  Next rule: The successor of a node is:  Next-R rule: If it has a right subtree, the leftmost node in the right subtree.  Next-U rule: Otherwise, traverse up the tree  If you make a right turn (i.e. this node was a left child), then that parent node is the successor  If you make a left turn (i.e. this node was a right child), continue going up.  If you can't go up anymore, then there's no successor  As you can see, for this to work, you need a parent node pointer.  Example:  First rule: The first node in the tree is the leftmost node in the tree:  Next-U rule: Since has no right subtree, we go up to . This is a right turn, so is next.  Next-R rule: Since has a right subtree, the leftmost node in that subtree is next: .  Next-U rule: Since has no right subtree, we go up to . This is a right turn, so next is .  Next-R rule: Since has a right subtree, the leftmost node in that subtree is next: .  Next-U rule: Since has no right subtree, we go up to . This is a left turn, so we continue going up to . This is a left turn, so we continue going up to . This is a right turn, so next is .  Next-R rule: Since has a right subtree, the leftmost node in that subtree is next: .  Next-R rule: Since has a right subtree, the leftmost node in that subtree is next: .  Next-U rule: Since has no right subtree, we go up to . This is a right turn, so next is .  Next-U rule: Since has no right subtree, we go up to . This is a left turn, so we continue going up to . This is a left turn, so we want to continue going up, but since has no parent, we've reached the end. has no successor.  Pseudocode  Java code  Here's a simple implementation of the above algorithm:  Can you change it to Iteration instead of a recursion?  You can, using an explicit stack. Pseudocode:  But this isn’t really superior to the recursive code (except for the missing base condition in your code).  498k122122 gold badges902902 silver badges11661166 bronze badges  9  3  "not superior": I agree. While its good to know that all recursive algorithms can be converted to iterative ones and how it is done, it often doesn't bring any significant advantages if it's actually done.  @ILMTitan: My code doesn’t preserve the order of traversal. You’re right that to do that, I need to invert the pushing order. Or in fact use a queue instead of a stack.  @JoachimSauer : -- thats observably wrong in every regard. Recursive algorithms are much slower by design in almost all languages and environments. They also use much more available space and can easily crash the application. Basic facts. The only advantage of recursive algorithms over iterative ones is the readability and ease of implementation ... some data structures require quite a bit of engineering to be traversed iteratively whereas they could be traversed much easier with recursion.  @specializt Basically every single thing you’ve said is wrong. You seem to equate replacing recursion with iteration with replacing a naïve algorithm by a more sophisticated one. This is sometimes the natural thing to do (calculating Fibonacci numbers being the typical example) but it’s not a necessary consequence. Iterative algorithms can be (memory/time) inefficient. Conversely, recursion can be efficient. For instance, a natural, recursive computation of Fibonacci numbers can be made as efficient as the canonical iterative version (running in O(n) time, using O(1) space).  If order of traversal is not important to you, go for breadth first, it's easier to implement for iteration. You're algorithm should look something like this.  As with every recursion, you can use additional data structure - i.e. the stack. A sketch of the solution:  22k1515 gold badges6464 silver badges9494 bronze badges  1  1  Hmmm... To preserve the same order of visiting? If you pushed the left one first and only then the right one, you would pop the right one first and then the left one. LIFO, right?  I had a tree (not binary) and eventually solved it with this very simple algorithm. The other solutions used left and right that were not relevant or even implemented in the examples.  My structure was: nodes with each parent containing list of children, and each child containing a pointer back to the parent. Pretty common...  After a bunch of refactoring, I came up with the following example using Kotlin. It should be trivial to convert to your language of choice.  Helper Functions  First, the node must provide 2 simple functions. This will vary depending on your Node class' implementation:  leftMost - This is the first child node. If that node has children, it's first child, etc. If no children, return this.  nextSibling - The next sibling of this node, or NULL  The Iteration  The iteration starts with the leftMost of the root.  Then inspect the next sibling.  If NOT NULL the sibling's leftMostChild  If NULL, the parent, and if the parent is NULL, we are done.  That's it.  Here is a Kotlin iterator function.  Here is the same next() function, but without the Kotlin shorthand for dealing with NULL values, for those that are not hip to the syntax.  Yes, you can change it to iteration instead of a recursion, but then it gets much more complicated, since you need to have some way to remember where to go back from the current node. In the recursive case, the Java call stack handles that, but in an iterative solution you need to build your own stack, or perhaps store back pointers in the nodes.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  