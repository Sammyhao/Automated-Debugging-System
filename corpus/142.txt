 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  17.4k5656 gold badges189189 silver badges308308 bronze badges  5  You can't do (or for that matter) on pointers. Pointer arithmetic only allows addition and subtraction. Why not work with indices instead?  @another.anon.coward: Binary search does not have to be implemented recursively, a loop will do just fine.  @BjörnPollex: Thanks! Duly Noted ... its been a while but that should not have been a reason for me to overlook the logic implemented here :\  5 Answers 5  You can't add (or shift, or divide) two pointers, but subtracting them gives an integral type (which you can add and divide), so you can write something like:  145k1515 gold badges172172 silver badges320320 bronze badges  2  With indexes, this approach also prevents overflows, so it should be preferred anyway.  @BjörnPollex Or you could use an unsigned type for indexing, and count on the modulo arithmetic giving you the correct value in the end. (Or you're using 64 bit integers, and you know your array can't be that big:-).) But in general, yes. This is the only correct way to determine the mid-point.  Adding pointers doesn't have any meaning. You are thinking of as , but it might not be so, and C doesn't automatically treat them as such. You could cast, but then it won't be standard.  You can subtract pointers that are in the same array. That returns an int. Also, you can add an int to pointer.  So,  would work. should be an , so you need to change the rest of your code to work with that. You have similar errors elsewhere. For example, the next line  didn't make sense even if mid was an int (*mid isn't allowed on int), but now mid points right at the element, so you want:  84.9k1414 gold badges128128 silver badges184184 bronze badges  1  Because you probably have a bug. use the debugger to figure out what is going on. If you want help, you need to post your new code.  You cannot add pointers. If you really insist on doing it the hard way (instead of using indexes), you should use std::distance and std::advance functions.  @friendzis: In your example you subtract pointers, but you don't add them. That is not possible.  @BjörnPollex: 1. it IS possible, though doesn't make sense. 2. It's just not straightforward - you have to explicitly tell the compiler to take integral values of pointers, i.e. in subtraction case it is done implicitly. Subtraction: a-b; addition: (int)a + (int)b  @friendzis: When you do this you are adding integers, not pointers. If you dereference a pointer that results from such an addition, I am pretty sure you get undefined behavior.  @BjörnPollex: well, but pointers ARE the very same integers. Their value is integer, that has size of your architecture e.g. 64bits/16Bytes. Pointer type denotes what RESIDES at memory location that has the same value as pointer's value. Therefore when you add pointers you get pretty much defined behavior. ` int arr[2] = {1, 2}; int ptr1 = arr; int *ptr2 = (int *)(1*sizeof(*arr)); int *ptr3 = (int)((int)ptr1 + (int)ptr2); printf("%d\n", *ptr3); // 2` This is pretty defined behavior. If you take two pointer pointing to actual data in your application, then it will  12.1k2828 gold badges103103 silver badges177177 bronze badges  2  one question @Avinash ,we are dividing (*p+*q) by 4?because sizeof(int) is 4 or why?thanks for help  Does this really work? Try it on or something similar. The calculation of is completely wrong; you can't use the values in the original array to create an index into the array, since they are unrelated.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  