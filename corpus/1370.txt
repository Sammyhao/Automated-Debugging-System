 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Is it possible to search a element with binary search in sorted linked list? If it is not possible then the question is "why it is not possible"?  You can do a binary search, but it is cumbersome. (You have to access the mid points by walking the list, which is...pretty silly.)  @William Pursell: It's not silly at all, it just depends on the relative costs of iteration and comparison. Imagine a linked list of external 10 GB files.  @doynax hit the nail on the head here. Binary search is possible and may even be useful depending on your application. For a doubly linked list, binary search takes O(n) traversal steps and O(lg n) comparisons. In contrast, linear search takes O(n) traversal steps and O(n) comparisons. Interestingly, you can show that the # of traversal steps required for binary search is always >= # of traversal steps required for linear search.  3 Answers 3  Binary search on a sorted array gives us the result in O(log N) comparisons and O(1) memory utilization. Linear search on a sorted array gives us the result in O(N) comparisons and O(1) memory utilization.  Beyond the normal memory and comparison measurements, we also have the idea of traversal steps. This is important for data structures with no random access. For example, in a linked list, to get to element j from the head, we would need to take j steps forward. These steps can happen without any comparison. As pointed out in the comments, the cost for making a traversal step may be different from the cost for making a comparison. A traversal step here translates to a memory read.  The question is what happens when our data structure is a sorted singly linked list? Is it worth doing binary search?  To address this, we need to look at the performance of binary search on a sorted singly linked list. The code looks like this:  The function binarySearch returns the node with element equal to or just greater than v. The parameter n is the head node in a sorted singly linked list.  It is clear that the outer loop iterates O(log N) times where N = size of the list. For each iteration, we make 2 comparisons, so the total # of comparisons is O(log N).  The number of traversal steps is the number of times right = right->next; gets executed, which is O(N). This is because the # of iterations in the inner loop decreases by half at each iteration of the outer loop, so N/2 + N/4 + ... + 1 = N (plus or minus some wiggle room).  Memory usage is still O(1).  In contrast, linear search through a sorted singly linked list is O(n) traversal steps, O(n) comparisons, and O(1) memory.  So is it worth doing binary search on a singly linked list? The answer is almost always yes, but not quite.  Disregarding the cost to count, what happens if the element we are looking for is the 2nd element in the list? Linear search takes 1 step and 1 comparison. Binary search takes ~ N steps and ~log N comparisons. Reality isn't so clear.  So here's the summary:  Sorted Array  Although, technically, the # of required traversal steps is 0 for sorted arrays. We never have to step forward or backwards. The idea doesn't even make sense.  Sorted Singly Linked List  And these are worst case run time. However, the glass may not always be half empty :p  @dfeuer, well it actually depends on your specific use case. You can imagine a scenario where the entire list fits into cache. In this case traversal is fast. On the other hand, comparisons are bad because branching can cause misprediction (and flushing of pipeline and instruction cache) and other penalties. So in this scenario, you would definitely want to do binary.  Arrays have traversal steps too, it's just that the mechanism is simpler - adding or subtracting from a pointer or index, rather than dereferencing a pointer. Order analysis doesn't get into the cost of individual operations, just their count.  @MarkRansom, array traversal doesn't require touching any data. I suppose you're right that there is something there, which is why I included those numbers. However, +1, +n can all happen in less than a clock cycle on most modern processors. That is not the case with list traversal. In terms of O(1), the actual constant here is >>>>>> in one case versus the other.  A linked list only allows sequential access, so binary search is impossible even if the list is sorted.  Edit: As others have pointed out, binary search is possible, but would be pointless.  We can emulate random access in a linked list, but that would be slow and has a time complexity of O(n) on average, so a binary search(which is normally O(lgn)) will take O(nlgn).  Edit 2: as @ethang pointed out, if it's a doubly linked list, the binary search can take only O(n). In each step, we can start from the previous position instead of from the head/tail, so the distance moved will half each time.  If you must use a linked list, you'd better using a linear search, whose complexity is only O(n), and is simpler than a binary search.  If you want to both search and insert/remove effectively, you may use other data strictures such as a binary search tree.  1,59244 gold badges1515 silver badges2020 bronze badges  4  Not impossible (you can simply emulate random access with sequential access), just slow.  – user395760  Mar 3 '15 at 15:58  1  Actually it wouldn't be O(n log n). It would be O(n) traversal steps and O(log n) comparisons. As a matter of fact, it is has an upper bound of n (+/- 1 or 2). This is assuming doubly linked list.  Note that by comparison, linear search would be O(n) traversal steps and O(n) comparisons. However, it is simpler, and the average constant on the O(n) traversal steps would probably be smaller (although someone should work out the math here).  Even with singly linked list, it would also be O(n) traversal steps. To get O(n) requires some book keeping, but it should be possible.  ethang shows how to perform binary search in a singly linked list with just O(1) extra space, O(n) traversal time, and O(log n) comparisons. I did not previously believe that this was possible. For fun, I figured I'd implement a similar algorithm in Haskell:  This can be adjusted to use O(log i) comparisons and O(i) traversal time, where i is the distance from the beginning of the list to the location where the sought key is or would be. This implementation could be improved, but the gist is quite simple—replace the above with this version:  46.5k44 gold badges5858 silver badges160160 bronze badges  10  +1 for Haskell just as for your old answer :-) I do wonder though whether it wouldn't be more efficient if we'd use extra space to store the heads of the s we'd came by already, so we would need to do only traversal steps instead of . What do you think?  @Bergi, I thought about your comment all through my shower, but I couldn't figure out which heads you were talking about (aside from the fact that they must surely have been heads of s rather than s).  Yeah, I mean the "middles" which you named in the code. In case we go left (multiple times), is called multiple times on the same list, doing unnecessary traversals over the same nodes again. If we could build a list from the heads of these "middle nodes" in the leftmost branch while traversing until , we could save some other node traversals. I guess if we limit the length of that list we could still take constant space but avoid lots of traversals.  @Bergi, if we save all of them, that's O(n) extra. I guess you could find a way to choose just log n of them, but I'm not sure how to decide which.  Note that as it is in the worst case scenario, you'd make n traversal steps, not 2n. There is really no way to make this any better. Even if you use up O(n) in space. Suppose the element you want to find is the last element. There is no way to get to it without touching every other elements.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  