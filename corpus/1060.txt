 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I will graduate this summer with a CS degree and not once have I had a professor stress the importance of a Stack. I have, however, had multiple projects that were all focused on the use of recursion. I found recursion useful and exciting and I use it a lot in my personal projects.  I recently went to a job interview and the interviewers were very disappointed in recursive solutions to their problems. They wanted Stack solutions. I did a bunch of research but I'm still not sure when to use which.  Given the following demonstration:  Both solutions complete in around 200 ms. Changing the value of by adding a zero: gives me a StackOverflowError (on the recursive method).  When I comment out the recursive solution with the SAME value of the program runs successfully, meaning the Stack solution works far beyond the limits of the recursive solution.  Questions  Why is the recursive solution yielding a StackOverflowError with the same number of iterations as the Stack solution, but the Stack solution does not error out?  When would you use a recursive solution if the Stack solution is more capable and uses less memory?  What are the fundamental differences between Recursion and Stacks/iterative solutions that one must consider before choosing one over the other?  3,1421010 gold badges4040 silver badges6161 bronze badges  5  3  Recursion often provides a clean "mathematical" description of an algorithm. Pragmatically, however, use of recursion in Java can cause unknown (and large) memory usage that may be more efficient when you control the information directly (e.g. in a "stack" solution).  Java does not have tail call optimization so recursion eats stack space which is limited. The stack solution uses heap space.  I wish you could elaborate more on the nature of your stack oriented solutions, or what was the problem posed? Are those stack solutions just equivalent in nature to / simulate what happens on the function call stack of a recursive solution or do they something different?  @mvw The problem posed was in relation to a tree structure, generating a tree from a string. Given a(bcd(efg)) create a tree without using recursion. My personal run-in with the issue came from solving the Robot Movements challenge on CodeEval. I used recursion there, but I've decided to try to find a non-recursive solution using several stacks and see which is more efficient.  5 Answers 5  Why is the recursive solution yielding a StackOverflowError with the same number of iterations as the Stack solution, but the Stack solution does not error out?  Recursion uses you thread stack and that has a much lower limit. The STack uses the heap and this is much larger but it will OutOfMemoryError eventually.  When would you use a recursive solution if the Stack solution is more capable and uses less memory?  It is much slower, harder to write, more error prone and uses more memory. It is just that the limit is much higher.  I see many people using recursion over Stacks, is this because recursion is "easier" although far less efficient? (3 lines of code vs. the 7 in this example).  You haven't warmed up the code to say which is more efficient. I would ignore the first 10,000 iterations or the first second of running time.  While I know you cannot say why everybody else uses recursion,  Usually recursion is less efficient than using iteration, however some problems cannot be easily refactored to use recursion. 95% of problems are much more efficient using iteration in Java.  I'd like to question it's use rather than use it because "everybody else does" if there's not a good reason for it.  Most of the time people use recursion because it is simpler, faster, but it can run out of stack space, and in very rare cases you have to use a Stack or an ArrayList which is more efficient than a Stack.  508k7373 gold badges718718 silver badges10951095 bronze badges  6  1  Here is a specific example where the author describes some of the difficulties he faced in a recursive vs. iterative approach to a simple algorithm: blog.andreloker.de/post/2009/03/10/…  @JasonC +1 Any kind of tree or graph is easier to work with recursion however it is fairly rare to write your own code to navigate nodes when there is Trees and SkipLists are built into the JDK. It is even rarer that you have a graph which is so deep it exhausts your stack.  @mvw true, but when you use a TreeMap or ConcurrentSkipListMap, you typically use iteration rather than recursion and for many developers these are the only sort of trees they use.  @leigero recursion works well when the depth is order of the problem space eg. for a balanced tree the depth you need is the log of the number of elements so it never gets out of hand. For graphs, you get a similar relationship. If your depth is order you have a scalability problem as you have found.  Recursion provides easy to read simple solutions for many problems, however it has issues related to function stack size limitation as pointed by others.  My personal theory on this is that if your recursion depth is O(log n) , you are OK using recursion.  To put things in perspective inorder traversal of balanced binary tree is +/- O(log n) recursion depth (Although this can be easily done with a stack, I am using it for example here)  But if your recursion depth can not be constrained in O(log n), there are very good chances of running out function stack space. If you are trying to write a program to flood fill you can not use recursion.  Most machine architectures use a fixed size stack, so your recursive algorithm has a limited amount of memory in which to work. The explicit stack you allocate, however, can grow to the size of main memory; it therefore has much more space to work with. Combine that with the fact that the recursive stack must contain much more data per frame then your explicit stack, and you can see why stack implementations are more efficient.  Recursive algorithms often seem more elegant; but stack-based algorithms are often a better choice for these reasons. Only when the number of levels of recursion is tightly bounded should a recursive algorithm be considered.  One thing should be kept in mind: From the viewpoint of math and information technology recursion and iteration are equivalent.  Why is the recursive solution yielding a StackOverflowError with the same number of iterations as the Stack solution, but the Stack solution does not error out?  Because recursion uses more memory than using a stack? Where does it say they should both fail at the same number of iterations?  When would you use a recursive solution if the Stack solution is more capable and uses less memory?  First, show me a case where 'the Stack solution is more capable'. This is not a meaningful question. Neither is your third. The recursive version of many algorithms is considerably easier to (a) write and (b) understand. Consider the shunting-yard algorithm versus a recursive descent expression parser for example.  It's not simply that it uses "more memory"; it uses a different and more limited area of memory. Recursion doesn't necessarily have to use more memory, either (consider e.g. a depth first traversal of a large tree, where a stack approach consumes memory for pending nodes, while a recursive approach does not).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  