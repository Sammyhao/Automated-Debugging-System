 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm struggling with this problem, which I want to solve in non-recursive way. There seems no logic error in my algorithm, 73% test cases passed. But it can't handle the big data, reported "Time Limit Exceeded". I appreciate if somebody could give me some hint how to do it in non-recursive and avoid time limit exceed, thanks in advance!  Given a binary tree, find the maximum path sum from root. The path may end at any node in the tree and contain at least one node in it.  @sudomakeinstall2: Recursion is problematic in the real world. It usually consumes unpredictable amounts of stack memory, which is generally fairly limited. As the old saying goes: The only problem with recursion is recursion.  3 Answers 3  I guess that the problem with your code is that when you are traversing your tree, in each node you are iterating to calculate the maximum path. This ends up with a complexity of . You need to calculate the maximum path on the flow (while traversing the tree).  In the solution below I used the post-order iterative algorithm from here. Please forgive me that I used this one instead of yours.  The solution () is simply to add a field to each node, and when visiting the actual node take the maximum between and :  3,81622 gold badges2626 silver badges5050 bronze badges  1  1  I think you're right, it's better to add a field and compare but not to change the real value of the node. Now time complexity is linear :)  From the top down, update each node by adding its parent's value to it. Keep track of your max value and its position. Return that at the end. O(n).  E.g., if your binary tree is T=[-4,2,6,-5,2,1,5], then we update it as: [-4, 2-4=-2, 6-4=2, -2-5 = -7, -2+2=4, 2+3=3, 2+5=7]  you won't need findPathMaxSum function. I also changed the parent map. Now it stores 2 values:  pointer to parent  path sum from root to the current node.  Here is the code.  OLD:  You want to pass the map by reference not by value in findPathMaxSum.  change it to.  It makes your time complexity O(n*n).  Its running complexity will become O(n*log n). Although it did not work out as your constraints are tighter. So I posted a O(n) solution above.  No, it doesn't change anything... and pass by reference won't effect the time complexity.  please post the link to the problem. passing by reference always does the job generally.  "passing by reference always does the job" - Blanket statements like these are easily invalidated, with a single counter example. Make sure your statements don't turn wrong when trying to simplify them.  I edit my post and add the problem link, and I also take your advice to pass by reference but still Time Limit Exceeded.  @IInspectable, I apologize for the statement. I will be careful with my words from the next time. Thanks  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  