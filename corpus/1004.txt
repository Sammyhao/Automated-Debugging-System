 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  To begin with, this question is not a dup of this one, but builds on it.  Taking the tree in that question as an example,  How would you modify your program to print it so,  rather than the general  I'm basically looking for intuitions on the most efficient way to do it - I've got a method involving appending the result to a list, and then looping through it. A more efficient way might be to store the last element in each level as it is popped, and print out a new line afterward.  7,14299 gold badges4040 silver badges5353 bronze badges  4  depend whether you did too much or to little. too much, remove the / and \ of too little, use arrayindex to know depth  @larsOn Ok, I understand the "remove every second line" comment now. But the first block is only an intuitive representation of the tree as it exists in memory. The third block shows what viksit already knows an algorithm for, and the second block what he would like to obtain instead.  16 Answers 16  Edit: if you're keen to get a small saving in maximum consumed "auxiliary" memory (never having simultaneously all this level and the next level in such "auxiliary" memory), you can of course use instead of , and consume the current level as you go (via ) instead of simply looping. The idea of creating one level at a time (as you consume --or iterate on-- the previous one) remains intact -- when you do need to distinguish levels, it's just more direct than using a single big deque plus auxiliary information (such as depth, or number of nodes remaining in a given level).  However, a list that is only appended to (and looped on, rather than "consumed") is quite a bit more efficient than a deque (and if you're after C++ solutions, quite similarly, a std::vector using just for building it, and a loop for then using it, is more efficient than a std::deque). Since all the producing happens first, then all the iteration (or consuming), an interesting alternative if memory is tightly constrained might be to use a list anyway to represent each level, then it before you start consuming it (with calls) -- I don't have large trees around to check by measurement, but I suspect that this approach would still be faster (and actually less memory-consuming) than (assuming that the underlying implementation of list [[or std::vector]] actually does recycle memory after a few calls to [[or ]] -- and with the same assumption for deque, of course;-).  793k160160 gold badges11861186 silver badges13631363 bronze badges  3  3  +1 I can see how using two s for the two levels could be more efficient than using a single . Especially if is moved outside the -loop and cleared instead of allocating a new one on the stack for each level (this is the C++ version I'm talking about, I've no idea how memory is managed in Python). This would also allow for very good cache utilization.  Yes, in C++ you'd definitely want to the vectors (and clear out the new one -- with the old one's contents -- right after that, if you're looping on it rather than using ). In Python you could do , then if needed , with similar effect (though I'm not sure the actual performance improvement would be measurable, it sure can't hurt;-).  @Alex - thanks for a great answer. The note on the iteration vs consumption of lists was quite informative!  Breadth-first traversal is implemented with a queue. Here, simply insert in the queue a special token that indicate that a newline must be printed. Each time the token is found, print a newline and re-insert the token in the queue (at the end -- that's the definition of a queue).  Start the algorithm with a queue containing the root followed by the special newline token.  76.7k77 gold badges150150 silver badges269269 bronze badges  6  Yes, I mentioned the BFS part in the title :) I was thinking about the newline in the queue as well, but it seems wrong to intersperse formatting tokens within the queue itself.  @Viksit Would it be more acceptible to store the depth of each node in the queue? In that case you could simply print a newline each time the current traversal depth is increased.  Ah, yes, "BFS"... I see what this three-letter acronym means now. Is the "S" for search? Isn't "search" always depth-first (or you built your binary tree wrong in the first place)?  @Andreas Nice! I was a little reluctant to mix special tokens and nodes in the queue too (but you have to do what you have to do...)  @Pascal I actually thought a little more and came up with a version that didn't require any extra storage whatsoever :)  My solution is similar to Alex Martelli's, but I separate traversal of the data structure from processing the data structure. I put the meat of the code into iterLayers to keep printByLayer short and sweet.  This is breadth first search, so you can use a queue and recursively do this in a simple and compact way ...  This does BFS traversal but without level distinction (no newline at the end of each level)  why not keep sentinal in queue and check when all the nodes in current level are processed.  A simple Version based on Bread First Search, This code is applicable for graphs in general and can be used for binary trees as well.  Another version based on Recursion, which is specific to binary tree  Here my code prints the tree level by level as well as upside down  Here in my code the function BFS prints the tree level by level, which also fills the data in an int array for printing the tree upside down. (note there is a bit of swapping is used while printing the tree upside down which helps to achieve our goal). If the swapping is not performed then for a tree like  o/p will be  but the o/p has to be  this the reason why swapping part was needed in that array.  For those who are simply interested in visualizing binary trees (and not so much in the theory behind breadth-first search), there is a function in the binarytree package. Applied to the example given in the question,  This is mostly the same code as provided by Alex Martelli except this is modified for python 3.  I think what you expecting is to print the nodes at each level either separated by a space or a comma and the levels be separated by a new line. This is how I would code up the algorithm. We know that when we do a breadth-first search on a graph or tree and insert the nodes in a queue, all nodes in the queue coming out will be either at the same level as the one previous or a new level which is parent level + 1 and nothing else.  So when you are at a level keep printing out the node values and as soon as you find that the level of the node increases by 1, then you insert a new line before starting to print all the nodes at that level.  This is my code which does not use much memory and only the queue is needed for everything.  Assuming the tree starts from the root.  At the end all you need is the queue for all the processing.  Here is a Python gist which prints the tree by level. The idea behind it is to use BFS and keep a level marker integer which marks the end the last node of the level. This is similar to Naresh's sentinel approach, but without the need of inserting a sentinel inside the queue, since this is accomplished by the level marker.  This algorithm has a space complexity of O(2tree_height)  Which prints something like:  If you want to use a separator, it would look like:  In BASH, you can easily implement BT / BST without using any hash arrays/map, etc by simply creating/maintaining nodes in a .txt file.  Here's my crack at it. 2 small functions and , will do. Script can print any level node info from any given user specified root node.  48.5k1414 gold badges8181 silver badges112112 bronze badges  2  @Andreas - nice! I was looking at a version of this algorithm where I would store the "level" or "depth" of where the loop was (so, this tree would have 3 levels). The problem I faced was how to increment this level each time. Looks like your approach of storing the depth of each element works better.  @Viksit If you look closer I only stores two extra integers, one for how many nodes are left to process in the current level and one for how many nodes are left to process in the next level (Or was this what you meant?)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  