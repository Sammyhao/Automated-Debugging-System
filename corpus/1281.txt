 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I get that when you pass a variable into a method, Java creates a shadow copy of it so you can't modify the original variable, but this is exactly what is confusing me.  Below are two somewhat similar algorithms to which I initially pass in a root Node-- the first one works but the second one doesn't.  First  Ouput:  Second (doesn't work)  Output:  I wrote the first one myself and got the second one from Wikipedia. Why does the first one work but not the second one?  No. If I insert numbers from [1-9], the first algorithm will allow my tree to print out all the numbers, while the second one only stores "1"  Your code doesn't match the C++ version in Wikipedia. You can't pass a reference to a pointer in Java, nor do you create a new Node as it does in the original code.  @Macrosoft-Dev All arguments are passed by value, even references are passed by value.  2 Answers 2  let's look at what references are. (Java-references, not to be confused with C++-references)  Let's assume we have some memory with addresses, in this case the data is some String Object  If we have a reference, than this reference is only an address, not the data itself!  Now, what happens if we call a method? Every value passed to a method will be copied.  The output of this will be 15. because, the value of gets copied to the call method. And the method only changes the copy, but not the original i.  The same goes for references:  The output here will be . As with the primitives, will be copied. But don't worry, only the address will be copied. The result is, that the call method works on a copy of which is . But the value of the original is not changed.  So, what is the connection to your problem? See this method:  Clearly as you can see, your code operates on the copy of the reference! You are changing a copy which will be discarded after the method. Basically the solution to your problem with the second code is to use the first code snippet. You could work with some wrapper object, like C++-references, but this get's complicated and will be error prone.  It does not work because you do not connect the element 'temp' in the tree. Suppose you reached the point where you have to add temp in the tree. Suppose at some stage you have current and  current.leftchild=null and you have to add temp here.What is done in second method is you got to current.leftchild and assign temp to it , but you have not actually pointed the left pointer to temp.Thus temp will be inaccessible and no tree is formed. That is you have to keep return type Node to solve the problem.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  