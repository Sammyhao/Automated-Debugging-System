 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I tried to solve this problem Problem Description It seems correct idea is to check if given graphs have cycles (whether is a tree). However, my code couldn't pass Test 7, (Always Time Limit Exceeded), any idea how to make this faster? I used DFS. Many thanks Yes, finally got accepted. The problem is dfs on each vertex, which is unnecessary. the dfs function should be like this.  5,44133 gold badges3333 silver badges6969 bronze badges  10  1  a general rule of thumb is that recursion is slower then iterative counterparts. Try using bfs if possible?  well, i agree. but i have removed 'recursion' by using a buffer array to unmark the visited-array. Besides,, i think DFS finds a cycle faster....  Surely you could use a known property of trees, say something about number of edges versus number of vertices to avoid most of this work? You would need to do so per connected component.  @FUD: The claim is wrong. I benchmarked (and statistically proved) it in this thread for iterative/recursive quick sort. You need to have a very optimized implementation of a stack (for the specific need) in order for that claim to be true.  A graph is a tree if and only if it (1) is connected and (2) has no cycles. These (1) and (2) are equivalent to the (1) and (2) given by @amit.  1 Answer 1  I know next to nothing about Pascal, so I could be misinterpreting what you are doing, but I think the main culprit is at where you unmark visited vertices. This forces you into doing a DFS from each vertex, whereas you only need to do one per component.  In the case where there is more than one connected component the movement will either halt  because a vertex points to a vertex already marked, in which case we just halt due to a cycle having been found  because the vertex points to no one (but itself), in which case we need to find the next unmarked vertex and start another DFS again from there  You need not worry about bookkeeping for backtracking as each vertex at most points to one other vertex in this problem. There is also no need to worry about which DFS did which marking, as each will only work within its connected component anyway.  In the case where a vertex that points to itself is encountered first, it should not be marked yet, but skipped over.  Alternate Solution Using Set Union and Vertex/Edge Count  Since a tree has the property that the number of edges is one less than the number of vertices, there is another way to think about the problem -- determine (1) the connected components and (2) compare the edge and vertex count in each component.  In many languages you have a Set data structure with near-constant time Union/Find methods readily available. In this case the solution is easy and fast - near-linear in the number of edges.  Create an Set for each vertex representing its connected component. Then process your edge list. For each edge, Union the Sets represented by the two vertices. As you go, keep track of the number of vertices in each Set and the number edges. Same example:  Process edge from 1 to 2  Process edge from 2 to 3  Process edge from 3 to 4  And we can stop here because at this point violates the vertex versus edge count of trees. There is a cycle in . It does not matter if vertex 5 points to itself or to someone else.  For posterity, here is an implementation in c. It's been a while, so forgive the sloppiness. It is not the fastest, but it does pass all tests within the time limit. The disjoint set coding is straight from Wikipedia's pseudocode.  25.6k11 gold badge5858 silver badges9090 bronze badges  4  Interresting solution, but could you explain how would that be faster than a dfs ? The way i see it, your solution is equivalent to dfs with earrly exit  @GreyGeek Yes, I do believe you are correct. I think I'll edit my answer to describe this as just another way of thinking about the problem. If we knew the graph was connected, comparing vertex and edge counts could certainly be faster than cycle detection via DFS. But, as it is, we have to determine connectivity, which DFS does at the same time.  @DoctorLai Yep, so a DFS should just as fast, faster indeed due to lower overhead. See the beginning of my answer for my attempt to diagnose what might be slowing down your DFS code.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  