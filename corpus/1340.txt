 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I know that STL has a HashMap API, but I cannot find any good and thorough documentation with good examples regarding this.  I want something like a java.util.HashMap in C++ and the standarized way to do it if there is one. Else the best non standard library. What do C++ developers commonly use when they need a HashMap?  5 Answers 5  The standard library includes the ordered and the unordered map ( and ) containers. In an ordered map the elements are sorted by the key, insert and access is in O(log n). Usually the standard library internally uses red black trees for ordered maps. But this is just an implementation detail. In an unordered map insert and access is in O(1). It is just another name for a hashtable.  An example with (ordered) :  Output:  If you need ordering in your container and are fine with the O(log n) runtime then just use .  Otherwise, if you really need a hash-table (O(1) insert/access), check out , which has a similar to API (e.g. in the above example you just have to search and replace with ).  The container was introduced with the C++11 standard revision. Thus, depending on your compiler, you have to enable C++11 features (e.g. when using GCC 4.8 you have to add to the CXXFLAGS).  Even before the C++11 release GCC supported - in the namespace . Thus, for old GCC compilers you can try to use it like this:  It is also part of boost, i.e. you can use the corresponding boost-header for better portability.  30.2k1111 gold badges123123 silver badges161161 bronze badges  3  1  While the standard library does not have a hash table-based container, almost all implementations include from the SGI STL in some form or another.  @JamesMcNellis which is advised unordered_map or hash_map for HashMap implementation  @ShameelMohamed, 2017, i.e. 6 years after C++11 it should be hard to find an STL that doesn't provide . Thus, there is no reason to consider the non-standard .  A is an older, unstandardized version of what for standardization purposes is called an (originally in TR1, and included in the standard since C++11). As the name implies, it's different from primarily in being unordered -- if, for example, you iterate through a map from to , you get items in order by key1, but if you iterate through an from to , you get items in a more or less arbitrary order.  An is normally expected to have constant complexity. That is, an insertion, lookup, etc., typically takes essentially a fixed amount of time, regardless of how many items are in the table. An has complexity that's logarithmic on the number of items being stored -- which means the time to insert or retrieve an item grows, but quite slowly, as the map grows larger. For example, if it takes 1 microsecond to lookup one of 1 million items, then you can expect it to take around 2 microseconds to lookup one of 2 million items, 3 microseconds for one of 4 million items, 4 microseconds for one of 8 million items, etc.  From a practical viewpoint, that's not really the whole story though. By nature, a simple hash table has a fixed size. Adapting it to the variable-size requirements for a general purpose container is somewhat non-trivial. As a result, operations that (potentially) grow the table (e.g., insertion) are potentially relatively slow (that is, most are fairly fast, but periodically one will be much slower). Lookups, which cannot change the size of the table, are generally much faster. As a result, most hash-based tables tend to be at their best when you do a lot of lookups compared to the number of insertions. For situations where you insert a lot of data, then iterate through the table once to retrieve results (e.g., counting the number of unique words in a file) chances are that an will be just as fast, and quite possibly even faster (but, again, the computational complexity is different, so that can also depend on the number of unique words in the file).  1 Where the order is defined by the third template parameter when you create the map, by default.  448k7474 gold badges586586 silver badges10491049 bronze badges  2  2  I realize I'm coming 9 years after the answer was posted but... do you have a link to a doc that mentions the fact that an unordered map can shrink in size ? Usually, std collections only grow. Moreover, if you insert a lot of data but know in advance more or less how many keys you'll insert, you can specify the size of the map on creation, which basically nullifies the resize cost (cause there won't be any).  @Zonko: Sorry, I didn't notice this when asked. As far as I know, an unordered_map doesn't shrink, except in response to calling . When you call , you specify a size for the table. That size will be used unless doing so would exceed the specified maximum load factor for the table (in which case, the size will be increased automatically to keep the load factor within limits).  Here's a more complete and flexible example that doesn't omit necessary includes to generate compilation errors:  Still not particularly useful for keys, unless they are predefined as pointers, because a matching value won't do! (However, since I normally use strings for keys, substituting "string" for "const void *" in the declaration of the key should resolve this problem.)  I have to say, this example is a very bad practice in C++. You are using a strongly typed language and destroying it by using . For starters, there's no reason to wrap the as it's part of the standard and reduces code maintainability. Next, if insist on wrapping it, use . That's exactly what they are for.  Strongly typed? You probably mean statically typed. The fact that he can go from const char ptr to void silently makes C++ statically, but not strongly, typed. There's types, but compiler won't say a thing unless you enable some obscure flag that most likely doesn't exist.  Here is a preview of the performance characteristic graph described in that answer:  For those of us trying to figure out how to hash our own classes whilst still using the standard template, there is a simple solution:  Under the standard namespace, declare a template struct called hash with your classname as the type (see below). I found a great blogpost that also shows an example of calculating hashes using XOR and bitshifting, but that's outside the scope of this question, but it also includes detailed instructions on how to accomplish using hash functions as well https://prateekvjoshi.com/2014/06/05/using-hash-function-in-c-for-user-defined-classes/  So then to implement a hashtable using your new hash function, you just have to create a or just like you would normally do and use as the key, the standard library will automatically use the hash function you defined before (in step 2) to hash your keys.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  