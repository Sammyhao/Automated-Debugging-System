 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I need a priority queue that will store a value for every key, not just the key. I think the viable options are since it iterates in key order, or since it sorts on K before V. Is there any reason I should prefer one over the other, other than personal preference? Are they really the same, or did I miss something?  18.6k2323 gold badges117117 silver badges189189 bronze badges  5  by default stores your elements as under the hood unless you specify different. It's just an adapter of container, not container itself.  Personally I would go with the one with the nicest interface for what you want to do.  @pkrysiak isn't the same as a pre-sorted vector because it allows O(log N) insertion. It's preferable, though, if insertion isn't needed.  1 Answer 1  A priority queue is sorted initially, in O(N) time, and then iterating all the elements in decreasing order takes O(N log N) time. It is stored in a behind the scenes, so there's only a small coefficient after the big-O behavior. Part of that, though, is moving the elements around inside the vector. If or is large, it will be a bit slower.  is a red-black tree (in universal practice), so it takes O(N log N) time to insert the elements, keeping them sorted after each insertion. They are stored as linked nodes, so each item incurs and overhead. Then it takes O(N) time to iterate over them and destroy the structure.  The priority queue overall should usually have better performance, but it's more constraining on your usage: the data items will move around during iteration, and you can only iterate once.  If you don't need to insert new items while iterating, you can use with a , of course. This should outperform the by some constant factor.  As with most things in performance, the only way to judge for sure is to try it both ways (with real-world testcases) and measure.  By the way, to maximize performance, you can define a custom comparison function to ignore the and compare only the within the .  @Iamanon It is not fully sorted. Forming the PQ ordering is O(n) and removing elements in full order is O(log n) per each.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  