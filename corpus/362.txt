 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am building a program to search for, identify, and mark the location of a graph of integer values in a simple two-dimensional array.  I hand traced the first example and it appeared to work out accurately. With that said I either wrote code that doesn't do what I think it does or my hand tracing was inaccurate.  I think my code is close and I'm looking for some debugging assistance and any thoughts on general style, etc.  Eventually this algorithm will be modified to find graphs of the pixels of characters for OCR. I simply want to prove that my algorithm implementation is accurate prior to complicating things with the code for processing images.  and the expected outcome is this:  another similar possibility is: in:  out:  The array size of the input file must match the GS defined in the .cpp file (H equals W equals GS).  A graph is defined as one or more "1" values adjacent to each other.  The search is performed using a basic BFS technique using a simple queue.  When a graph is located its values will be updated from "1" to "2".  When the final value in the graph is determined a bounding box of "3" values will be drawn around the graph. The smallest X of the box equals the smallest X of the graph minus two, the smallest Y of the box equals the smallest Y of the graph minus two. The largest X of the box equals the largest X of the graph plus two, the largest Y of the box equals the largest Y of the graph plus two. Assume all graphs have a buffer of at least two rows/columns from the border to allow a box to be drawn.  1 Answer 1  This code does not compile. You've left out `queue.h`. We can infer it, but you shouldn't make us do that.  You have class declarations in this source file; they belong in the header file (otherwise there isn't much point in having a header file).  If you're going to have class declarations in the source file, for heaven's sake put them before the code that needs them.  There's a simple compile-time bug in `queue::del()`. Either your compiler isn't very good, or you've turned off warnings, or you're ignoring warnings, or you can't be bothered to fix the easy stuff.  Is there some good reason you're using arrays instead of STL containers?  Is there some good reason you're declaring all of these points on the heap?  I don't want to jump to conclusions, but the logic in your main loop looks really confused and over-complicated.  Most important: If you were to dispense with the bounding box, I very much doubt that the program would run bug-free, and the bugs would be much easier to find. Did you try that before writing code for the bounding box? You should test each new behavior as you put it in, and never add to code that doesn't work. (I say that so often I should start calling it "Beta's Rule".)  Now let's look for bugs...  In the main loop, you iterate from `xLo` and `yLo`, but you modify those variables in the loop.  Sometimes you index with `[j][k]`, sometimes with `[k][j]`. When I clean that up, some of the bad behavior disappears.  You're drawing a separate bounding box around every point of the graph.  There's a simple off-by-one bug in you bounding box routine.  And now it works, for one graph. I'm not going to try it with two.  EDIT: I have to eat some of my words: you don't index with , I was just confused by your use of and got it mixed up with an actual bug elsewhere. And now I see what you're doing with the , but seriously you should look into the STL.  The really serious bug is in the signature of . You're passing by value, not by reference. Fix that, and the code works for multiple graphs.  EDIT: Yep, another bug: stores pointers to points, not points, for no particular reason (see "6", above), and somehow it's fouling them up. Rather than hunt down the exact bug, I changed to handle points, and got the correct result for the complicated graph.  89.8k1111 gold badges137137 silver badges143143 bronze badges  6  Thanks for your feedback. Regarding your 1st 8 comments, queue.h is in fact included at the bottom of the code. I simply for got to say it was queue.h and said it was the "queue class". Queue was written by someone else for me to use. I am aware of the bug but it has no practical consequences in my use. The logic in the main loop came from pseudo code I am working with. Not sure if you simply wanted to berate it or if you have something valuable to add there. Beta's rule makes sense.  I fixed the use of xLo/yLo to keep the loop incrementing properly. I don't actually index with [j][k] and then [k][j] as far as I can see. Regarding a one off bug in the bounding box routine, I don't see it. I did change the indexing of the second portion of the code as to not change some of the values twice. This part: 'for (int y = yLo - 1; y <= yHi + 1; y++)'. But in the end I am not really getting anywhere. I do see that I am calling the bounding box more than necessary. It needs to be inside the loop otherwise it only gets called once even if there is more than one graph. Any thoughts?  No. The graphs cannot be close together. The intent is to modify this algorithm for identifying letters for OCR using EasyBMP. The spec assumes at least 5 pixels separating adjacent characters (graphs). In my test case using the simple array of integers I setup the input to allow enough room for separate graphs to not overlap. Other acceptable inputs would be THIS. We are limited to square 2D arrays only in the context of this test algorithm...  OK. Making some progress. To your credit, some of my indexing was questionable and I cleaned it up. This didn't modify function but it is more consistent and not as confusing. Changed Q to pass by reference and this made a big difference. Please see further examples at this link. The 1st shows an accurate 20 x 20 array of simple graphs. All are located and all are boxed properly. The next shows a 15 x 15 array with one complicated graph. Since I'm using an "8 neighbor" algorithm this should work but the result is boxing 2 graphs when it is only 1.  Thanks for all the help. In the end I used the STL queue instead of the flawed implementation of a queue that was provided to me. My program now functions perfectly on arrays of integers. Unfortunately I now have some sort of bug in my adaptation of this code to process BMP files for OCR. The battle continues...  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  