 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  8 Answers 8  Ensure that your array is sorted since this is the crux of a binary search.  Any indexed/random-access data structure can be binary searched. So when you say using "just an array", I would say arrays are the most basic/common data structure that a binary search is employed on.  You can do it recursively (easiest) or iteratively. Time complexity of a binary search is O(log N) which is considerably faster than a linear search of checking each element at O(N). Here are some examples from Wikipedia: Binary Search Algorithm:  @Firas Assad, Thanks, updated code to show the fix associated with preventing the overflow  is the same as . Not sure with integer division in play, but the algorithm works nevertheless with both formulas.  Binary Search in Javascript (ES6)  It depends if you have repetition of one element in your array or no and if you care about multiple findings or not. I have two methods in this implementation. One of them returns only first finding, but the other one returns all findings of the key.  You should check a[n], too, in the end. Otherwise does not find e.g. 1 from {0,1}.  @jarno As conventional with C, is the length of the (0-based) array so is not valid. Meanwhile, is valid and returns .  Did implement below code in Java,simple and fast /** * Binary Search using Recursion * @author asharda * */ public class BinSearch {  with more tacit(and possible less computation hungry) if observe former is equal:  so if left,mid,right vars situated sequentially we can address to all of them throw &mid[-1,0,1 respectively] in C pointer sense :  now we get body of loop so we can construct binary search:  after while we just:  with semantic that  so in some more human pseudocode javascript function equivalent:  for js sintax we need use q={'-1':0,1:nums.length-1} where left name for q[-1], mid for q[0] and right for q[1] or for q for all 3 is q[dir]  or the same for array indexing from 0:  we can use p=[0,,nums.length-1] where left is nikname for p[0], mid for p[1] and right for p[2] which is for all 3 of them is p[1+dir]  Thank you for contributing an answer. Would you kindly edit your answer to to include an explanation of your code? That will help future readers better understand what is going on, and especially those members of the community who are new to the language and struggling to understand the concepts.  Assuming the array is sorted, here is a Pythonic answer with O(log n) runtime complexity:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  