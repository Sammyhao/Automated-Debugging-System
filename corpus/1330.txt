 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm beginner and learning C++ Having hard times to understand std::map concepts, because the code I'm playing with implies that the is a search tree, i.e. all the names of std::map objects have *tree in it as well as comments.  So I`m confused -- either the variables and comment in the code lie to me, or the subject is more complex then I think it is :)  5,20066 gold badges4242 silver badges9595 bronze badges  4  1  It isn't defined by the standard, but the complexity requirements are kind of limiting in that regard.  is often implemented using red-black trees, while is often implemented using hash tables. But the standard doesn't mandate much so if you can come up with other data structures that fit both functional and complexity requirements of the C++ standard then all is fine. :)  Stroustrup, in The C++ Programming Language (4th Edition) states "It is implemented as a balanced binary tree".  6 Answers 6  Did you know that on Ubuntu's 16.04 default package or a GCC 6.4 build from source you can step into the C++ library without any further setup?  By doing that we easily conclude that a Red-black tree used in this implementation.  This makes sense, since , unlike , can be traversed in key order, which would not be efficient in if a hash map were used.  main.cpp  Compile and debug:  Now, if you step into you immediately reach :  which clearly just forwards to .  So we open the source file in and find the definition of :  So is of type and is a .  OK, now that is enough evidence for me. If you don't believe that is a Black-red tree, step a bit further and read the algorithm  uses hash table  Same procedure, but replace with on the code.  This makes sense, since cannot be traversed in order, so the standard library chose hash map instead of Red-black tree, since hash map has a better amortized insert time complexity.  Stepping into leads to :  So we open the source file in and search for the definition of :  on the non-zoomed plot, we clearly see the backing dynamic array doubling on huge one off linearly increasing spikes  on the zoomed plot, we see that the times are basically constant and going towards 250ns, therefore much faster than the , except for very small map sizes  Several strips are clearly visible, and their inclination becomes smaller whenever the array doubles.  I believe this is due to average linearly increasing linked list walks withing each bin. Then when the array doubles, we have more bins, so shorter walks.  is an associative container. The only requirement by the standard is that the container must have an associative container interface and behavior, the implementation is not defined. While the implementation fits the complexity and interface requirements, is a valid implementation.  Viewed externally a map is just an associative container: it behave externally as an "array" (supports an expression) where x can be whatever type (not necessarily integer) is "comparable by <" (hence ordered).  But:  Because can be any value, it cannot be a plain array (otherwise it must support whatever index value: if you assign a[1] and a[100] you need also the 2..99 elements in the middle)  Because it has to to be fast in insert and find at whatever position, it cannot be a "linear" structure (otherwise elements shold be shifted, and finding must be sequential, and the requirements are "less then proportional finding time".  The most common implementation uses internally a self-balancing tree (each node is a key/value pair, and are linked togheter so that the left side has lower keys, and the right side has higer keys, so that seraching is re-conducted to a binary search), a multi-skip-list (fastest than tree in retrieval, slower in insert) or a hash-based table (where each x value is re-conducted to an index of an array)  As chris have written, the standard doesn't define the internal structure of the std::map or std::set. It defines the interface and complexity requirements for operations like insertion of an element. Those data structures of course may be implemented as trees. For example the implementation shipped with VisualStudio is based on a red-black tree.  I would say that if you think of a map as a pair you can't go wrong. Map can be implemented as a tree or a hash map, but the way it is implemented is not as important since you can be sure any implementation is STL is an efficient one.  It can't be a hash map, because the Standard requires that "The fundamental property of iterators of associative containers is that they iterate through the containers in the non-descending order of keys where non-descending is defined by the comparison that was used to construct them." and hash tables don't provide sorted iteration  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  