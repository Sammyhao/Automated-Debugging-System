 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Suppose I have a grid of squared defined like so in a class:  This, oddly, seems to compile fine. I would think it would error because the compiler doesn't know how big the array is? Anyways, it means it is a pointer to an array. Then to initialize it, I do:  This isn't accepted by the compiler, because the statement returns a pointer to squares rather than a pointer to an array of squares. It makes sense that it does that. Now, is there a simple way to accomplish what I'm asking, other than just declaring and looping through it and doing separate allocations for each column of the 2D array?  4,22055 gold badges2727 silver badges4646 bronze badges  7  What's wrong with changing to ? If is truly a grid then there's no point to adding the complexity of making it multi-dimensional.  What's right with that? The array is dynamic; the size of it isn't known at compile time.  It accomplishes exactly what you're asking for, so what isn't right with that? Note that and are identical...  Well they're not identical in class definitions. Only in function arguments and a few other things.  However, I see where you're getting at. I could just make a 1D dynamic array and emulate a 2D one, right?  2 Answers 2  This, oddly, seems to compile fine. I would think it would error because the compiler doesn't know how big the array is?  That's declaring a pointer to an array, not an array; it's fine to declare a pointer to any incomplete type, including an array of unknown size. However, it's quite an unusual thing to do, and not what you want for a dynamic array.  Now, is there a simple way to accomplish what I'm asking?  The easiest dynamic array to use is:  initialised as  If you really want to manage the memory yourself, then change your pointer-to-array to a pointer-to-object:  initialised as  A pointer can point to either a single object, or the start of an array; if it does point to an array, then you can use on it just like with a non-dynamic array. Make sure you deallocate it () once you've finished with it.  If you want a 2-dimensional array, it's often easiest to use a 1-dimensional array, and wrap the necessary arithmetic in an accessor function:  I believe the reason works is because pointers to incomplete types are allowed, and an array without a size counts as an incomplete type.  The reason that you can't do  even though it looks like the types match up perfectly is just another manifestation of the bug in the design of C where array types are treated specially. It seems like ing an object of type should return a pointer to an object of that type. However you're not really ing an array type, but ing the element type . The result of is a pointer to the element type, in line with the C convention for arrays.  You can use a cast to 'fix' this to use the 'right' type:  Or you can just do it the C++ way and use a  If you have a fixed size array you can use  pretty much fixes all the mistakes made in the design of array types. For example can't 'forget' its size, functions can take parameters by value (whereas with raw arrays the array syntax just becomes a synonym for pointers), functions can return whereas they are inexplicably prohibited from returning arrays (The syntax would be ), and with there's no need for a special array allocator which must be matched to an array deallocator (instead you can say and then 'delete foo;')  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  