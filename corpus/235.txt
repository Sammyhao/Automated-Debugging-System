 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to solve the programming problem firstDuplicate on codesignal. The problem is "Given an array that contains only numbers in the range to , find the first duplicate number for which the second occurrence has minimal index".  Example: For the output should be  There are 2 duplicates: numbers 2 and 3. The second occurrence of 3 has a smaller index than the second occurrence of 2 does, so the answer is 3.  With this code I pass 21/23 tests, but then it tells me that the program exceeded the execution time limit on test 22. How would I go about making it faster so that it passes the remaining two tests?  The answer is the same regardless of language. In Java, I had to use and instead of iterating over the array multiple times.  3 Answers 3  Anytime you get asked a question about "find the duplicate", "find the missing element", or "find the thing that should be there", your first instinct should be use a hash table. In C++, there are the and classes that are for such types of coding exercises. The is effectively a map of keys to bools.  Also, pass you vector by reference, not value. Passing by value incurs the overhead of copying the entire vector.  Also, that comparison seems costly and unnecessary at the end.  is linear time complexity in terms of distance between first and last element (or until the number is found) in the container, thus having a worst-case complexity of O(N), so your algorithm would be O(N^2).  Instead of storing your numbers in a vector and searching for it every time, Yyu should do something like hashing with to store the numbers encountered and return a number if while iterating, it is already present in the map.  Edit: is even more efficient if the order of keys doesn't matter, since insertion time complexity is constant in average case as compared to logarithmic insertion complexity for .  8,26533 gold badges2323 silver badges5454 bronze badges  2  is more efficient than (hash table vs tree insertion). accomplishes the same thing as a a map of boolean values.  Yes, you are right, insertion time is constant average case as compared to log(n) for .  It's probably an unnecessary optimization, but I think I'd try to take slightly better advantage of the specification. A hash table is intended primarily for cases where you have a fairly sparse conversion from possible keys to actual keys--that is, only a small percentage of possible keys are ever used. For example, if your keys are strings of length up to 20 characters, the theoretical maximum number of keys is 25620. With that many possible keys, it's clear no practical program is going to store any more than a minuscule percentage, so a hash table makes sense.  In this case, however, we're told that the input is: "an array a that contains only numbers in the range 1 to a.length". So, even if half the numbers are duplicates, we're using 50% of the possible keys.  Under the circumstances, instead of a hash table, even though it's often maligned, I'd use an , and expect to get considerably better performance in the vast majority of cases.  The advantage here is fairly simple: at least in a typical case, uses a specialization to store s in only one bit apiece. This way we're storing only one bit for each number of input, which increases storage density, so we can expect excellent use of the cache. In particular, as long as the number of bytes in the cache is at least a little more than 1/8th the number of elements in the input array, we can expect all of to be in the cache most of the time.  Now make no mistake: if you look around, you'll find quite a few articles pointing out that has problems--and for some cases, that's entirely true. There are places and times that should be avoided. But none of its limitations applies to the way we're using it here--and it really does give an advantage in storage density that can be quite useful, especially for cases like this one.  We could also write some custom code to implement a bitmap that would give still faster code than . But using is easy, and writing our own replacement that's more efficient is quite a bit of extra work...  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  