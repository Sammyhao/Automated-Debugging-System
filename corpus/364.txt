 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I just encountered a DEBUG macro in C that I really like  I'm guessing a C++ analogue would be :-  Is the second code snippet analogous to the one in C?  Do you have any favorite C++ debug macros?  EDIT : By "Debug Macros" I mean "macros that might come in handy while running a program in debug mode".  @OliCharlesworth I do realize that my second question might be subjective -- however, I'm not asking an opinion on something specific, im asking for code samples that are commonly used by the programming lot on SO. However, if the visitors still feel that the question is not appropriate for SO, I'll make sure I edit it out.  – user277465  Jan 10 '13 at 5:09  @Pubby Apologies to have been unclear -- I meant "macros that might be useful while running a program in debug mode"  10 Answers 10  Is the second code snippet analogous to the one in C?  More or less. It's is more powerful, as you can include -separated values in the argument, so with a single argument you get something that would require a variable number of macro arguments in C. On the other hand, there is a slim chance that people will abuse it by including a semicolon in the argument. Or even encounter mistakes due to a forgotten semicolon after the call. So I'd include this in a do block:  Do you have any favourite C++ debug macros?  I like the one above and use it quite often. My no-op usually just reads  which has the same effect for optimizing compilers. Although the comment by @Tony D below is correct: this can leave some syntax errors undetected.  I sometimes include a run-time check as well, thus providing some form of a debug flag. As @Tony D reminded me, having an endl in there is often useful as well.  Sometimes I also want to print the expression:  In some macros, I like to include , or , but these are more often assertions and not simple debug macros.  53.5k1616 gold badges132132 silver badges260260 bronze badges  4  9  "My no-op usually just reads "... a substitution tends to produce an error if the DEBUG-invocation's semicolon is missing, instead of leaving the next statement to slip into the DEBUG's place. E.g. "if (expr) DEBUG", next line: "++i;", you'd get "if (expr) ++i;". Small reason to prefer do-while. A lot of the time putting "" into the macro is best too.  @TonyD: Good points, updated my answer. Although is superior to since it also flushes the stream.  in the case of , it's normally line buffered so will flush anyway and using is cheaply redundant, but - pet peeve - what bothers me is people using in streaming operators that might be used for , a file stream etc - that screws with the buffering badly and can lead to dramatically worse performance.  It's super handy and makes for clean (and importantly, fast in release mode!!) code.  Lots of blocks all over the place (to filter out debug related blocks of code) is pretty ugly, but not so bad when you wrap a few lines with a .  How to use:  If that's still too ugly/weird/long for you,  (I suggest not using though maybe could be a good idea)  Note that you might want to do more things than just print to stderr when you are thinking about "debugging". Get creative, and you can build constructs that offer insight into the most complex interactions within your program, while allowing you to very quickly switch to building a super efficient version unencumbered by debug instrumentation.  For example in one of my recent projects I had a huge debug-only block which started with and proceeded to dump out a graphviz compatible graph in dot format to visualize large trees within my datastructures. What's even cooler is the OS X graphviz client will auto-read the file from disk when it changes, so the graph refreshes whenever the program is run!  I also particularly like to "extend" classes/structs with debug-only members and functions. This opens up the possibility of implementing functionality and state that is there to help you track down bugs, and just like everything else that is wrapped in debug macros, is removed by switching a build parameter. A giant routine that painstakingly checks each corner case on every state update? Not a problem. Slap a around it. Once you see it works, remove from the build script, i.e. build for release, and it's gone, ready to be re-enabled at a moment's notice for your unit-testing or what have you.  A large, somewhat complete example, to illustrate (a perhaps somewhat overzealous) use of this concept:  Notice that for large blocks of code, I just use regular block conditionals because that improves readability somewhat, as for large blocks the use of extremely short macros is more of a hindrance!  The reason why the macro must exist is to specify what to add when unit-testing is disabled.  In this part:  It would be nice if we could say something like  But we cannot, because the comma is a part of preprocessor syntax. Omitting the comma produces invalid C++ syntax.  If you had some additional code for when not compiling for debug, you could use this type of corresponding inverse-debug macro.  Now this code might not be an example of "really good code" but it illustrates some of the things that you can accomplish with clever application of macros, which if you remain disciplined about, are not necessarily evil.  I came across this gem just now after wondering about the stuff, and you really do want all that fanciness in these macros as well!  Hopefully my example can provide some insight into at least some of the clever things that can be done to improve your C++ code. It is really valuable to instrument code while you write it rather than to come back to do it when you don't understand what's happening. But it is always a balance that you must strike between making it robust and getting it done on time.  I like to think of additional debug build sanity checks as a different tool in the toolbox, similar to unit tests. In my opinion, they could be even more powerful, because rather than putting your sanity check logic in unit tests and isolating them from the implementation, if they are included in the implementation and can be conjured at will, then complete tests are not as necessary because you can simply enable the checks and run things as usual, in a pinch.  38.2k5353 gold badges191191 silver badges342342 bronze badges  7  Wow, I have never known that macro parameter ( in ) can also eat and . How far can it be interpreted? I heard that parameter of macro cannot contain character or . May you provide some rule/limitation reference/link about it, please? It is hard to find such rule in books. Thank.  AFAIK the way a macro works is it substitutes the string up until syntax prevents it from doing so. Because the parens are implicated in the substitution, you wouldn't be able to embed an unmatched set of parens, for example. And the commas are also implicated (in separating the macro args!). But everything else is fair game. Employ the tricks sparingly and responsibly...  Don't ever use empty macros like , they're very dangerous! as it has been pointed out in comments to the accepted answer (which also suffers from this issue) you get unexpected behaviour if you forget mistakenly semicolon afterwards like where is executed only if is nonzero, while it looks as executed every time. If you put it like it's still removed seamlessly by the compiler, but will yield compile error in case of missing semicolon.  You're right @MarcinTarsier. I'll add it to my code listings to make them more safe. It's too bad that it's a bit uglier now.  This wont work in a struct definition. struct { D(int proof_of_initialization;) ... }. After several attempts with debug on and off and moving the semicolon around I finally went with the simple and dangerous #define D(x) x and #define D(x). This has its problems as noted but on the bright side it actually works.  For question 1] Answer is yes. It will just print the message to standard error stream.  For question 2] There are many. My Fav is  which will allow one to include arbitrary number of variables to include in the debug message.  I like to use macros with , as arguments to show where in the code the printout is from - it's not uncommon to print the same variable name in several places, so won't mean much if you then add another one the same ten lines further down.  I've also used macros that override certain functions and store where it was called from (e.g. memory allocations), so that later on, I can figure out which one it was that leaked. For memory allocation, that's a little harder in C++, since you tend to use new/delete, and they can't easily be replaced, but other resources such as lock/unlock operations can be very useful to trace this way [of course, if you have a locking wrapper that uses construction/destruction like a good C++ programmer, you'd add it to the constructor to add file/line to the internal structure once you have acquired the lock, and you can see where it's held elsewhere when the you can't acquire it somewhere].  122k1313 gold badges124124 silver badges212212 bronze badges  1  Agree. However I find func somewhat more useful than FILE when func is available.  Observation: as currently shown, you always have the debugging enabled. You also limit the output to 100 characters (which isn't very long), but you don't ensure no buffer overflow by using instead of . That's living dangerously, isn't it? Shouldn't your logging go to or ? What is new and distinctly different about this answer compared to others?  Personally I never use macros like to distinct debug from release code, instead I use which is must be defined for release builds to eliminate calls (yes, I use extensively). And if latter is not defined, then it is a debug build. Easy! So, actually there is no reason to introduce one more debug macro! (and handle possible cases when and both are not defined).  This is my version, using a variadic template function:  The version I makes the a variadic template function which accepts a debug level which allows me to select what kind of output I want to output at runtime:  Note the function crashes Visual Studio 2013 Preview (I haven't tested the RC). I have noticed it is faster (on Windows, where console output is slow) than my previous solution which used an child class that overloaded .  You can also use a temporary inside if you only want to call the real output function once (or write your own typesafe ;-))  I use the code below for logging. There are a few advantages:  I can turn them on/off at runtime.  I can compile out statements at a particular log level. For example, at the moment, I've unconditionally compiled in the macro because I'm debugging something in the release build but since there is a lot of potentially secret sauce stuff being logged (lol), I compile it out of release builds.  This pattern has served me very well over the years. Note: although there is a global function, the code usually queues the log to a logging thread.  As is clear from the other answers, there are many. There is one that I like which both allows for a variable number of arguments, prints the names of the arguments, and which includes a newline.  Much of the explanation is as in this answer, but I find that the additional templating simplifies it when I want to debug-print several variables on one line without having different macros.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  