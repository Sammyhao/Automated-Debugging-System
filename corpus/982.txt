 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Is it possible to pass a lambda function as a function pointer? If so, I must be doing something incorrectly because I am getting a compile error.  That's one heck of an error message to digest, but I think what I'm getting out of it is that the lambda cannot be treated as a so therefore I cannot pass it as a function pointer? I've tried making constexpr as well, but that doesn't seem to help.  9 Answers 9  A lambda can only be converted to a function pointer if it does not capture, from the draft C++11 standard section [expr.prim.lambda] says (emphasis mine):  The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type’s function call operator.  Note, cppreference also covers this in their section on Lambda functions.  So the following alternatives would work:  and so would this:  and as 5gon12eder points out, you can also use , but note that is heavy weight, so it is not a cost-less trade-off.  146k3434 gold badges412412 silver badges697697 bronze badges  1  4  Side note: One common solution used by C stuff is to pass a as the sole parameter. It's normally called a "user pointer". It's relatively lightweight, too, but does tend to require that you out some space.  Shafik Yaghmour's answer correctly explains why the lambda cannot be passed as a function pointer if it has a capture. I'd like to show two simple fixes for the problem.  Use instead of raw function pointers.  This is a very clean solution. Note however that it includes some additional overhead for the type erasure (probably a virtual function call).  Use a lambda expression that doesn't capture anything.  Since your predicate is really just a boolean constant, the following would quickly work around the current issue. See this answer for a good explanation why and how this is working.  Note that in general, if you know the capture data at compile time, you can convert it to type data and then you're back to having a lambda with no capture - see this answer that I just wrote to another question (thanks to @5gon12eder's answer here).  Shouldn't the object have a longer lifespan than the pointer function then? I would like to use it for .  i don't recommend this suggestion, things that tend to work magically, introduce new errors. and practices that go along with those errors. if you want to use std::function, you should see all kinds of ways that std::function can be used. because some ways maybe something that you don't want.  This doesn't answer the question. If one could use or a lambda — why wouldn't they? At the very least it's a more readable syntax. Usually one needs to use a function pointer to interact with C libraries (actually, with any external library), and sure you can't go modify it to accept an std::function or lambda.  Lambda expressions, even captured ones, can be handled as a function pointer (pointer to member function).  It is tricky because an lambda expression is not a simple function. It is actually an object with an operator().  When you are creative, you can use this! Think of an "function" class in style of std::function. If you save the object you also can use the function pointer.  To use the function pointer, you can use the following:  To build a class that can start working like a "std::function", first you need a class/struct than can store object and function pointer. Also you need an operator() to execute it:  With this you can now run captured, non-captured lambdas, just like you are using the original:  Wow That's amazing! So we just could use lambda's class inner pointers (to member function operator() ) to invoke stored lambdas in a wrapper class!! AMAZING!! Why do we ever need the std::function then? And is it possible to make lambda_expression<decltype(lambda), int, int, int> to automatically deduce/ these "int" parameters directly from the passed lambda itself?  I've added a short version of my own code. this should be working with a simple auto f = make::function(lambda); But i'm quite shure you will find plenty of situation my code will not work. std::function is way more well constructed than this and should be the go to when you are working. This here is for education and personal use.  This solution involves calling the lambda via an implementation, so if I'm reading it right I don't think it would work to call the lambda using a C-style function pointer, would it? That is what the the original question asked for.  You claimed that lambdas can be handled as function pointers, which you didn't do. You created another object to hold a lambda, which does nothing, you could've just used the original lambda.  This is not "passing capturing lambda as function pointer". This is "passing capturing lambda as an object that contains a function pointer among other things". There is a world of difference.  Capturing lambdas cannot be converted to function pointers, as this answer pointed out.  However, it is often quite a pain to supply a function pointer to an API that only accepts one. The most often cited method to do so is to provide a function and call a static object with it.  This is tedious. We take this idea further and automate the process of creating and make life much easier.  This is essentially declaring an anonymous function at each occurrence of .  Note that invocations of overwrite the previously written given callables of the same type. We remedy this, to a certain degree, with the parameter .  17.3k66 gold badges4242 silver badges8585 bronze badges  1  1  forcing the N integer to be declared would be an elegant way to remember the client to avoid overwriting the function pointers at compile time.  That lambda doesn't have a capture. The OP's issue is the capture, not having to deduce the function pointer type (which is what the trick gets you).  Not a direct answer, but a slight variation to use the "functor" template pattern to hide away the specifics of the lambda type and keeps the code nice and simple.  I was not sure how you wanted to use the decide class so I had to extend the class with a function that uses it. See full example here: https://godbolt.org/z/jtByqE  The basic form of your class might look like this:  Where you pass the type of the function in as part of the class type used like:  Again, I was not sure why you are capturing it made more sense (to me) to have a parameter that you pass in to the lambda) so you can use like:  While the template approach is clever for various reasons, it is important to remember the lifecycle of the lambda and the captured variables. If any form of a lambda pointer is is going to be used and the lambda is not a downward continuation, then only a copying [=] lambda should used. I.e., even then, capturing a pointer to a variable on the stack is UNSAFE if the lifetime of those captured pointers (stack unwind) is shorter than the lifetime of the lambda.  A simpler solution for capturing a lambda as a pointer is:  e.g.,  Just remember to later so ensure that you don't leak the lambda memory. Secret to realize here is that lambdas can capture lambdas (ask yourself how that works) and also that in order for to work generically the lambda implementation needs to contain sufficient internal information to provide access to the size of the lambda (and captured) data (which is why the should work [running destructors of captured types]).  Why bother with the -- std::function already stores the lambda on the heap AND avoids needing to remember calling delete.  By "capture a lambda as a pointer", you mean type-erase inside ... but OP clearly wanted a free function pointer. Having a pointer to , by advising the pointless antipattern of raw , doesn't qualify as relevant to the Q.  A simular answer but i made it so you don't have to specify the type of returned pointer (note that the generic version requires C++20):  As it was mentioned by the others you can substitute Lambda function instead of function pointer. I am using this method in my C++ interface to F77 ODE solver RKSUITE.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  