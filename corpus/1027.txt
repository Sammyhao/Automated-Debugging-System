 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  In my project I'm using Python's library to create multiple processes in __main__. The project is being packaged into a single Windows EXE using PyInstaller 2.1.1.  I create new processes like so:  And in __main__:  Unfortunately, when packaging the application into an EXE and launching it, I get 5 or 6 (seems random) at this line:  A recipe at PyInstaller's homepage claims that I have to modify my code to enable multiprocessing in Windows when packaging the application as a single file.  I'm reproducing the code here:  My frustration with this "solution" is that, one, it's absolutely unclear what exactly it is patching, and, two, that it's written in such a convoluted way that it becomes impossible to infer which parts are the solution, and which are just an illustration.  Can anyone share some light on this issue, and provide insight what exactly needs to be changed in a project that enables multiprocessing in PyInstaller-built single-file Windows executables?  Well, it's unclear (at least to me) how to apply the recipe. Just pasting the above code in my main Python script does not work, either, as it raises two more exceptions unrelated to my Python scripts. Which tells me that the recipe is fundamentally flawed.  No, I get two errors, one complaining that is incorrectly formatted, the other that there's something wrong with pywintypes, which is incorrect.  2 Answers 2  *nix (Linux, Mac OS X, etc.) does NOT require any changes for PyInstaller to work. (This includes both and options.) If you only intend to support *nix systems, no need to worry about any of this.  However, if you are planning on supporting Windows, you will need to add some code, depending on which option you pick: or .  If you plan to use , all you will need to add is a special method call:  According to the documentation, this call must be made immediately after , or else it will not work. (It is strongly suggested that you have these two lines in your main module.)  In reality, however, you can afford to do a check before the call, and things will still work:  However, calling is possible on other platforms and situations as well - running it only impacts freezing support on Windows. If you're a bytecode nut, you'll notice that the if statement adds some bytecode, and makes potential savings from using an if statement negligible. Therefore, you should just stick to a simple call immediately after .  If you plan to use , you will need to add nikola's code:  You can combine the above with the rest of his code, or the following:  I got the code from here, PyInstaller's new site for the multiprocessing recipe. (They seem to have shut down their Trac based site.)  Note that they have a minor error with their code for multiprocessing support. They add os.sep to their environment variable. (Line: ) This breaks things:  The code I provided above is the same, without the . Removing the fixes this issue and allows multiprocessing to work using the configuration.  In summary:  Enabling multiprocessing support on Windows (does NOT work with on Windows, but otherwise safe on all platforms/configurations):  Enabling multiprocessing support on Windows (safe on all platforms/configurations, compatible with ):  87111 gold badge1111 silver badges1414 bronze badges  2  1  Thanks for the detailed answer. I was having issues with zombie threads appearing after I close my main Python window (with tk) when I use --onefile option. The last snippet where you redefine Popen fixed the issue. For anyone working with Python >3.4, you need to use instead of .  Don't forget that should always be the first line in and that there should be no other code executed before this line (i.e. before the ). I had some imports that executed some code, resulting in not having any effect.  Apparently all we have to do is provide a (and ) class as shown below, and use it instead of . I've corrected and simplified the class to work on Windows only, *ix systems might need different code.  For the sake of completeness, here's the adapted sample from the above question:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  