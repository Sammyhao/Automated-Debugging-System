 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have been struggling to detect a memory corruption error in our product. The memory detection tools like valgrind only tell the problem at the time of the crash, not when the corruption actually occurs. I have seen while using debug builds that it will check the memory area before and after the block being freed, and show a debug assertion failure saying a heap corruption has occured. So can I rebuild my product in debug mode to capture the error right when it occurs? Will it also catch buffer overruns etc? I could not find any information on the internet about debug builds being targetted towards memory error detection.  If you know that some data is valid at a point and corrupted later, you can try to put a data breakpoint on it.  3 Answers 3  You can use as well the 'Page Heap' available on every version of Windows. You can use gflags that comes along to Debugging Tools for Windows to configure Full Page Heap for your application. You can then run your application, even in retail mode, under the debugger. The debugger will stop once you encounter a buffer overrun or access to freed memory.  I like very much this tool, because it is built in the OS, an can even be activated on a customer site (gflags only sets registry keys and you can simply send these keys to your customer).  Some people are afraid when we mention (Debugging Tools for Windows). You can use Visual Studio to diagnose the problem. The only thing you need are the PDBs corresponding to your binaries (you can generate them even for release builds).  So is the Page Heap mechanism as good as having a debug build? I was under the impression that it will only create a core dump file at the time the application crashes (not beforehand when the corruption acutally occurs).  The 'Full Page Heap' attempts to detect the corruption at the time it occurs. In rare cases, it will only detect it at a later time. It will generate a dump if you don't have a debugger attached to it. However, if you have a debugger, either WinDbg or Visual Studio, it will break immediately. You can then review the program state and, from the call stack, find out why it crashed. You can do this in release mode. However, to ease debugging, you can turn off optimization during the compilation phase. Give a try with Page Heap and I'm sure you'll love it !  "C++" is not a compiler; vendors make their own according (more or less) to the standard specs.  I only have experience with Microsoft's, and I can tell you that it checks heap corruption by allocating "sentries" around each or block (in debug mode only, of course) and filling them with a special pattern (was when I last used it), and then it checks the guards for every write around that location. If they changed, you'll get a run-time error saying the heap got corrupted.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  