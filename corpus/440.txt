 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Most of the time we can assume that stack is faster and cleaner. No memory fragmentation, easier to cache, quick allocation. That's also why people always assume that static buffer allocated on stack is much faster than dynamic buffer on heap. Is it? One misconception I see most of the time is that people assume that c99 extension (which is supported as non-standard extension in common C++ compilers like GCC) allocating dynamic sized array on stack will perform as fast as static size. I think it's not the case here. Stack operations are faster because we already know stack size and all of the offsets, compiler can easily reach to something allocated before or jump by constant offset. If stack becomes dynamic, it can no longer optimize it this way. You can simply write code with static and dynamic array allocated on stack, check assembly code and second option will be much more complicated.  Now the question is: Is using non-standard extension like VLA really more efficient than dynamic array on heap? If so, then in which cases it's faster, in which can be comparable or even worse?  I tried to run some benchmarks on example code on quick-bench. I wanted to test performance difference with small and large allocations. To make it even more extensive, I wanted to simulate accessing something allocated before this dynamically allocated stack to see if it is affected in any way.  Allocate temporary buffer.  Test #1 - 5k operations on static buffer and 5k size of temp buffer They look comparable although static allocation seems to be worse of them which is a bit suspicious.  Test #2 - 10 operations on static buffer and 5k size of temp buffer I'm not sure if this test is valid, quick-bench shows that incrementing counter took most of execution time.  Test #3 - 5k operations on static buffer and 10 size of temp buffer Looks a bit more reasonable although performance difference is very small.  Test #4 - 10 operations on static buffer and 10 size of temp buffer Heap allocation generates huge overhead but static dynamic stack is still much slower than constant stack buffer.  I performed the same tests in different versions, results are sometimes quite interesting although I'm not sure how reliable are results I get, most of all how "DoNotOptimize" affects this code.  Similar test but temp buffer is not used, just created to mess up with stack. Big static buffer, small temp.  I'm mostly curious about cases in which you can clearly see the difference and explain what happens. Also it would be good to get better benchmarking setup and understanding.  To me it seems like using VLA is just lazyness. For bigger allocations performance is comparable. For lots of small allocations it will still be better to use constant size buffer on stack. For lots of big allocations it might be good just because it reduces memory fragmentation but then maybe use some big, static buffer? For loading very big files it would be better to use memory mapping instead. I'm looking for some rationale why to use not supported VLA extension, what is real benefit of that? It might make more sense to create const size small buffer for smaller messages and dynamic buffers for messages that will not fit there.  To me it seems like using VLA is just lazyness -- It's all crap. should disable it by default, IMO.  IMHO, the right approach would have been a pair of LIFO-alloc/release functions which implementations could process using the stack, heap, or whatever combination happened to be most convenient. Both and VLAs are semantically inferior.  @PaulMcKenzie I think that by default all non-standard extensions should be disabled. If someone is not that familiar with C++, he will be forced to use it according to standard. If he really knows where to search and what to search for, then he'll find switches to enable extensions he needs. Imagine you see commercial project and can't enable pedantic because it requires heavy code refactoring. Just because people used what is available by default.  @supercat The exact problem I try to solve is communication using sockets. I want to make all of the code pass pedantic but VLA is used everywhere as most efficient way of allocating temporary buffer. I think benefit of VLA is not good enough compared to alternatives for sacrificing C++ standard compliance. I'd think that for most of smaller messages const size buffer on stack is enough, for bigger messages it does not matter too much and it can be allocated on heap with no significant performance loss.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  