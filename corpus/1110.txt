 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Given an arbitrary unweighted rooted tree which consists of N (2 <= N <= 40000) nodes. The goal of the problem is to find largest distance between two nodes in a tree. Distance between two nodes is a number of edges on a path between the nodes (there will be a unique path between any pair of nodes since it is a tree). The nodes will be numbered 0 through N - 1.  I am finding a node which is farthest from root node using dfs. From this node i am doing DFS to find the farthest node. this distance is the required answer. I implemented it, but while calling do_dfs function i am getting segmentation fault. i wrote return statement after every line to find out where i am getting error. I have indicated that line in comment in code.  Tescases :- A : [ -1, 0, 0, 1, 2, 1, 5 ] expected output : 5  1) Use instead of when accessing elements in your vectors. This will check if you are accessing an element out-of-bounds, and if you are, will throw an exception instead of seg faulting. 2) Check if you're trying to access an empty before issuing a call. 3) Please write a function, calling your with the test data.  did all of these three. This was shown : terminate called after throwing an instance of 'std::out_of_range' what(): vector::_M_range_check Aborted . Still can't find the reason for the exception.  The reason is stated in the error message -- you are going out-of-bounds in one of your vectors. Now figure out which call threw that exception by slowly introducing back into your code. Once you get the seg fault again, it was the last call you changed back to that caused the error.  Or just use a debugger which will stop at the exact point the exception is thrown  The algorithm works but IMHO it's not the best way to solve the problem. You build a bidirectional adjacency list and then completely forget that your graph is a tree. In a real tree, DFS from the root is simply a recursive traversal. You don't really need the second DFS because you can collect the data you need during the first one.  1 Answer 1  The problem is you're not fully iterating the given array. You start iterating from the index , while the array goes from index to . So your adjacency list does not get constructed properly, and the variable remains uninitialized in some cases. So you run into .  This is not a very good answer. What is the root cause of the problem? Why does this change solve it?  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  