 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm writing an multiarchitecture assembler/disassembler in Common Lisp (SBCL 1.1.5 in 64-bit Debian GNU/Linux), currently the assembler produces correct code for a subset of x86-64. For assembling x86-64 assembly code I use a hash table in which assembly instruction mnemonics (strings) such as and are keys that return a list of 1 or more encoding functions, like the ones below:  The encoding functions are like these (some are more complicated, though):  Now I am trying to incorporate the complete x86-64 instruction set by using NASM's (NASM 2.11.06) instruction encoding data (file ) converted to Common Lisp CLOS syntax. This would mean replacing regular functions used for emitting binary code (like the functions above) with instances of a custom class (a very basic class so far, some 20 slots with , , etc.), in which an method with arguments would be used for emitting the binary code for given instruction (mnemonic) and arguments. The converted instruction data looks like this (but it's more than 40'000 lines and exactly 7193 's and 7193 's).  I have converted NASM's to Common Lisp syntax (like above) using a trivial Perl script (further below, but there's nothing of interest in the script itself) and in principle it works. So it works, but compiling those 7193 objects is really really slow and commonly causes heap exhaustion. On my Linux Core i7-2760QM laptop with 16G of memory the compiling of an code block with 7193 objects like the ones above takes more than 7 minutes and sometimes causes heap exhaustion, like this one:  I had to add parameter for SBCL to get it compiled at all, but still after allocating 4 gigabytes of dynamic space heap sometimes gets exhausted. Even if the heap exhaustion would be solved, more than 7 minutes for compiling 7193 instances after only adding a slot in the class ( class used for these instances) is way too much for interactive development in REPL (I use slimv, if that matters).  Here's output:  Using OOP (CLOS) would enable incorporating the instruction mnemonic (such as or above, ), allowed operands of the instruction (), instruction's binary encoding (such as for , ) and possible architecture limitations () of the instruction in one object. But it seems that at least my 3-year-old computer is not efficient enough to compile around 7000 CLOS object instances quickly.  My question is: Is there some way to make SBCL's faster, or should I keep assembly code generation in regular functions like the examples further above? I'd be also very happy to know about any other possible solutions.  1 Answer 1  18636 warnings looks really bad, Start by getting rid of all the warnings.  I would start by getting rid of the around all that. Does not make much sense to me. Either load the file directly, or compile and load the file.  Also note that SBCL does not like when the variable is undefined. New top-level variables are introduced with or . just sets them, but does not define them. That should help to get rid of the warnings.  Also and smell like these properties should be converted into classes to inherit from (for example as a mixin). A container has variants. A variant does not have variants.  131k1010 gold badges208208 silver badges334334 bronze badges  2  2  -> fix dropped the compile time from 7 minutes to 2 minutes (I had to prefix the variable names, because causes error (in my own package the same happends because of ). Then I created a container class for each instruction (mnemonic), discarded and and created an instance of the container class for each variant, it dropped the compilation time from 2 minutes to 2 seconds. Thanks a lot, it works great.  @nrz: that's quite an improvement. 7 minutes to 2 seconds. Faktor 210. Btw., you could also make an own package for the variables. A package which would not :use Common Lisp...  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  