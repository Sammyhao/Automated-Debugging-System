 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm trying to build a BST (binary search tree) with dict in python. I do not understand why my code is not adding nodes to the BST. I saw a similar post here: How to implement a binary search tree in Python? which looks the same as my code except declaring a node class, but I would like to know why my dict implementation fails (and hopefully improve my understanding of parameter passing with recursion in python).  ===========================================  Edit: here is the code that would make it work!  Here is what I think that is happening under the hood (why one version is able to add to BST but the other one is not):  In the original version, we will reach a recursion call where still points to None inside the BST, but then make points to which has absolutely no connection with , i.e. the BST itself. Then local variables are deleted and no changes are made.  In the modified version, we will avoid this since when we add the node by e.g. . Here is still pointing to the original BST and thus we are modifying the key-val pair in the original BST instead of having point to something totally outside the BST.  The accepted answer of the linked question deals with left or right being None instead of recursing.  @ForceBru inside the function root is the first argument passed to the function, independent of the root outside. I've edited the code to clear any confusion.  @quamrana they were able to insert the node to the root so I thought I could do the same with dict, but I'm not sure why it fails..  2 Answers 2  Let's run through your code as though we were the python interpreter.  Lets start at the first call:  Here is the defined at the top of your script and is another (which curiously has the same value).  Lets jump inside the call and we find ourselves at: where refers to above and so is so fails this .  Next we find ourselves at: which in this case is not .  Next we pass into the and we are at: .  Just before we jump into the first recursive call, lets review what the parameters to the call are: from has the value and is still the same which we want to insert somewhere. So, onto the recursive call.  Again we find ourselves at:  However this time just refers to the first parameter of the first recursive call and we can see from the above review of the parameters that refers to .  Now is considered and so this time the succeeds and we are on to the next line.  Now we are at .  This is an assignment in python. What this means is that python will use the variable to stop referring to and to refer to whatever currently refers to, which is the which was created in the loop. So (which is just a parameter, but you can think of as a local variable now) refers to a .  Now what happens is that we are at the end of the first recursive call and this function ends. Whenever a function ends, all the local variables are destroyed. That is and are destroyed. That is just these variables and not what they refer to.  Now we return to just after the first call site i.e. just after  We can see here that the parameters: still refer to whatever they were referring to before. This is why your is unchanged and why your program should deal with and now instead of recursing.  31.6k1212 gold badges5151 silver badges6767 bronze badges  6  Thanks a lot for your clear explanation! May I ask how to modify the code so that one could successfully insert the node into the outside the function?  Well, as I commented before, its there in the accepted answer of the linked question.  Right... I did make it work and added it to the post. But if I understood your answer correctly when it passes into the recursive call, it will still assign to point to as a local variable to be destroyed by the end of that recursion call. So we are never going to be able to make changes beyond first recursion?  I'm referring to the part 'Now what happens is that we are at the end of the first recursive call and this function ends. Whenever a function ends, all the local variables are destroyed. That is root and node are destroyed. That is just these variables and not what they refer to.'  Your loop (which should be btw) keeps feeding new s into (which should be btw) so at some point both and of will have their own s. Then at the next call there will be an which passes one of the previously added s in, which becomes and then there is the possibility of that being modified, just as was.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  