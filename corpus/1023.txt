 Program to implement Hash Table using Open Addressing  The task is to design a general Hash Table data structure with Collision case handled and that supports the Insert(), Find(), and Delete() functions.  Examples:  Suppose the operations are performed on an array of pairs, {{1, 5}, {2, 15}, {3, 20}, {4, 7}}. And an array of capacity 20 is used as a Hash Table:  Insert(1, 5): Assign the pair {1, 5} at the index (1%20 =1) in the Hash Table.  Insert(2, 15): Assign the pair {2, 15} at the index (2%20 =2) in the Hash Table.  Insert(3, 20): Assign the pair {3, 20} at the index (3%20 =3) in the Hash Table.  Insert(4, 7): Assign the pair {4, 7} at the index (4%20 =4) in the Hash Table.  Find(4): The key 4 is stored at the index (4%20 = 4). Therefore, print the 7 as it is the value of the key, 4, at index 4 of the Hash Table.  Delete(4): The key 4 is stored at the index (4%20 = 4). After deleting Key 4, the Hash Table has keys {1, 2, 3}.  Find(4): Print -1, as the key 4 does not exist in the Hash Table.  Approach: The given problem can be solved by using the modulus Hash Function and using an array of structures as Hash Table, where each array element will store the {key, value} pair to be hashed. The collision case can be handled by Linear probing, open addressing. Follow the steps below to solve the problem:  Define a node, structure say HashNode, to a key-value pair to be hashed.  Initialize an array of the pointer of type HashNode, say *arr[] to store all key-value pairs.  Insert(Key, Value): Insert the pair {Key, Value} in the Hash Table.  Initialize a HashNode variable, say temp, with value {Key, Value}.  Find the index where the key can be stored using the, Hash Function and then store the index in a variable say HashIndex.  If arr[HashIndex] is not empty or there exists another Key, then do linear probing by continuously updating the HashIndex as HashIndex =(HashIndex+1)%capacity.  If arr[HashIndex] is not null, then insert the given Node by assigning the address of temp to arr[HashIndex].  Find(Key): Finds the value of the Key in the Hash Table.  Find the index where the key may exist using a Hash Function and then store the index in a variable, say HashIndex.  If the arr[HashIndex] contains the key, Key then returns the value of it.  Otherwise, do linear probing by continuously updating the HashIndex as HashIndex =(HashIndex+1)%capacity. Then, if Key is found, then return the value of the Key at that HashIndex and then return true.  If the Key is not found, then return -1 representing not found. Otherwise, return the value of the Key.  Delete(Key): Deletes the Key from the Hash Table.  Find the index where the key may exist using a Hash Function and then store the index in a variable, say HashIndex.  If the arr[HashIndex] contains the key, Key then delete by assigning {-1, -1} to the arr[HashIndex] and then return true.  Otherwise, do linear probing by continuously updating the HashIndex as HashIndex =(HashIndex+1)%capacity. Then, if Key is found then delete the value of the Key at that HashIndex and then return true.  If the Key is not found, then the return is false.  Below is the implementation of the above approach:  C  Output  Time Complexity: O(capacity), for each operation Auxiliary Space: O(capacity)  Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here.  We use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy Got It !  