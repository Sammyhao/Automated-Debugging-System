 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I tried to run it on another online ide where the code compiles and runs successfully but gives a wrong answer . in order to debug it I have inserted some lines into my code in order to print all the strings which are at a distance of 1 for my current string. surprisingly an empty string is appearing to be in the set. Please help me in understanding where am I doing a mistake.  You should configure an IDE locally and run it with a debugger attached. Using only online tools for development is a bad approach.  maybe not the current problem, but in you silently assume that is not longer than , if it is you are accessing out-of-bounds  definitely not the current problem: In many places you are making unnecessary copies. Passing parameters and , if I counted correctly the strings (eg ) are copied 3 times before they end up in the unordered_set  3 Answers 3  returns a value, and this returned value is important. You should not ignore it.  In your case, once you erase something from the set, is invalid. Trying to increment it results in Undefined Behavior.  The correct approach is to replace the current iterator with the returned one, then not increment during the loop.  in the solution suggested above it = st.erase(*it); still doesnt work . when i just use the iterator it = st.erase(it); the problem is solved .  @venkat Did you change to loop to not increment the iterator? Your solution declares a new variable.  @venkat An Iterator refers to an item in the set. If you remove this item from the set, the iterator no longer refers to an item in the set. Since the iterator no longer refers to an item in the set, correctly iterating to the next item in the set cannot be guaranteed. Some good, general reading on the invalidation of iterators: Iterator invalidation rules  Your problem seems to be already addressed, but if you'd be interested, this'd also pass without using , only using :  You might want to break it into more methods, a bit too long for a function.  References  For additional details, please see the Discussion Board where you can find plenty of well-explained accepted solutions with a variety of languages including low-complexity algorithms and asymptotic runtime/memory analysis1, 2.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  