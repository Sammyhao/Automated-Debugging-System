 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have recently implemented a min heap. My heap is not an array based heap. The heap features a method called where, given an element, it will change its value to a smaller one and re-adjust the heap accordingly.  In min heaps, finding an element will take O(n) time because the heap structure is unsorted. This would take too long, so I had a friend suggest that I back my data structure with a hash table. The HashTable's keys would be the data type of the keys inside the heap and the values would be the actual nodes inside the heap. So, when a user asks, for example, to , it will hash in the table, find the corresponding node, and decrease it to in constant time (O(1)).  The problem I'm having:  HashTables do not allow duplicate values; heaps (generally) do. I want my heap to be able to contain duplicate elements.  If I had the situation  is placed into the hash table and is inside of the heap. However, if I attempt to add , it will hash the same bucket as . and will be compared since they have the same hash code, and since they are exactly the same, will replace in the map, ruining my heap structure.  Possible solution  One option I have is to hash elements based on their pointers. For example, lies at memory address and lies at memory address . They will hash to different values and will not overwrite each other in the map. HOWEVER, the consequences of that would be disastrous, as then the following code would return  The above code would return false because and have different addresses and would hash to different buckets. That doesn't seem right, since the value of is clearly present inside the heap. should return . Not allowing duplicate values inside the heap feels wrong.  3,11544 gold badges2626 silver badges6767 bronze badges  5  The real question is why you'd want duplicate keys in your heap. The whole point of a key is for it to uniquely identify an item. You might want two items to have the same priority, but having two instances of the same item in your heap doesn't make much sense. You need to be storing keys, not priorities, in your dictionary.  @Jim Mischel Does it have to be a key value system? In Java's priority queue, you only provide an element, not a key + à value. I guess in my example the key and the value are the same  The key could be the object itself. It doesn't really matter how you do it, so long as you have a way to uniquely identify each item in the heap. Java's doesn't need a key/value system because it wasn't designed to let you find items in the heap.  @Jim Mischel is it a poor idea to have a heap that does not allow duplicate elements? Also, if I back the heap with a hashmap, of two heaps will go from being to because even though I can combine two Fibonacci Heaps in , I will have to combine the two hashmaps together. Is that a bad sacrifice? I'm not sure how often will be used in real world applications  You could store the number of occurrences of an object in the hashmap, and only store an object once in the heap. That way you don't lose information. You would have to adapt the heap implementation so that a pull from the heap will only remove the root node when its frequency drops back to zero, ...etc.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  