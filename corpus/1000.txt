 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I was wondering if it's possible to print a binary tree in breadth first order while using only O(1) space?  The difficult part is that one have to use additional space to memorize the next level to traverse, and that grows with n.  Since we haven't place any limitation on the time part, maybe there are some inefficient (in terms of time) ways that can achieve this?  4 Answers 4  This is going to depend on some finer-grained definitions, for example if the edges have back-links. Then it's easy, because you can just follow a back link up the tree. Otherwise I can't think off hand of a way to do it without O(lg number of nodes) space, because you need to remember at least the nodes "above".  Update  Oh wait, of course it can be done in O(1) space with a space time trade. Everywhere you would want to do a back link, you save your place and do BFS, tracking the most recent node, until you find yours. Then back up to the most recently visited node and proceed.  Problem is, that's O(1) space but O(n^2) time.  Another update  Let's assume that we've reached node n_i, and we want to reach the parent of that node, which we'll call wlg n_j. We have identified the distinguished root node n_0.  Modify the breath-first search algorithm so that when it follows a directed edge (n_x,n_y), the efferent or "incoming" node is stored. Thus when you follow (n_x,n_y), you save n_x.  When you start the BFS again from n_0, you are guaranteed (assuming it really is a tree) that at SOME point, you will transition the edge (n_j,n_i). At that point you observe you're back at n_i. You've stored n_j and so you know the reverse edge is (n_i,n_j).  Thus, you get that single backtrack with only two extra cells, one for n_0 and one for the "saved" node. This is O(1)  I'm not so sure of O(n^2) -- it's late and it's been a hard day so I don't want to compose a proof. I'm sure it's O((|N|+|E|)^2) where |N| and |E| are the size of the sets of vertices and edges respectively.  I'm not familiar with this IDDFS mentioned below, but if it works as advertised, that's a little better, O(lg lg #nodes).  @CharlieMartin: could you elaborate the second example a bit more? If you need to use BFS for each backlink, and for each backlink in that BFS also use a BFS, it seems like you will need more than O(1) space?  I still don't understand how this should work. Let's say you are 20 levels deep in your hierarchy at one point, and you need to backtrack back to 19th level. How can you "start the BFS again" and "at some point transition the edge" if all you have is an incoming node for a node in 20th level? What about all the other nodes you need to traverse before getting here? Consider this Wikipedia image, for example: you are at node "e" currently. How would your algorithm know that the next node to be printed is "f"?  You know where the root node is, no? If you don't, then change the algorithm to save the root node when you start; that adds only a constant amount of space, so it's still O(1). Now, every time you want to "backtrack", you start from the root node. You're guaranteed to find the node you're at again eventually (otherwise how'd you get there the first time?).  Heaps are binary trees for which every parent node has a value less than or equal to any of its children. This implementation uses arrays for which and for all k, counting elements from zero. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that its smallest element is always the root, . [explanation by François Pinard]  How a tree represented in memory (indexes of the array):  In this case nodes in the array are already stored in a breadth first order.  I know that this is strictly not an answer to the question, but visiting the nodes of a tree in breadth-first order can be done using O(d) space, where d is the depth of the tree, by a recursive iterative deepening depth first search (IDDFS). The space is required for the stack, of course. In the case of a balanced tree, d = O(lg n) where n is the number of nodes. I honestly don't see how you'd do it in constant space without the backlinks suggested by @Charlie Martin.  It is easy to implement a recursive method to get all the nodes of a tree at a given level. Hence, we could calculate the height of the tree and get all the nodes and each level. This is of the tree. But, the time complexity is . Below is the Java implementation (source).  This uses O(h) space where h is the height of the tree. The recursion is implemented using a call stack, which counts as auxiliary space.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  