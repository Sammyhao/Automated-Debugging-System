 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I come up with an algorithm to solve surrounded region problem posted at leetcode.  But the sad thing is my solution can pass with first judge input sets, but can not pass with the second larger input sets, and it reports run time error. However, I can run successfully on my laptop! I have spent hours on this problem, but I still have no idea!  Below is the problem.  Given a 2D board containing 'X' and 'O', capture all regions surrounded by 'X'.  A region is captured by flipping all 'O's into 'X's in that surrounded region .  @huseyintugrulbuyukisik, no, you misunderstand, it can work on my laptap with Ubuntun 12.04, but it cannot work on leetcode online judge platform. at least it cannot pass the test with the last one input.  2 Answers 2  I agree with one of the other answers, either you are using too much run time or stack space. Try this idea. Note that for a connected region of 'O', either the region touches the edge of the board, or the region is completely surrounded by 'X'. So you can use the following strategy. First go along the edges of the board until you find an 'O'. Then initialize a set CurrentBoundaryO to be equal to the set of just this one 'O', and initialize a set NextBoundaryO to be empty. Then iteratively do the following. Mark every location in CurrentBoundaryO to be 'unchanged O'. Then iterate through the elements of CurrentBoundaryO and check all neighbors. Every neighbor that is 'O' that is not marked 'unchanged O' should be added to the set NextBoundaryO. Then set CurrentBoundaryO = NextBoundaryO and repeat, until CurrentBoundryO has no elements. Then continue searching around the edges of the board, until you find a 'O' that is not marked 'unchanged O', and repeat the process. Keep repeating until you have traveled along the entire edges of the board. Then every 'X' is still an 'X', every 'O' marked 'unchanged O' is still a 'O', and all other 'O' on the board should be switched to 'X'. This strategy runs in linear time in terms of the input size, and it avoids recursion so there is no stack space issue either. This should pass the judge software evaluation.  this is exactly what I want to do. But maybe my method is not efficient enough....  In general online judges run on a completely different environment than the one on your desktop. The servers use commodity hardware, which mean cpu can be slow and memory small. Nothing prevent your code to be ran in a thread. Moreover you don't have control on level of optimization and compiler used.  The error is probably due to the recursive nature of the function. The runtime error imho is either or both due to an overflow of the stack or the program being killed because it took too much time to complete.  The function mark is pretty unintuitive and costly. First it is recursive with the maximum depth linear to the dimensions of the board. If the board has 1 million rows we will have  The stack may not be big enough.  Secondly each time you call mark each of the cell in the same row or column with be "visited" () several more times than needed. Let say the grid is nxn. If you call mark(x,y) the test above will be done n times for each of the positions on the row x and on the row y. Which means the complexity of mark is O(n^2). In general, it is O(#row^2 + #columns^2)  Then you have :  Your code has a worst running time of where n = max(row, cols).  ps: How do i come up with the complexity of mark?  mark(x,y) with lead to  in each of the mark the complete row is tested again. which make n calls to the function . Thus an n^2 complexity.  21.7k88 gold badges5555 silver badges8888 bronze badges  1  your explanation makes sense some way. But I only call mark() when the points are on the edges of the matrix. so it does not cost so much time as you say. and it reports run time error, not Time Limit Exceeded. However, I had better think about another way to do the job of mark(). thanks  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  