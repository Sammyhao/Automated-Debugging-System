 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to solve some problems from some paper exams and I have this problem:  Consider the graph G = (N,A) where N={a,b,c,d,e,f,g,h} and A is the following set of arcs: {(0,5),(5,4),(4,5),(4,1),(1,2),(2,3),(3,4),(4,3),(0,6),(6,7)} and I have to draw the depth-first search tree T for G with the root being 0  This is the graph:  I got the following tree:  and the answer is this one:  (for both cases above, please ignore the arrows) and I don't understand why. Anyone who can explain me what I'm doing wrong? Thanks!  1,27733 gold badges2424 silver badges4444 bronze badges  4  1  It depends on the order you traverse the vertices. Your solution firstly meets the nodes with minimum labels, "right" - vice versa  There seems to be a mistake; in the given supposedly 'correct' solution, there is an arc from to , but this arc is not present in the input! Please clarify on that. What are the dotted arc supposed to mean?  @Codor Yes, my mistake, I edited it now. The dotted arcs don't mean anything (it's because of the program I used to draw them)  w.r.t @restrest comments, then yes there might be an ordering followed while choosing the neighbors of current node. Normally, DFS pick up the neighbor in the order in which they are stored in the data structure used to store the information of edges. In the case of currently posted question, after visiting node 4 the neighbor which was picked up should have been node 3. Due to this, the tree shown in second diagram will be outputted.  1 Answer 1  Both trees are correct in the sense that both of them can be generated by depth-first search. To my understanding, the key point here is that for a given graph, several depth-first search trees may exist, depending on the sequence in which children of the current node are selected. More precisely, depth-first search, without any clear rule on how to iterate children, is not a deterministic procedure. As indicated in the comments, the solution found by you can be obtained by selecting a child with minimum node index, whereas the proposed solution can be generated by selecting a child with maximum node index.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  