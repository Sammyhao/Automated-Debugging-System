 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  How will I free the nodes allocated in another function?  I call the buildList function in the main()  I want to free head, second and third variables. Thanks.  Update:  Both prints 2. Shouldn't calling free(h) remove h. If so why is that h->next->data available, if h is free. Ofcourse the 'second' node is not freed. But since head is removed, it should be able to reference the next element. What's the mistake here?  Are you having problems in unlinking the elements, or freeing them? If the latter, you call with the returned value from .  user349433: This isn't HW, I tried with free(h) in main. Then if h is not there then how come h->next->data gives the value 2? So I asked. But free(h->next) should also be called. But then since h is the head, and after removing the head, I must not be able to reference head->next, isn't it. Where did I make mistake?  – user235273  Jun 20 '11 at 20:48  3  does not erase the content of the memory, it merely allows those contents to be reused later. The pointer remains valid as a coincidence because the memory you 'd has not yet been reused.  @jase21 Well Heath answered to this. It just works when you tried it, but it's not guaranteed that it will work in the future or by another machine. In another machine doing could get you a segmentation fault. Ok, let's say you have having the following data: , when you do you just let know the machine that in a future you can overwrite , that is not more used by your program. But the data seem to keep existing, that doesn't mean you should use them.  @jase21 Maybe in a future , where and is saved, something else will be written. And then when doing will get you a segmentation fault.  5 Answers 5  check if is NULL, if yes the list is empty and we just return  Save the in a variable, and make point to the next node on your list (this is done in  Now we can safely variable, and just points to the rest of the list, go back to step 1  4,89066 gold badges3535 silver badges5959 bronze badges  5  1  Just be sure the set the list head pointer to null after passing it to this function. In fact, it's a good idea to set each next pointer of each node to null before freeing the node, too.  @foobar If the data in the node was created using malloc too, would we have to free that BEFORE we freed temp? Like: free(tmp->data); free(tmp);  @Robert yes exactly! If you free'd first then tmp->data would probably point to garbage and you will get a seg fault.  Perhaps it would be better to pass the head pointer by reference and NULL the pointer directly in the FreeList function. So, it would be void freeList(struct node** head){blah; blah; *head = NULL;}. This would avoid the problem that David mentions.  You all are ignoring that a non NULL head pointer will not break the loop at all.  argg, recursion is nice on paper... but in reality it's memory and CPU demands is very costy compared to simple loops like I or jase21 did. Unwinding the stack is not cheap when you have 1328786 nodes.  @elcuco I agree actually. In a case like the one the question presents, it'll perform fine, but if you're looking at lists that large, there's no question a loop is going to put you in a better position.  This code is not tail recursive. (It s doing something after the recursion) And cannot benefit from tail recursion optimization  I think this function would cause an error if called on a node that is NULL. Maybe put a NULL check in the first line of the definition instead of checking if the next node is null?  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  