 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I don't understand how binary search trees are always defined as "sorted". I get in an array representation of a binary heap you have a fully sorted array. I haven't seen array representations of binary search trees so hard for me to see them as sorted like an array eg [0,1,2,3,4,5] but rather sorted with respect to each node. What is the right way to think about a BST being "sorted" conceptually?  3,42577 gold badges3535 silver badges6767 bronze badges  5  When building a BST, it's common to have lower elements from a method be on the left, and higher elements be on the right. In this way it will always be sorted  @phflack: More precisely, having "smaller" (whatever your definition of that may be) elements on the left is the way to construct a binary search tree. If you don't have such a structure, it'll just be a generic binary tree.  @AasmundEldhuset What stops a person from putting smaller elements on the right? All it takes is a sign being flipped  @phflack: You could flip your definition of "smaller", but sure, putting them on the right works too as long as you're consistent with it. The reason I commented was that to me, it sounds like your original comment implies that there is another valid way to organize a BST (since you're saying "it's common to have..."), which there isn't (except for the left/right difference, which I'd argue isn't really two different ways because you can redefine "smaller" instead).  4 Answers 4  There are many types of binary search trees. All of them have one thing in common: they satisfy an invariant which enables binary search, namely an order relation by which every element in the tree can be compared to any other element in the tree, in a total preorder.  What does that mean?  Let's consider the typical statement of a BST invariant in a textbook, which states that every node's key is greater than all keys in its left sub-tree, and less than all keys in its right sub-tree. We omit conflict resolution details for keys which compare equal.  What does that BST look like? Here's an example:  The way I would explain it to a class of three-year-olds, is try to collapse all the nodes to the bottom level of the leaves, just let them fall down. Or, for high-schoolers, draw a line from each node/key projecting them on the x-axis. Once you did that, it's obvious the keys are already in (ascending) order.  Is this imaginary and casual observation analogous to our definition of a sorted sequence? Yes, it is. Since the elements of the BST satisfy a total preorder, an in-order traversal of the BST must produce those elements in order (Ex: prove it).  It is equivalent to state that if we had stored a BST's keys, by an in-order traversal, in an array, the array would be sorted.  Therefore, by way of our initial definition of a BST, the in-order traversal is the intuitive way of thinking of one as "sorted".  37.3k55 gold badges7878 silver badges117117 bronze badges  2  Splendid explanation - however, it's the inorder (not preorder) traversal that produces the sorted sequence.  "The way I would explain it to a class of three-year-olds" the kind of explanation I needed. Thanks man!  2,86866 gold badges3030 silver badges6161 bronze badges  3  Thanks yeah that's clear to me, but I'm asking about a binary search tree. How is a binary search tree "sorted"?  Generally binary tree's aren't sorted for you. Ignoring my comment above, you have to sort a binary tree before you can search it because parts of the code involve traversing the left or right subtree based on whether or not the value of the left child is less than the value of the parent node, or if the right child's value is greater than the parent node's. Basically what I'm trying to say is that to use a binary search tree, it needs to be sorted beforehand so they that's why they define it as "sorted" for you.  Downvoting because 1) it doesn't answer the question and 2) it's misleading because the array of a heap is almost never sorted - only in very rare cases (like the one you've shown).  It is not "sorted" in the same sense an array might be sorted (and trees, except for heaps, are rarely represented as arrays anyway), but they have a structure that allows you to easily traverse the elements in sorted order: simply traverse the nodes of the BST with a depth-first search, and output each node's value after you've looked at its left child (if any) but before you look at its right child (if any).  By the way, the array in which a heap is stored is almost always not sorted. The heap itself can also not be said to be "sorted", because it does not have enough structure to be able to readily produce the elements in sorted order without destroying the heap by successively removing the top element. For example, although you do know that the top element is larger than both of its children (or smaller, depending on the heap type), you cannot tell in advance which child is smaller than the other.  as far as data structures are concerned (arrays, trees, linked lists, etc), "sorted" means that sequentially going through all it's elements you'll find that their values are ordered according to some rule ( >, <, <=, etc).  For arrays, this is easy to picture because it's a linear data structure. But trees are not, however, iterating through a BST you will notice that all the element are ordered accoring to the rule left value <= node value < right value ( or something similar); the very definition of a sorted data structure.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  