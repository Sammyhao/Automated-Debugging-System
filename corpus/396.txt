 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  My program goal is to search for a tree node with a given key using depth-first search and if a node with that key is found it will be returned to the caller function. The problem is that accessing the node after DFS execution terminates the program with a segmentation fault, exactly when it searches for a node in the right subtree, but not when searching on the left subtree.  1 Answer 1  Your function does not always return a value. If is you should return .  Your compiler should be warning you about this! If it is not, then change your compiler settings, or get a better compiler.  Edit: Also - you should check that is not before you try to use it.  Edit2: Didn't see this bit  The second call to preOrder will never be called (because you have already returned), so you are never searching right hand nodes. You need to change the logic so it search on the right hand node if the left search returned nullptr.  8,24311 gold badge1414 silver badges1919 bronze badges  5  Ok, it makes sense that the second preOrder on the right subtree will never be called, but where to check if left subtree returned a nullptr?  Instead of returning the result of the left subtree immediately, store it in a local variable. Then if the variable is not , return it, otherwise check the right subtree as you are doing now.  I think a simpler way to find the node is to have a global variable of type node* (for example res) and in preOrder if (srcNode->data == key) then res = srcNode. Then preOrder calls don't need to be returned.  But that would also mean that if you found the node, you would keep looking through all the rest of the nodes in the tree. Also, using a global variable would make it harder to use this function in a larger program, especially a multithreaded program). This may not be an issue right now, or ever, for this program, but is good practice.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  