 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  i have implemented a simple DFS (non recursive) that 'tests' if a Path between StartNode and EndNode exists. It works as expected ( handling bidirectional/directional graphs ) - but i just can't figure out how to store the Path for later usage.  Currently i am debug-printing Visited nodes, but it's not what is should be storing.  Can somebody please help me out / shed a bit of light on - what exactly should i store and at what point to return a list of nodes from NodeStart to NodeEnd ?  2 Answers 2  If I understand your algorithm correctly (and it is a DFS), from the starting point you are taking a step to the direction of the first non-visited node. If there is no route to your target from that node, you step back and try to go to the next non-visited node, in the mean time carefully administrating which nodes were visited.  All you need to add is a stack to which you always push the node you are taking a step to, and pop it from the stack if you had to step back. This stack will store your route from the start_node to the target. It also helps you to determine where to step back.  Here is your code, finally it grew a bit lengthier than I've thought but here it is:  And now you can your way from start to target or your way from target to start. If the route is empty, that corresponds to returning false from your original function.  Reference on unordered_set and stack, both in STL. It is implemented with a bucket has so it is much faster than set or map, which are usually implemented with red-black trees.  Remark: is a C++11 extension, feel free to replace it with the slower if you use C++03.  Well, instead of having a set - you can have a map (map:Vertex->Vertex).  Modify the map while you traverse the graph, such that if you discovered node from node , add . Init .  Now, all you have to do is iterate (pseudo code):  It will give you the path in reversed order. You can store into to a stack (instead of the print statement) and iterate the stack if you want to achieve the original order of the path.  @BarnabasSzabolcs: Maybe, but: (1) The advantage is minor because you are keeping a set anyway. I am not sure set + stack should be much more efficient then a map. (2) Using a map has some very important advantages over stack, mainly robustness. This approach fits well all graph discovery algorithms (like BFS), and lets you change the implementation from DFS to BFS with almost no effort, which is an important aspect.  Point taken on the first argument and I agree that BFS needs parent map (if you return when you've found a route, you may not want to return it). <br /> On the second argument: what do you mean by the stack not being robust?  I recommend you to consider using . It is of O(1) complexity whereas is of O(log n) at search/insert.  @BarnabasSzabolcs: I mean that a generic loop + collection traversal can be easily changed from DFS to BFS by simply changing the collection from stack to a queue. However, the stack solution does not fit well a BFS if you want to get the actual path, while a map does. Hope I am clear enough... If not, open a chat and I'll try to elaborate.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  