 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  My program undergoes a run-time error every time I uncomment l70-72 . It's not the first time I encountered this particular problem.  I make a pointer to an array of objects, send that pointer into a function, try to execute commands defined in that function in main and get a run-time error, all whilst using heap. Something clearly happens with that pointer, or with the pointers in the array.  An error occurs when I call with any of the following: "fill array", "get areas" and "empty contents" (obviously the last two are related to "fill array" in nature, since they need it to be executed first in order to function)  37711 gold badge33 silver badges1414 bronze badges  4  2  If you edit the minimum possible code that demonstrates the problem into the question then this question can get migrated to Stack Overflow. In it's current state I won't let it get migrated.  You are missing the point. Include the code in the question not as a link to an external site.  I tested your code. Using Visual Studio 2010 the code crashes just with uncommented. This is because you try to delete a non-allocated memory area.  Because you have added code I feel it is good enough to migrate to SO now. You should get better answers there.  2 Answers 2  Fundamentally, there are two things wrong with this code, besides the call-by-value issue that Max pointed out.  The first error is that you aren’t using functions properly, and abusing a string to give commands.  The second error is that you are using pointers. Every single C++ course gets this wrong. Pointers have no place in most C++ code. Don’t get into bad habits.  Corrected and simplified, the code should look as follows:  With the two methods:  Note in particular how there’s no more use for “empty contents” and “delete array”. Just two benefits from not using pointers.  498k122122 gold badges902902 silver badges11661166 bronze badges  5  Well, I guess our instructors are idiots then. Figured as much. ;) My philosophy is: the cleaner the code, the better the code. That's why I'm not a big fan of LISP-based languages (so hard to read). Thanks, I'll study your answer in detail, Konrad. Right now my head hurts due to all the pointers. :(  to be fair, sometimes a tutorial exercise can be artificial as the tutor is trying to get you to understand the problem. Its not "real-world" code solutions. If this was to force an understanding of pointers, then this answer get a F. (even if I'd write it like the answer in my job).  @gbjbaanb If this was to force an understanding of pointers, then the instructor has failed abysmally. This is simply not a legitimate situation for pointers, and I’m getting increasingly vocal about this since so much crap code in C++ is caused by use of pointers.  @Max if by the 'string lookup' you mean "toString", that thing is being taught in the written course explicitly (and was asked for in that particular assigment, even though it wasn't needed), so yeah, pretty much, if you're referring to "toString" data member.  Even though this seems to get alot of downvotes, I'll try to provide a helpful answer. :)  Your array is of type - that is, a pointer to a pointer of a rectangle. You send this by value into a method. This means that the value of in your original method will be copied into the variable in . Thus, when you assign a value (the address of the memory area / array) will only contain this value in the called function - since these are completely different variables.  If you instead declare manage_Rectangle_arr as  That variable / memory area will be sent by reference, which means it will be another , automatic, level of indirection. You could accomplish this by having a variable of type Rectangle*** and dereferencing the variable , but this quickly gets silly.  There are also many other 'not-best-practices' in your code, but I won't talk about them all here. :) Hopefully this will help you get back on track!  4,21388 gold badges3434 silver badges6363 bronze badges  3  Hmm, I don't like calling by reference, any way to get it to work by calling by pointer? P.S.: calling by reference does indeed work.  – Crawling Pasta Hellion  Mar 19 '12 at 12:48  I'll try the triple-star method, triple-starred cognac is usually better than double- and single-starred one anyways ;)  – Crawling Pasta Hellion  Mar 19 '12 at 12:54  @CrawlingPastaHellion Go ahead, it's better if you figure it out on your own than having me tell you... As long as your not just randomly interchanging symbols in your source code :) Just try to incorporate the operator. Hint: You don't need it declared as Triple-Star everywhere ;)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  