 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am attempting to make a maze-solver using a Breadth-first search, and mark the shortest path using a character '*'  The maze is actually just a bunch of text. The maze consists of an n x n grid, consisting of "#" symbols that are walls, and periods "." representing the walkable area/paths. An 'S' denotes start, 'F' is finish. Right now, this function does not seem to be finding the solution (it thinks it has the solution even when one is impossible). I am checking the four neighbors, and if they are 'unfound' (-1) they are added to the queue to be processed.  The maze works on several mazes, but not on this one:  1,45522 gold badges1515 silver badges2222 bronze badges  1  just a comment that is not related to your question - you will never delete neither prd nor bfsq as you have written the code.  2 Answers 2  Iterating through neighbours can be significantly simplified(I know this is somewhat similar to what kobra suggests but it can be improved further). I use a moves array defining the x and y delta of the given move like so:  Please note that not only tis lists all the possible moves from a given cell but it also lists them in clockwise direction which is useful for some problems. Now to traverse the array I use a This way the current position is defined by the pair of coordinates corresponding to it. Here is how I cycle through the neighbours of a gien cell c:  I know this code is not really related to your code, but as I am teaching this kind of problems trust me a lot of students were really thankful when I showed them this approach.  Now back to your question - you need to start from the end position and use prd array to find its parent, then find its parent's parent and so on until you reach a cell with negative parent. What you do instead considers all the visited cells and some of them are not on the shortest path from to .  You can break once you set this will optimize the algorithm a bit.  I personally think you always find a solution because you have no checks for falling off the field. (the bit in my code).  Hope this helps you and gives you some tips how to improve your coding.  65.7k1515 gold badges115115 silver badges166166 bronze badges  10  Not having learned queues yet I'm unfortunately a bit confused by your guidance. What exactly do 'ti' and 'tj' represent in your example?  Actually the code snippet I give has nothing to do with queues. I only show how to iterate the neighbours of a cell. is the current cell and the coordinates of its candidate neigbour are I compute those to verify that they do not fall off the field. Hope this makes it clearer.  so "n" and "m" would be the number of rows and columns, for instance? You're determining whether or not the coordinates are inside the range of the maze, correct?  Thanks for your help, the program now works on several test mazes, but not one of them (see original post). Any thoughts?  It seems your code should be OK now. What I notice is that your board is rectangular so one wild guess is that you may be passing wrong rows and cols values(i.e. swapped values). In your example rows should be 10 and cols 12.  You can use queue container in c++, its much more easier in use  In this task you can write something like that:  And then you simple can iterate through all four sides, you shouldn't copy-paste the same code.  You will have problems with boundaries of your array. Because you are not checking it.  When you have founded finish you should break from cycle  And in last cycle you have an error. It will print * in all cells in which you have been (not only in the optimal way). It should look:  And of course this cycle should in the last if, because you don't know at that moment have you reach end or not  PS And its better to clear memory which you have allocate in function  1,08511 gold badge1111 silver badges1414 bronze badges  4  Could you clarify your function to fill in the '*' for the chosen path? It doesn't seem to work and I'm not clear I understand what you are intending.  this part of code looks ok, maybe you still have some errors in your code. In your code you are trying to put * in all cells which you have visit in BFS, in my code I returning back from last vertex to first vertex using array prd. So i'm putting * only in one path.  I just edited my original post to reflect my latest attempt - however, it has two issues: it marks spaces that shouldn't be part of the path (different than it used to, but still wrong) and after the code runs, I get an error stating "glibc detected *** ./maze: double free or corruption (out)." Do you have any guidance?  Thanks for your help, the program now works on several test mazes, but not one of them (see original post). Any thoughts?  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  