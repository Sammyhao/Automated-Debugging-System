 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am working (in Java) on a recursive image processing algorithm that recursively traverses the pixels of the image, outwards from a center point.  Unfortunately, that causes a Stack Overflow. So I have decided to switch to a Queue-based algorithm.  Now, this is all fine and dandy- but considering the fact that its queue will be analyzing THOUSANDS of pixels in a very short amount of time, while constantly popping and pushing, WITHOUT maintaining a predictable state (It could be anywhere between length 100, and 20000), the queue implementation needs to have significantly fast popping and pushing abilities.  A linked list seems attractive due to its ability to push elements onto itself without rearranging anything else in the list, but in order for it to be fast enough, it would need easy access to both its head, AND its tail (or second-to-last node if it were not doubly-linked). Sadly, I cannot find any information related to the underlying implementation of linked lists in Java, so it's hard to say if a linked list is really the way to go...  This brings me to my question. What would be the best implementation of the Queue interface in Java for what I intend to do? (I do not wish to edit or even access anything other than the head and tail of the queue -- I do not wish to do any sort of rearranging, or anything. On the flip side, I DO intend to do a lot of pushing and popping, and the queue will be changing size quite a bit, so preallocating would be inefficient)  6,2541111 gold badges4646 silver badges6565 bronze badges  2  Maybe you need to step back and think about if there is a better way than pushing thousands of individual pixels one by one into a data structure (if that is indeed what you are doing).  It's a blob detection algorithm, the idea is that it starts from a point on the blob and traverses outwards to the edge of the blob. I do not believe there is any other (simple) way of doing this. Also, the queue just stores points of interest -- It doesn't actually keep the pixels in the queue, the queue mainly just serves as a way of keeping track of where it is. Similar to many pathfinding algorithms  9 Answers 9  You can use to append an element to the end of the queue and to dequeue and retrieve the head (first element) of the queue.  Java defined the interface , the LinkedList provided an implementation.  It also maintains references to the Head and Tail elements, which you can get by and respectively.  credit to @Snicolas for suggesting queue interface  5,47444 gold badges4141 silver badges5454 bronze badges  2  4  I would prefer using the methods implemented by the linkedList : add to enqueue and poll to dequeue.  My answer to this question talks about that, please see below. It is not recommended to use LinkedList, but to instantiate it as Queue interface... see below.  If you use LinkedList be careful. If you use it like this:  then you can violate queue definition, because it is possible to remove other elements than first (there are such methods in LinkedList).  But if you use it like this:  it should be ok,as this is heads-up to users that insertions should occur only at the back and deletions only at the front.  You can overcome defective implementation of the Queue interface by extending the LinkedList class to a PureQueue class that throws UnsupportedOperationException of any of the offending methods. Or you can take approach with aggreagation by creating PureQueue with only one field which is type LinkedList object, list, and the only methods will be a default constructor, a copy constructor, , , , , and . All those methods should be one-liners, as for example:  Check out the Deque interface, which provides for insertions/removals at both ends. LinkedList implements that interface (as mentioned above), but for your use, an ArrayDeque may be better -- you won't incur the cost of constant object allocations for each node. Then again, it may not matter which implementation you use.  Normal polymoprhism goodness comes to play: the beauty of writing against the Deque interface, rather than any specific implementation of it, is that you can very easily switch implementations to test which one performs best. Just change the line with in it, and the rest of the code stays the same.  It's better to use ArrayDeque instead of LinkedList when implementing Stack and Queue in Java. ArrayDeque is likely to be faster than Stack interface (while Stack is thread-safe) when used as a stack, and faster than LinkedList when used as a queue. Have a look at this link Use ArrayDeque instead of LinkedList or Stack.  If you know the upper bound of possible quantity of items in the queue, circular buffer is faster than LinkedList, as LinkedList creates an object (link) for each item in the queue.  Deque operation takes O(n) time in worst case and a queue data structure should take constant time for insertion and deletion.This is a naive implementation of a queue and please avoid it.  Just a small correction, the dequeue method should return a 'T'. A Node is the internal implementation of the Queue and should not be available outside the Queue implementation.  However, if you still want to use the recursive algorithm, you can change it to be "tail-recursive" which probably is optimized in the JVM to avoid stack overflows.  Yes you are right as tail recursions will overcome the stack overflow errors. I know that Tail Recursion is supported in a language like Scala itself to do optimizations. However I doubt whether the Tail recursion is not supported in Java. Please correct me if I'm wrong.  The JVM could support something much more general with special opcodes, and the Java compiler could implement it directly under pretty restricted conditions. There's a wishlist item, but it never made it to actual implementation in the past, though it may make it in the future. -- Also, you shouldn't recommend relying on an optimization that "probably exists", particularly not if the presence/absence of the optimization will make the program work resp. crash.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  