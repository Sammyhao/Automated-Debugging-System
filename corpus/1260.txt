 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I started using WinDbg to debug VB6 runtime errors but can't really get it to work, all I need is to know the source of the error (the procedure where the error comes from).  I created a small app to test and made it to throw an overflow runtime error like this:  I compiled it with "Create Symbolic debug Info" option checked to create the PDB file.  Then I attached the application to WinDbg and clicked the button to throw the error, but when I check the call stack I don't find any trace of the procedure. All I get is the following :  Note that WinDbg doesn't break on the error, so I manually break into it after I get the error message and before clicking OK, because if I clicked OK, the application closes.  I'm new to WinDbg but I read that it should break on error but it doesn't, all I get is "First chance Exception" and I don't get a "Second chance Exception" when I click OK and let it crash.  I think that somehow WinDbg considers that VB6 handled the error even though it didn't handle it. Is there something I'm missing here? How can I get the trace of the error to the calling procedure?  1,78911 gold badge1212 silver badges1515 bronze badges  2  Here's a 2006 blog post by a Microsoft guy about using Windbg with VB6. Can I ask why you have to use WinDbg? Other options are VB6's own debugger or later versions of Visual Studio  I already read that and others but it doesn't help about my problem, i don't have to use WinDbg, I even tried msvc++ debugger but same problem, what I need is to be able to detect the source of the error (the procedure) when a client calls and complains about unhandled error in my app and I can't get enough informations from him to know where the error could be.. So i plan to make the app take a dump image when there's an error and analyze it with the debugger.  1 Answer 1  Running the application in VB6 itself results in a VB6 runtime error 6, which stands for "overflow".  First chance exception  Running the application under WinDbg (6.2.9200), I first see a  which is probably the most common VB6 exception. By default, WinDbg does not break on first chance exceptions of this type. If you want it to do so, you need to enable that explicitly by  Second chance exception  The first chance exception is followed by a message box  This message box is the first indicator that the exception must have been caught, otherwise there would have been a second chance exception immediately afterwards.  And in fact, VB6 creates an exception handler:  At you see that VB6 is working with . is the beginning of a try/catch block. At it stores 0x3E8 (hex) or 1000 (dec) to ECX. That's where your code is.  After confirming the message, the process terminates, but not due to a second chance exception but because of an call. That's the way VB6 "handles" exceptions.  Symbols  To see if the symbols have been loaded correctly, type (list modules). It should look like this:  If you see , the symbols have not been loaded yet. Type to load them.  With symbols, you can set breakpoints by first finding the method with and then setting a breakpoint :  But a breakpoint is not what you wanted...  Why the method is not on the call stack  Unfortunately enabling first chance exceptions and loading symbols does still not help seeing the method on the call stack at the time the exception is thrown. It's somewhere in :  Have you noticed the warning about the stack unwind information? Let's look at the stack manually:  I guess you can't do anything about it. VB6 is not very good in creating symbols and also not in maintaining a nice call stack.  47.4k1818 gold badges106106 silver badges192192 bronze badges  6  Whether this is a blessing or a curse is in the eye of the beholder. As a developer I appreciate everything VB6 does (by intention or by quirk) that helps defeat cracking and other reverse-engineering efforts. If you seek a soft target look to .Net code.  @Bob77: interesting point of view. Did you try C++ on x64? That's a totally new calling convention. Things are passed in registers and can be optimized by the compiler. Quite hard to get things right.  Well explained..but can you tell me what does the command exactly do? And how can it work with dumped image.. Or if its not.. Is there a way to get the last method called of my application (not api) out of the dumped image?  @MohamedGharib: is the command for "dump pointer-sized data and resolve symbols". refers to a register which points to the stack ("extended base pointer")  @ThomasWaller: Thanks for the explanation.. I tried it on a dumped image and didn't work so i gave up the idea of WinDbg although i really wanted it to work and now i'm working on some kind of CallStack for vb6 to help me debugging the unhandled errors.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  