 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  The DFS algorithm is already working with small test cases, but when I run it with a huge sample it throws "RuntimeError: maximum recursion depth exceeded", so I included and the system throws this message: "python.exe stopped working" and PyCharm throws the message: "Process finished with exit code -1073741571 (0xC00000FD)". You can download a zip file of the sample.  Code:  Is there any way of achieving this without taking away the recursion?  2 Answers 2  One of the cool things about Python is that iterators are just a normal datatype. Although one usually uses for loops and comprehensions to iterate, there is nothing to stop you from doing the iteration manually if that is convenient. One reason it might be convenient is to avoid deep recursion, by replacing it with an explicit stack.  While this does "take away the recursion", it does not significantly complicate the program, and the recursive structure is still evident. Python simply does not recurse gracefully, so this sort of transformation is often useful.  When you write  You're doing something very similar to the following:  [See Note 1]  The function returns an iterator for a collection (or other iterable object, such as a comprehension, a generator, or a range). The method returns the next value, and advances the iterator; if there is no next value, a exception is raised.  The DFS function simply calls itself recursively for every unvisited child of its argument. We can emulate that behaviour precisely using a stack of iterators. Instead of recursively calling with a node, we'll push an iterator to the node's children onto the iterator stack. When the iterator at the top of the stack terminates, we'll pop it off the stack.  The above function applied to the sample data in the file provided in the OP used a maximum of 62794 stack slots. On my Linux laptop, it took somewhere around 3 seconds, once the data was read in; I didn't time it precisely.  It's also interesting to note that the above can be changed to do a breadth-first search simply by changing the stack to a queue. For a depth search first, the stack must be a stack of iterators (or equivalent, in languages in which that is not so simple); for breadth-search first, the queue may be a queue of iterators, but it would work as well to use a queue of values.  Notes  The actual virtual machine uses the defined iterator protocol, which varies slightly between Python2 and Python3. In both versions, the container (or other iterable) objection has a member function called which returns a newly created iterator object. The iterator object has a method called in Python2 and in Python3, which returns the current value and advances the iterator. Since 2.6, you can use the and global functions to avoid having to worry about these details, and that's what I've done here.  212k2424 gold badges209209 silver badges305305 bronze badges  3  good answer, In fact you solved other question that I had about How implement DFS with a Stack, thanks. Just to clarify that xrange() was renamed to range() in Python 3(see more here stackoverflow.com/questions/17192158/…) and as you see in my tags I use python 3.4  @GuillermoAyranTorresLores: That's exactly why I included the comment ` # In Python3, you need to use range instead of xrange `. Sorry for not noticing the tag.  The default recursion limit (at least on Windows) is 1000. I have set it as high as 10000. That should be enough for a graph with any degree of branching. The maximum depth for a linear chain graph is the number of nodes. So try something less than 1000000.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  