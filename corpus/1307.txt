 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  SITUATION: I have a TreeSet of custom Objects and I have also used a custom Comparator. I have created an iterator to use on this TreeSet.  QUESTION: Well I want to know that if I add a new element to the TreeSet within the while loop, then will that new element get sorted immediately. In other words, if I add a new element within the while loop and it is less than the one which I am currently holding in c, then in the next iteration will I be getting the same element in c as in the last iteration?(since after sorting, the newly added element will occupy a place somewhere before the current element).  7 Answers 7  If you add an element during your iteration, your next iterator call will likely throw a . See the fail-fast behavior in TreeSet docs.  To iterate and add elements, you could copy first to another set:  or create a separate collection to be merged with after iteration, as Colin suggests.  13.6k55 gold badges3535 silver badges4848 bronze badges  4  3  Could also queue elements to be added in another collection and then add them all after you finish iterating, rather than copying up front.  Ok, then please tell me how to do the following: 1. I need a data structure which can keep itself sorted. I have used TreeSet.Ok? 2. Next, I will be using a custom comparator for the TreeSet since it is made up of custom objects. 3. Next I want to superimpose two TreeSets based on the value of a particular entity. The TreeSet is made up of custom objects and one of the entities in an object is time. If the time of one element of a treeset is less than the other, then i copy that row into the other. how to do this?  Thanks. But is there any elegant way of superimposing two TreeSets of similar custom elements? I have a custom class consisting of an interger a, string b, integer c, double d. now i have created treesets containing objects of that custom class. i have two such treesets. what i want is to go though each element of two treesets and superimpose the elements of the two treesets, according to which one has the entity c lesser.  I'm not sure I understand your requirements--how do you know which two elements of the sets to compare? In any case, it sounds to me like you're traversing the two input sets to create a third set, rather than modifying the originals.  You will get a java.util.ConcurrentModificationException if you add an element into the TreeSet inside while loop.  Output  This will come to all collections like , , Because when iterator starts it may be putting some lock on it .  if you iterate list using iterator then this exception will come. I think otherwise this loop will be infinite as you are adding element whole iterating.  obviously I have enough grey matter to understand that it would be infinite...so I would have obviously used some condition based on which new elements would be added.but does TreeSet use get(i), where i is an index? i don't think so.  In order to avoid the you might want to check out my . I have even added a new test case showing how to add elements during a loop. To be more exact, you mark new elements for a later, deferred update of the set. This works quite nicely. Basically you do something like  To prevent the ConcurrentModificationException while walking. Below is my version to allow high frequency insertion into the TreeSet() and allow concurrently iterate on it. This class use a extra queue to store the inserting object when the TreeSet is being iterating.  While the question has already been answered, I think the most satisfactory answer lies in javadoc of TreeSet itself  The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.  Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, >generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.  To avoid the concurrent modification error that's bound to occur when you're doing the insertion, you could also create a temporary copy of the Set, iterate through the copy instead, and modify the original.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  