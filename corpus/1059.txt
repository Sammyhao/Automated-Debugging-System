 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Mergesort, quicksort are probably most known nlogn sorting algorithms. Their explanation and c++ code examples in most cases contains recursion. But as far as I understand about recursion when it will be big amount of data we run big risk of stack overflow. So is it reasonable to ignore recursion explanation about sorting algorithms as such that can't be use in real life?  41311 gold badge44 silver badges1111 bronze badges  4  Recursion is bad if you have n levels. If you can break the work into two recursive calls (half the data) or more then you avoid the problem of stack overflow.  I don't think you can cite anything in the field of programming which is "always bad". (Well, some argue that installing Windows on a machine may be an example, but that's another question.)  – user529758  Jan 30 '13 at 14:50  Recursion is something to use when it is needed. In some cases, including several sort algorithms, the recursive code is much simpler and cleaner than any alternative representation, and the maximum depth is reasonable.  The risk of stack overflow exists only in poor implementations that allocate a lot of memory as local variables, like pass-by-value arrays in Pascal. The depth of the recursive calls is not a problem if the recursive function only allocates 2-3 pointers on the stack.  4 Answers 4  But as far as I understand about recursion when it will be big amount of data we run big risk of stack overflow.  It depends on several things:  Tail calls are nearly always optimized these days, so you would never hit stack overflow with tail recursion, even if you recurse times (the algorithm would still be slow, but it wouldn't overflow the stack).  Most sorting algorithms recurse down times. This comes up to 40 levels per terabyte of data being sorted - not enough to overflow a stack of anything capable of holding a terabyte of data in its memory.  is it reasonable to ignore recursion explanation about sorting algorithms as such that can't be use in real life?  No, it is not reasonable to ignore these explanations: if an algorithm is logically recursive, the best explanation will also be recursive. Even if you implement the algorithm with a loop that uses a dynamically allocated stack to avoid stack overflows, the nature of the algorithm would remain recursive, so the best way to understand what's going on is to pretend that a recursive call is made.  With sorting algorithms, the call stack height incurred by the recursive algorithm is usually (Assuming relatively balanced division of problem size at each recursive iteration)  The exception occurs in the worst-case scenario of quicksort on a naive implementation that always uses the last element as the pivot when the array is already sorted, In which case you would have a run time and incur a call stack height of .  (If it helps you visualize: this is somewhat analogous to the rationale behind DFS using less space than BFS - the former only keeps track of one "search path" in the call stack at a time, whereas the latter keeps track of all of them)  In a algorithm, we're typically looking at levels of recursion.  To give a concrete example, , so hardly a major risk of stack overflow.  Things do get problematic if recursion depth is allowed to grow as, say, . A scalable algorithm would need to ensure this doesn't happen.  As others have pointed out, the depth of the stack is equal to the deepest level of recursion which typically is order log(n).  The "problem" with recursion is generally the overhead involved in making a method call and passing parameters. For example consider a factorial method  int factorial(int k) {if (k==1) return 1 else return k*factorial(k-1);}  If you call this with n=21 then you do 20 multiplications, but you also have the overhead of setting up and returning from 20 method calls - a lot more work. If you do want to use a recursive algorithm, you may be able to set up a private stack and use a while loop to implement the algorithm without lots of (comparatively expensive) method calls. Of course, the improvement (if any) will be language specific.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  