 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a book that explains the theory behind binary search tree in a very bad way i know that there is something about the order of both left and right child but i still cannot get the idea about one being greater than the other previous level.  Take for example this tree of strings:  (sorry for my paint) this example is taken directly from my book :)  Could someone explain the order to me ? what is the logic behind this?  17.6k6969 gold badges183183 silver badges317317 bronze badges  1  2  If there really are two nodes in the example tree, then it is technically not a BST, because duplicate nodes are not allowed.  5 Answers 5  In a BST every node has at most a left child and a right child. Every node on the left of a given node is smaller than it, and every node on the right of a given node is greater than it. One of the consequences of this is that you can't have duplicate values, so I'm not sure if that example is exactly how the book has it.  In the example you have, the strings are ordered alphabetically. Taking the root node as an example, Bob comes before Karen, so Bob goes on Karen's left. Tom comes after Karen, so Tom goes on Karen's right. Looking at the tree as a whole, you can see that every node on Karen's left (Bob, Alan, Ellen) comes before Karen alphabetically and every node on Karen's right (Tom, Wendy) comes after Karen alphabetically. This pattern is the same no matter which node you look at.  See my comment on @irrelephant's answer. It is not sufficient that every node's left is < parent, and every node's right is > parent to define a BST. Your third sentence does not necessarily follow from the second and first without defining every node's left/right subtree as being less/greater than the parent.  For any node (Karen - the root - for example), every node in the left subtree (Bob, Alan, Ellen) is lexicographically smaller than Karen, and every node in the right subtree (Tom, Wendy) is larger than Karen.  The 2nd Karen shouldn't be there, as @mellamokb points out in the comments.  As such, you can binary search this tree in O(log N) time as you would a sorted array.  4,05122 gold badges2323 silver badges4141 bronze badges  1  1  The second does not necessarily follow from the first. For instance, if the root was , then left from was , then right from was , it would satisfy your first condition, but not the second. It is necessary that a BST be defined as having all nodes in the left/right subtree being less/greater than the parent node.  In your example, they meant the order of the first symbol in each name.  If you see, the name order from left to right, is from the first character in ABC to the last.  Also, there is a special case with the second occurrence of Karen name - The default behavior in this tree, if same data entered, is "move right", then Karen compared to Tom -> K is "smaller" the T, so it gets left from it.  Everything in the left branch is alphabetically ordered < the current node.  Everything in the right branch is alphabetically ordered > the current node.  This provides a couple of unique properties  You can find any node by simplying going left or right based on whether the key you are searching is lexicographically < or > than the current node. You will either arrive at the destination, or a non-matching leaf node (in which case the key doesn't exist), and in time.  An in-order traversal gives all the keys in alphabetical order.  I think this article bellow will be very helpful for you on understanding the concepts of binary tree, it also provides common code samples in C/C++ and Java:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  