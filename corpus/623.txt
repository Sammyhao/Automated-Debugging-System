 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I wrote a typical producer-consumer program: one producer, which is responsible for filling the queue; one consumer, which is responsible for dequeuing the queue. Below is my implementation.  The tricky part is that there is another sharing variable vFlag. the process(str) may change its value to true, which will be detected by the producer thread, and cause emptying the queue.  Right now, there is still some bug. Could anyone give me some clue or suggestions in general, like a better concurrent programming philosophy or mechanism to avoid the concurrency bugs?  For above implementation, the program sometimes reports an err in process(str, vFlag):  In other cases, the program runs normally. If I comment out the queue.clear(), it works well.  Also, please include more code. There are a bunch of declarations missing, such as those of variables, and whatever PQueue is. If you can't post the whole thing, post a synopsis. Is this homework? It looks an awful lot like a homework problem.  2 Answers 2  For a generic thread safe queue you can use ConcurrentLinkedQueue or if you want to limit to one object in a queue at a time SynchronousQueue finally if one object at a time, but precalculate the next object can be done with ArrayBlockingQueue.  The Java memory model allows for effective caching of values, as well as reordering of instructions by a compiler assuming that reordering would not change the results if just one thread were running. As such the producer is not guaranteed to ever view vFlag as true, as it is allowed to use the cached value. Thus the consumer thread sees vflag as true, and the producer sees it as false. Declaring a variable as volatile means that JVM has to look up the value each time, and produces a memory fence between on either side of the access which prevents reordering. For instance  The consumer may continue to access the queue after it sets vFlag true, either the consumer should clear the queue itself, or it needs to wait for a signal from the producer that the queue is cleared. Even assuming value was volatile, it would still be acceptable operation for the program to consume all of the input in the queue after vFlag.value got set true, before activating the producer and clearing the queue.  Additionally your queue structure assumes only one thread is writing and one thread is reading, by having the producer clear the queue, the producer is effectively reading from the queue and breaking your invariant.  For your error specifically I imagine that what is happening is that the consumer tells the producer to clear the queue when the queue is empty and then tries the queue again, the queue is still empty so it waits. The producer then wakes up, fills the queue, this wakes up the consumer, the producer then clears the queue, the consumer starts going and polls the queue, however the queue is empty. And so NULL is returned. In other words  In this case you would need to do change PQueue.poll to  but this is not a good solution as it still has all of the other bugs mentioned earlier. Note: This only allows two threads to read from the queue, it does not protect against multiple threads writing to the queue.  Edit: Noticed another race condition, the Producer may put "end" into the queue, the Consumer read and process it, and then the Producer updates exitFlag. Note that changing exitFlag does not fix anything as it has nothing to do with reading stale data. Instead of using an exitFlag, you should have the Consumer also break when it reads "end".  the situation you describe is exactly a problem. To avoid this situation, I tried to exchange the queue.add() and the code block containing queue.clear() in the source code. But problem is the same. Is this reasonable?  Yes, either way the Producer will block on the add, when the Consumer consumes the variable, it will notify the Producer, but the producer might not get priority until after the consumer gets to the poll. I am not sure there is an easy way to modify your code to get rid of all of the race conditions.  You need to make sure that the field is since the boolean is being changed by multiple threads. Also, I assume that the producer once it sees the has been set to , drains the queue and then sets it to . That sounds like race conditions may result. You might consider using instead so you can use to avoid overwrites.  I'm not sure this is a problem but you should consider doing something like the following to remove some of the set/unset race conditions. You don't need for this:  You might also consider using a instead of synchronizing your own . s handle the thread-safety for you and also have a method which does the logic for you. Your code seems to want to block if there is an item in your queue so you may want to use which limits the size of the queue to 1 which will block the .  Lastly, it is always recommended in these cases to use loops instead of loops:  This solves the problem of unexpected signals and multiple consumers or producers.  111k2222 gold badges278278 silver badges341341 bronze badges  1  I added volatile to the vFlag.value. But problem is still the same. It seems the consumer sometimes can get a null. But how could that be possible?  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  