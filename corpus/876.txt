 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Here's my code to find the max number in an array of numbers, but i can't seem to understand how to get the top 5 numbers and store them in an array and later retrieve them  Here's the code:  I'm using an array to store 5 numbers, but when i run it, it is not what i want. Can anyone help me with the program?  Downvoted as this is the sort of bad quality question that says: 'I don't even know what I'm doing fix it for me'. @bappibazzi You might want to read about sorting and selection algorithms.  10 Answers 10  The optimum data structure to retrieve top n items from a larger collection is the min/max heap and the related abstract data structure is called the priority queue. Java has an unbounded which is based on the heap structure, but there is no version specialized for primitive types. It can used as a bounded queue by adding external logic, see this comment for details..  Apache Lucene has an implementation of the bounded priority queue:  Here is a simple modification that specializes it for ints:  The way you implement decides whether it will behave as a min or max heap. This is how it's used:  Some interest was expressed in the performance of this approach vs. the simple linear scan from user rakeb.void. These are the results, pertaining to the input size, always looking for 16 top elements:  Conclusion: constant factors working against the heap approach are quite low. The breakeven point is around 70-80 input elements and from then on the simple approach loses steeply. Note that the constant factor stems from the final operation of extracting items in sort order. If this is not needed (i.e., just a set of the best items is enough), the we can simply retrieve the internal array directly and ignore the element which is not used by the algorithm. In that case this solution beats one like rakib.void's even for the smallest input size (I tested with 4 top elements out of 32).  Put them all into the queue, checking queue size at each step. If size exceeds n, remove the first element. In the end the queue will contain your top n elements.  @FranMontero Heap is not a binary search tree. The items are not fully sorted, but can be removed one by one in sort order.  correct me if i'm wrong, if i perform sorting it increases the time complexity, so storing in an priority queue is a better option or sorting with respect to the time complexity  Note: If you don't want to change the inputted array, then make a copy of it and do the same operation on the copied array.  5,48333 gold badges1919 silver badges4040 bronze badges  12  2  @bappibazzi he is getting the maximum value of the array 5 times, and after getting it he sets the value in the original array to the lowest value possible . as a result the max value isn´t present anymore in the array  This is O(m n) where m is input size and n is in your case five. For small inputs this is enough.  Asking for top 5 of { 33, 55, 13 } will return { 33, 55, 13, MIN_VALUE, MIN_VALUE }. Not necessarily what you want, but asking for top 5 of 3 values is weird to begin with.  @BoristheSpider, You may find the in the comment section that I asked any other restriction does OP has to solve this problem, he said none. So I provide the simple solution with .  This has a bug: once the first element is the max one, you never reassign so the same number keeps repeating.  Sorting, regular expressions, complex data structures are fine and make programming easy. However, I constantly see them misused nowadays and no one has to wonder:  Even if computers have become thousands of times faster over the past decades, the perceived performance still continues to not only not grow, but actually slows down. Once in your terminal application, you had instant feedback, even in Windows 3.11 or Windows 98 or Gnome 1, you often had instant feedback from your machine.  But it seems that it becomes increasingly popular to not only crack nuts with a sledgehammer, but even corns of wheat with steam hammers.  You don't need no friggin' sorting or complex datastructures for such a small problem. Don't let me invoke Z̴̲̝̻̹̣̥͎̀A̞̭̞̩̠̝̲͢L̛̤̥̲͟͜G͘҉̯̯̼̺O̦͈͙̗͎͇̳̞̕͡. I cannot take it, and even if I don't have a Java compiler at hands, here's my take in C++ (but will work in Java, too).  Basically, it initializes your 5 maxima to the lowest possible integer values. Then, it goes through your list of numbers, and for each number, it looks up into your maxima to see if it has a place there.  It is a similar solution to rakeb.voids' answer, but flips the loops inside out and does not have to modify the input array.  Use steam hammers when appropriate only. Learn algorithms and datastructures. And know when NOT TO USE YOUR KUNG-FU. Otherwise, you are guilty of increasing the society's waste unecessarily and contribute to overall crapness.  (Java translation by Marko, signature adapted to zero allocation)  36.9k55 gold badges8787 silver badges128128 bronze badges  10  ... one reason why I am embittered: I do a lot of JavaScript coding recently, and I could puke on how many problems are hammered down by regexes where totally inappriate. Replacing all , , , ? Use four regex-replaces on a multi kilobyte string seems the appropriate solution in JavaScript.  The advantage of this over rakib's should be not thrashing the cache lines by repeatedly going through the large array. I expect this to beat the heap-based solution for any input size, as long as the number of maxima is low enough.  @MarkoTopolnik: That's for sure. For larger lists of maxima (is that even right? Is "maximums" more correct?), more complex algorithms grow friendlier.  Let's see where the breakeven point is, though... BTW to be identical to other solutions, you should also sort the maxima array.  I translated your code to Java and posted into your answer at the bottom, check it out. Unfortunately, JMH says it very slow, about 3x worse than rakib.  As an alternative to sorting, here is the logic. You figure out the code.  Keep a list (or array) of the top X values found so far. Will of course start out empty.  For each new value (iteration), check against top X list.  If top X list is shorter than X, add value.  If top X list is full, check if new value is greater than any value. If it is, remove smallest value from top X list and add new value.  Hint: Code will be better if top X list is sorted.  If you don't want to sort you can check lower number and it's position and replace. WORKING DEMO HERE.  First of all, you can't use the constant with array. goes up to 10, while length is 5. Use a separate variable for that and increment when you add a new value.  Second, this logic is not retrieving the max values, you need to go over your array fully, retrieve the max value and add it to your array. Then you have to it again. You can write a first loop which use as a condition and the inner loop which will use . Or, you can use recursion.  You could do this properly in an OOp way. This maintains a list of the n largest values of a list of offered values.  For larger numbers you can improve the algorithm using to find the best place to put the new item instead of blindly walking the whole list. This has the added benefit of returning a sorted list.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  