 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a complex json file that I have to handle with javascript to make it hierarchical, in order to later build a tree. Every entry of the json has : id : a unique id, parentId : the id of the parent node (which is 0 if the node is a root of the tree) level : the level of depth in the tree  The json data is already "ordered". I mean that an entry will have above itself a parent node or brother node, and under itself a child node or a brother node.  Usually these kind of tasks required extensive working knowledge objects. Good question  33 Answers 33  There is an efficient solution if you use a map-lookup. If the parents always come before their children you can merge the two for-loops. It supports multiple roots. It gives an error on dangling branches, but can be modified to ignore them. It doesn't require a 3rd-party library. It's, as far as I can tell, the fastest solution.  If you're into complexity theory this solution is Θ(n log(n)). The recursive-filter solution is Θ(n^2) which can be a problem for large data sets.  55.4k1010 gold badges8585 silver badges123123 bronze badges  13  33  keep in mind that with this solution, your nodes must be ordered specifically to make sure the parents are pushed into the map first, otherwise the lookup process will error... so you either need to sort em on the level property, or you need to push them into the map first. and use a separate for loop for the lookup. (i prefer sort however when you don't have a level property the separate loops might be an option)  I found it surprising at first that having additional information, eg: a path like [1, 5, 6] where the array is the subsequent ancestors, couldn't be used efficiently in it. But looking at the code it kinda makes sens since I believe it is O(n)  Despite of the good answer, it is complex. Apply my answer for just two line codes: link  Please can you explain why this solution is Θ(n log(n)), It seems to be taking O(n) time.  ( BONUS2 : NO 3RD PARTY LIBRARY NEEDED, PLAIN JS )  ( BONUS3 : User "Elias Rabl" says this is the most performant solution, see his answer below )  Here it is:  Here is a test, it might help you to understand how the solution works :  6,06933 gold badges2121 silver badges3434 bronze badges  4  3  Wouldn't it be more accurate if we added only when needed? By removing them from the first and moving them inside the second?  @FurkanO really nice solution, however would it be possible to get anywhere near this performance with functional programming (no mutations)  As mentioned by @Sander, @Halcyon`s answer assumes a pre-sorted array, the following does not. (It does however assume you have loaded underscore.js - though it could be written in vanilla javascript):  Code  Requirements  It assumes the properties 'id' and 'parentid' indicate ID and parent ID respectively. There must be elements with parent ID 0, otherwise you get an empty array back. Orphaned elements and their descendants are 'lost'  You can add after the first if-clause to ensure that every node has an attribute (it'll be empty if the node is a leaf node)  Your code snippet worked perfectly, thank you!! The only thing is: is never passed as an argument when calling the function recursively, so i think the line can be replaced by  could this be modified to allow parent_ids instead of 0? Edit: Nevermind, I got it working by changing the to .  Keep in mind that the above answer uses two loops, and hence could be improved. Since I could not find a npm module which implements a O(n) solution, I created the following one (unit tested, 100% code coverage, only 0.5 kb in size and includes typings). Maybe it helps someone: npmjs.com/package/performant-array-to-tree  For anyone interested, the code is easily converted to vanilla js: jsfiddle.net/LkkwH/853  Had the same problem, but I could not be certain that the data was sorted or not. I could not use a 3rd party library so this is just vanilla Js; Input data can be taken from @Stephen's example;  You can handle this question with just two line coding:  Test Online (see the browser console for created tree)  Requirements:  1- Install lodash 4 (a Javascript library for manipulating objects and collections with performant methods => like the Linq in c#) Lodash  Note that link-only answers are discouraged, SO answers should be the end-point of a search for a solution (vs. yet another stopover of references, which tend to get stale over time). Please consider adding a stand-alone synopsis here, keeping the link as a reference  I don't understand why the -1,I think that it's a good solution but unfortunately I don't find the package in gitHub or in another public repository  Thank you for your attention to the package. I plan to later expand it. Here is a link to the repository github.com/DenQ/list-to-tree  I've written a test script to evaluate the performance of the two most general solutions (meaning that the input does not have to be sorted beforehand and that the code does not depend on third party libraries), proposed by users shekhardtu (see answer) and FurkanO (see answer).  playcode.io gives an error "error: Uncaught ReferenceError: global is not defined"; however pasting into browser code works just fine; for everyone wondering - createDataTree is about 15-16 faster than the other one  This is a proposal for unordered items. This function works with a single loop and with a hash table and collects all items with their . If a root node is found, then the object is added to the result array.  I like @WilliamLeung's pure JavaScript solution, but sometimes you need to make changes in existing array to keep a reference to object.  I created this function to convert data from array of objects to tree structure,which is required for d3 tree interactive chart. With Only 40 lines of code I was able to get the output. I wrote this function in an efficent way usign recursive funtionality in js. Try and let me know your feedback. Thank you!!!!  Thanks for the anwser..It works perfectly for my d3 tree topology.. Now i have requirement that i need to change the node color based on the values of the node..So for that i need to pass a flag value in the JSON. How do i do that.. { "name": "Top Level", "flag" : 1, "parent": "null", "children": [ { "name": "india", "flag" : 0, "parent": "Top Level", "children": [  I had similar issue couple days ago when have to display folder tree from flat array. I didn't see any solution in TypeScript here so I hope it will be helpful.  In my cases main parent were only one, also rawData array don't have to be sorted. Solutions base on prepare temp object like  example raw data  def of Folder  SOLUTION: Function that returns tree structure for flat argument  The principle of this algorithm is to use "map" to establish an index relationship. It is easy to find "item" in the list by "parentId", and add "children" to each "item", because "list" is a reference relationship, so "roots" will Build relationships with the entire tree.  Convert nodes Array to Tree  ES6 function to convert an Array of nodes (related by parent ID) - to a Tree structure:  Generate HTML List from nodes Tree  Having our Tree in place, here's a recursive function to build the UL > LI Elements:  Demo time  Here's an example having a linear Array of nodes and using both the above functions:  Based on @FurkanO's answer, I created another version that does not mutate the origial data (like @Dac0d3r requested). I really liked @shekhardtu's answer, but realized it had to filter through the data many times. I thought a solution could be to use FurkanO's answer by copying the data first. I tried my version in jsperf, and the results where unfortunately (very) bleak... It seems like the accepted answer is really a good one! My version is quite configurable and failsafe though, so I share it with you guys anyway; here is my contribution:  With the options parameter, it is possible to configure what property to use as id or parent id. It is also possible to configure the name of the children property, if someone wants or something.  OP could simply use default options:  If the parent id is falsy (, or other falsy values) or the parent object does not exist, we consider the object to be a root node.  Incase anyone needs it for multiple parent. Refer id 2 which has multiple parents  Here's a simple helper function that I created modeled after the above answers, tailored to a Babel environment:  Here is a modified version of Steven Harris' that is plain ES5 and returns an object keyed on the id rather than returning an array of nodes at both the top level and for the children.  This is a modified version of the above that works with multiple root items, I use GUIDs for my ids and parentIds so in the UI that creates them I hard code root items to something like 0000000-00000-00000-TREE-ROOT-ITEM  You can use npm package array-to-tree https://github.com/alferov/array-to-tree. It's convert a plain array of nodes (with pointers to parent nodes) to a nested data structure.  Solves a problem with conversion of retrieved from a database sets of data to a nested data structure (i.e. navigation tree).  UPDATE  You can use object introduced in ES6. Basically instead of finding parents by iterating over the array again, you'll just get the parent item from the array by parent's id like you get items in an array by index.  1,55011 gold badge1414 silver badges2020 bronze badges  2  1  While this link may answer the question, it is better to include the essential parts of the answer here and provide the link for reference. Link-only answers can become invalid if the linked page changes. - From Review  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  