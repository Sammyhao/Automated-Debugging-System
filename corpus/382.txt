 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to write the destructor for my Binary Search Tree and I know how to recursively loop through the tree, but I do not know how to do that in the destructor so that every node is deleted.  My Header is:  My constructor is:  Is there a way to call the destructor recursively? If not, how do I traverse through every node to delete it.  28911 gold badge66 silver badges2121 bronze badges  1  Imagine if you could call the destructor recursively. The destructor runs with the current object being a , not a . And it doesn't take any parameters. So how would it know which node to destruct?  4 Answers 4  217k3232 gold badges280280 silver badges389389 bronze badges  4  I did that and I received this error " Build started: Project: BinarySearchTree, Configuration: Debug Win32 ------ BST.cpp BST.obj : error LNK2019: unresolved external symbol "public: void __thiscall Tree::DestroyRecursive(struct Node *)" (?DestroyRecursive@Tree@@QAEXPAUNode@@@Z) referenced in function "public: __thiscall Tree::~Tree(void)" (??1Tree@@QAE@XZ) C:\Users\Matthew\Desktop\Comp245\BinarySearchTree\Debug\BinarySearchTree.exe : fatal error LNK1120: 1 unresolved externals ========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped =========="  I figured it out. I forgot the "Tree::" in the void function. Thanks. @JohnZwinck  @MatthewDanielSorrell: I actually didn't mean for to be a member of . You can make it that way if you want, but it can also be a regular free function.  Why don't allow operator do all the stuff by itself? look at my response that deletes all nodes but the recursive calll is behind the scenes embedded in the operator.  That makes it hard to do tree operations like removing a single Node, doesn't it? Because it makes every Node deletion recursive.  @JohnZwinck No, you just adjust the node and its surrounding nodes prior to deleting it. For example, if you're deleting the node itself but not its children, you would attach its left and right subtrees to other nodes, clear them in the node itself, then delete the node.  Yeah, that's fair. If there's such a strong concept of ownership then maybe smart pointers would be a better design from the beginning.  When you call or your goes to end of lifetime (exit from a block, like the example at the end), you have to the children s and the operator will call the destructor, see example at the end.  This will make the Tree disappear entirely from memory when the Tree destructor is called.  but it works even if node has null pointers!!! The main diffference is that this answer is tested and @ejp's is not. It shows the destructor call sequence and how the tree is created and deleted. Also, it allows to locate s in the stack (as shown).  deletes chain recursively in the middle of other deletes.... it's the compiler that knows the exact order of execution. In a parallel environment, those than be handled with multiple threads.  Here is my implementation. A Tree equals a TreeNode.  Simply delete the root node of the tree, then the whole tree will be deleted recursively.  You may already know what a delete do.  When delete is used to deallocate memory for a C++ class object, the object's destructor is called before the object's memory is deallocated (if the object has a destructor).  So, in a treeNode's destructor, you only need to destroy the left and right pointers that are manually allocated by you. You don't need to worry about the deallocation of the node itself.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  