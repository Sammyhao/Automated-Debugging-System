 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  What are the benefits of using a functor over a function? Isn't the first a lot easier to read (even before the implementation is added)?  Will really return the average? Don't you need ? See sgi.com/tech/stl/accumulate.html. Here, your second line applies CalculateAvarage()() to each member of the sequence, so you'd need some clever running average calculation, plus an instance of CalculateAverage that you can query after the . will return a copy of your functor.  Functors give you more flexibility, at the cost of usually using slightly more memory, at the cost of being more difficult to use correctly, and at the cost of some efficiency. The memory cost is minuscule per object, but when it is 100% (as in the case of one function pointer versus double that amount of memory) and you have a zillion objects, it counts. The "use correctly" cost includes that functors can be freely copied, so to share state must use internal pointer and possibly dynamic allocation. And that latter is also main efficiency cost.  @juanchopanza: probably OP assumes implicit conversion CalculateAverage to double. And I don't understand how to calculate average (not sum!) with accumulate(). we need to divide by number of elements.. how accumulate's BinaryOperation knows about this number? If BinaryOperation has state and counts sum and number of elements in parallel (and does not use it second operand at all) - is it really more clear solution then for_each ?  @user396672: The way you use accumulate could be for example, . You don't need to use the binary operator parameter at all if you don't want, and the operator doesn't need to track the count, the accumulator can (and should) do it. I think this is about equally clear with the functor you'd pass to , the difference is you implement instead of .  7 Answers 7  In your particular example, the functor-based approach has the advantage of separating the iteration logic from the average-calculation logic. So you can use your functor in other situations (think about all the other algorithms in the STL), and you can use other functors with .  Parameterisation  You can parameterise a functor more easily. So for instance, you could have a functor that takes the average of the squares, or cubes, etc. of your data, which would be written thus:  You could of course do the same thing with a traditional function, but then makes it difficult to use with function pointers, because it has a different prototype to .  Statefulness  And as functors can be stateful, you could do something like this:  to average across a number of different data-sets.  Note that almost all STL algorithms/containers that accept functors require them to be "pure" predicates, i.e. have no observable change in state over time. is a special case in this regard (see e.g. Effective Standard C++ Library - for_each vs. transform).  Performance  Functors can often be inlined by the compiler (the STL is a bunch of templates, after all). Whilst the same is theoretically true of functions, compilers typically won't inline through a function pointer. The canonical example is to compare vs ; the STL version is often 5-10x faster, assuming the comparison predicate itself is simple.  Summary  Of course, it's possible to emulate the first three with traditional functions and pointers, but it becomes a great deal simpler with functors.  You're welcome, but I was trying to give a hint about something a little bigger, which affects your answer fundamentally (I think). I just tried your code, and Visual C++ protests . g++ similarly complains  @Matthieu: That's a fair point. To be honest, I'm echoing the sentiment that Scott Meyers makes in "Effective STL", and that I've observed in practice. I'll look into profiling with functor vs. function-pointer. But fundamentally, I don't think there's any reason that couldn't be implemented in the same way as with a function pointer.  @Matthieu: "last time I tested qsort it allocated extra memory" - I'm surprised, I'd expect there to be adequate space on the stack for qsort, and for pretty much any qsort implementation to rely on this. Furthermore, malloc is allowed to fail and qsort isn't, so typically it would have to abort as a special-case. Finally, qsort does not require a table of pointers, the element size is one of its parameters and pointers to the elements are passed to the comparator function. You can qsort an array of anything and expect the same locality as other similar array operations.  The statefulness example is really good, I hadn't thought of using functors like that.  Functor fits into OOP paradigm as compared to functions.  Functor often may be inlined unlike Function pointers  Functor doesn't require vtable and runtime dispatching, and hence more efficient in most cases.  is easily the most capricious and least useful of the standard algorithms. It's just a nice wrapper for a loop. However, even it has advantages.  Consider what your first version of must look like. It will have a loop over the iterators, and then do stuff with each element. What happens if you write that loop incorrectly? Oops; there's a compiler or runtime error. The second version can never have such errors. Yes, it's not a lot of code, but why do we have to write loops so often? Why not just once?  Now, consider real algorithms; the ones that actually do work. Do you want to write ? Or ? Or ? Do you even know how to implement it in the most efficient way possible? How many times do you want to implement these complex algorithms?  As for ease of reading, that's in the eyes of the beholder. As I said, is hardly the first choice for algorithms (especially with C++0x's range-based for syntax). But if you're talking about real algorithms, they're very readable; sorts a list. Some of the more obscure ones like won't be as familiar, but you can always look it up in your handy C++ reference.  And even std::for_each is perfectly readable once you use Lambda's in C++0x.  This is very interesting because std::binary_function, std::less and std::equal_to has a template for an operator() that is const. But what if you wanted to print a debug message with the current call count for that object, how would you do it?  Here is template for std::equal_to:  I can think of 3 ways to allow the operator() to be const, and yet change a member variable. But what is the best way? Take this example:  Because all 3 solutions are compiled in, it increments count by 3. Here's the output:  In the first approach the iteration code has to be duplicated in all functions that wants to do something with the collection. The second approach hide the details of iteration.  Functors are functions with a state. In C++ you can realize them as a class with one or more private members to store the state and with an overloaded operator () to execute the function. Functors can encapsulate C and C++ function pointers employing the concepts templates and polymorphism. You can build up a list of pointers to member functions of arbitrary classes and call them all through the same interface without bothering about their class or the need of a pointer to an instance. All the functions just have got to have the same return-type and calling parameters. Sometimes functors are also known as closures. You can also use functors to implement callbacks.  You are comparing functions on different level of abstraction.  You can implement either as:  or you can do it with a for loop  The former requires you to know more things, but once you know them, is simpler and leaves fewer possibilities for error.  It also only uses two generic components ( and ), which is often the case in more complex case too. You can often have a simple, universal functor (or function; plain old function can act as functor) and simply combine it with whatever algorithm you need.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  