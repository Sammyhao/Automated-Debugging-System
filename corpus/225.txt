 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm new to Lisp and I'm trying to solve an 8-puzzle using simple dfs (depth-first search). But I am getting a program stack overflow. My code:  here is a list of 9 atoms.  With uncommented it prints 723 - number of items in before the stack overflow occurs.  Now, before solving 8-puzzle, I just want to iterate over all possible states (there are exactly 9! / 2 = 181440 possible states). Sure, it may take some time, but how can I avoid the stack overflow here?  2 Answers 2  This is a typical problem explained in some AI programming books. If you need to search a large / unbounded amount of states, you should not use recursion. Recursion in CL is limited by the stack depth. Some implementations can optimize tail recursion - but then you need architecture your code, so that it is tail recursive.  Typically a data structure for that will be called an agenda. It keeps the states still to explore. If you look at a state, you push all states to explore from there onto the agenda. Make sure the agenda is in some way sorted (this might determine if it is depths or breadths first). Then take the next state from the agenda and examine it. If the goal is reached, then you are done. If the agenda is empty before the goal is found, then there is no solution. Otherwise loop...  Instead of processing the four moves one by one while relying on recursion to keep track of what-to-do-next on each level, just push all the resulting positions at once to a list, then pop and continue with the top one; repeating while the list is not empty (i.e. there is something to do, literally):  This way there's no more info to keep track of, with recursion -- it's all in the list.  This means the generated positions will be processed in the LIFO order, i.e. the list will be used as a stack, achieving the depth-first search strategy.  If you'd instead append all the new positions on each step at the end of the list, it'd mean it being used as a queue, in a FIFO order, achieving the breadth-first search.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  