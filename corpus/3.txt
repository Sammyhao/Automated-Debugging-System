 Iterator invalidation / Quicksort bug  I am writing a quicksort for an exercise. I gave it a shot, and it didn't work. I just spent the past few hours staring at it, and still have no clue what's wrong. My guess is that I'm invalidating my iterator, but I don't know where. After reducing it nearly all the way down to a working example I found online at ( http://en.cppreference.com/w/cpp/algorithm/partition ) I came up with this:  Which is wrong for some reason --- on a short (~16 element) vector shuffled randomly, the output won't be fully sorted most of the time. Oops. Here's the thing -- if I change to (i.e., I make pivot a value instead of an iterator), and remove the dereference operators on in the lambda functions, the sorting routine works. Any ideas why? Here's my code:  This code won't even compile. What is the actual code you're using? In...  ...why are you using const iterators? Why are you using a const function object for comparison? Copies of all these things are being fed to the function. Do you really mean to disallow changes to those local copies?  ... why are you using const iterators? Why are you using a const function object for comparison? Copies of all these things are being fed to the function. Do you really mean to disallow changes to those local copies?  I do, because I have no intention of changing them. For instance, I don't intend to alter my comparison function in the middle of my sorting routine. That would be bad. :) Perhaps it would be smarter to pass those objects by constant reference. I don't think that's an issue at the moment, though (since iterators can be copy-constructed without becoming invalidated). But maybe the issue is somewhere else. Let me take a look with GDB.  I do, because I have no intention of changing them. For instance, I don't intend to alter my comparison function in the middle of my sorting routine. That would be bad. :)  You're also not allowing the comparison function object to modify its own state. That may be unnecessarily restrictive.  But maybe the issue is somewhere else.  What I mentioned there isn't an "issue" I was just curious about why you were doing so when you aren't, for instance, making it impossible to modify what the iterator refers to which would actually have some meaning for me, rather than making it impossible to modify a local-to-function-copy. [Edit: That's silly if I reread that in the context of the OP. ]  That's an interesting point about the comparision object. But then is there a way to make sure the callee doesn't touch it, but allow the functor/closure to manage its own state?  ...when you aren't, for instance, making it impossible to modify what the iterator refers to...  Well, what you said is what I intended, but clearly I'm not thinking today :D. Uhh, how could you enforce that on the callee side? I suppose you would have to have the caller tell you which container they were using, which I guess causes some loss of generality.  What I mentioned there isn't an "issue"  Oh, I was referring to iterator invalidation, not the "const" shenanigans.  I think the fundamental mistake you are making is an assumption about the position of the pivot element. The pivot element can be anywhere in the right-hand partition and the value of *pivot in your second call to std::partition will likely be different than it was for the first (and I'm not entirely certain what you were hoping to accomplish with it.) In other words, you don't really have a pivot element. What you have is a pivot value and you lose track of the corresponding element. Keeping tabs on the pivot element:  