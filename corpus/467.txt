 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  An exception occurs at an arbitrary point in time (Error in caption). Is there a way to make this code work with minimal effort?  I am looking for a method to concurrently communicate with std::map in a multithreaded environment. But, Debug Assertion Failed: Expression: cannot dereference value-initialized map/set iterator.  Why is a thread? Creating a thread and then directly joining it doesn't make sense. If you want to execute and in parallel then it's enough that one of them is a separate thread, like . Then you just plain call .  And you use the map without locking or synchronization, so there are data-races. Which means your code will have undefined behavior. You need to protect all access to the map.  This is a generalized little piece of a very large code. I must have thousands of such threads.  Have you tried debugging it and checking what causes the exception? Shouldn't you lock the map when you do an update? And shouldn't you be locking the map earlier in the other operations? What would happen, for example, if you find a key and try to erase it but another thread erases it first?  2 Answers 2  This accesses the contents of the multimap, without the protection of a mutex. The other execution thread is modifying this map, concurrently. This is undefined behavior.  Neither , nor any other container in the C++ library, is thread-safe. This means that all access to the container, and not just modifications to the container, must be synchronized (i.e., protected by a mutex). The shown code locks a mutex to synchronize only certain modifications to the map. This is insufficient. All access to the map must be synchronized.  Additionally, ignoring the subject of synchronization for a brief moment: the overall algorithm also has another flaw. Even if does not find an existing value in the map, the other execution thread may end up reaching the same conclusion and its value into the map before the first execution thread gets around to calling , itself. The clear intent of the shown code is for the find/insert to be an atomic operation. This is another reason why that entire section of code must be protected by a mutex (and not only the call).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  