 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am intending to serialize and deserialize a hashmap whose key is a string.  From Josh Bloch's Effective Java, I understand the following. P.222  For example, consider the case of a hash table. The physical representation is a sequence of hash buckets containing key-value entries. Which bucket an entry is placed in is a function of the hash code of the key, which is not, in general guaranteed to be the same from JVM implementation to JVM implementation. In fact, it isn't even guaranteed to be the same from run to run on the same JVM implementation. Therefore accepting the default serialized form for a hash table would constitute a serious bug. Serializing and deserializing the hash table could yield an object whose invariants were seriously corrupt.  My questions are: 1) In general, would overriding equals and hashcode of the key class of the map resolve this issue and the map can be correctly restored?  2) If my key is a String and the String class is already overriding the hashCode() method, would I still have problem described above. (I am seeing a bug which makes me think this is probably still a problem even though the key is String with overriding hashCode.)  3)Previously, I got around this issue by serializing an array of entries (key, value) and when deserializing I would reconstruct the map. I am wondering if there is a better approach.  4) If the answers to question 1 and 2 are that it still can't be guaranteed, could someone explain why? If the hashCodes are the same would they go to the same buckets across JVMs?  If you are attempting to serialize a Map you need to make sure that your entire object tree is Serializable, including keys, values, and the Map implementation.  7 Answers 7  The serialization form of doesn't serialize the buckets themselves, and the hash code is not part of the persisted state. From the javadocs:  Serial Data: The capacity of the HashMap (the length of the bucket array) is emitted (int), followed by the size of the HashMap (the number of key-value mappings), followed by the key (Object) and value (Object) for each key-value mapping represented by the HashMap The key-value mappings are emitted in the order that they are returned by .  The persisted state basically comprises the keys and values and some housekeeping. When deserialized, the hashmap is completely rebuilt; the keys are rehashed and placed in appropriate buckets.  So, adding String keys should work just fine. I would guess your bug lies elsewhere.  EDIT: Here's a junit 4 test case that serializes and deserializes a map, and minics VMs changing hashcodes. The test passes, despite the hashcodes being different after deserialization.  55.1k1111 gold badges8888 silver badges126126 bronze badges  5  What's your view on this post which suggests something extra needs to be done to serialize a hashmap correctly. Thanks. (I feel that it aligns with Josh Bloch's paragraph quoted above.) obscured.info/2007/02/15/serializable-override-hashcode  The article says to override hashCode/equals when implementing Serializable, but actually the rule is more general - override if your object is going to be used as the key in a Map. See my edit for a test case to demonstrate that serializing a map works even under changing hashcodes.  Couple of things. 1) This statement seems to have no impact 'Key.xor = 0x7555AAAA', if I remove it and run test it still works. b) This method does not work when HashMap is contained in another object (which is what we're trying to do).  Of course the test still works, the hash code is then the same value. The point of the test is to show that deserialization still works even when the hash codes change. If it doesn't work for our case when the hashmap is in an object, then the fault lies with your object's serialization. You say the method doesn't work for you, but there's no method here - I'm merely showing that hashmaps are safe to be serialized across VMs where the hashcodes may be different.  Sorry, didn't properly read that EDIT: about VMs. In our case we have an object that contains a hashmap<Key, V> and its crimping. Do you think that I need to do writeObject/readObject for each serializable object in my class?  I'm 99% sure that the JVM implementation of HashMap and HashSet handle this issue. They have a custom serialization and deserialization handler. I don't have Bloch's book in front of me now, but I believe he is explaining the challange, not saying that you can't reliably serialize a java.util.HashMap in practice.  I have tried this and used in my app it is working fine. Make a function of this code according to your need.  When using a correctly implemented hash table (like ), you don't have to worry about the method of your keys. The technique referred to in item #3 of the original post is actually built into a good hash table implementation.  The default serialization mechanism is overridden. A simple list of entries (key–value) pairs is stored instead. When deserializing the hash table, the table's method is used to re-add each entry individually. This maintains the consistency of the new, deserialized hash table instance. It won't matter if the hash codes of the keys have changed; the bucket is chosen based on the hash code of the key at the time of deserialization.  254k5353 gold badges378378 silver badges475475 bronze badges  2  What's your view on the below post which suggests something extra needs to be done to serialize a hashmap correctly. Thanks. Do you believe he is using an incorrectly implemented hashtable? Thanks. obscured.info/2007/02/15/serializable-override-hashcode  Yes, his hash table is broken, not his key. Or perhaps he simply misdiagnosed the problem altogether.  If all else fails, can you serialize your Map using JSON or YAML or XML or something?  87.3k6868 gold badges171171 silver badges216216 bronze badges  1  Thanks. I have used 3) that I mentioned in the post above which works just fine. I just want to get better understanding of my other questions.  Add these methods to the class that contains the map. You have also to add serialisation/de-serialization of any other fields:  If you re-read the paragraph you would notice "Therefore accepting the default serialized form for a hash table would constitute a serious bug", It doesn't mean the Hash implementations in Java use default serialized form, I believe Java uses custom serialization for its Hash implementations.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  