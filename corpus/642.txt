 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  My program throws an error which it cannot handle by a block and then it crashes:  Access Violation Corrupted State Exception.  This is the weird thing, because, as I know, corrupted state exceptions are thrown from unmanaged code, while here I get this exception while calling a StringBuilder method.  The code runs in a background thread and crashes from time to time which cannot be easily reproduced. So I attached WinDbg to the process and have the following stack of the exception:  WinDbg shows this exception occurred:  I read such exceptions can be handled with a method attribute [HandleProcessCorruptedStateExceptions], but why does this exception ever occur if I only use StringBuilder?  This is the previous WinDbg analysis ( causes the exception):  UPDATED AGAIN  Here is the WinDbg stack of the exception after I enabled paged heap:  9,2551515 gold badges5353 silver badges6969 bronze badges  8  You shouldn't be able to get that sort of exception, but you haven't shown us your code. You need to post the function and maybe .  Probably I have a wrong interpretation of the WinDbg results, but CLR stack points to these methods, I have posted their source.  Maybe I misunderstood your question. Does it always crash in that method, or did you only see it crash there once?  It's actually the garbage collector that's on the top of the stack. The StringBuilder is there because that's what triggers the GC. As noted below, your problem is heap corruption which is not generally caused by the code that actually crashes.  This looks very much like your unmanaged code wasn't developed to run in a multi-threaded environment. I suggest you encapuslate all calls to the unmanaged code in blocks, so that only one thread at a time can access it. This still may not be enough, as the code may require that only a single thread, ever should access it.  2 Answers 2  Recently, I was faced with a managed heap corruption which was something new to me. I was very frustrated with it and had to learn many things to be able to debug it. I want to thank Seva Titov who gave me right direction to start. His answer was concise and very helpful. I want to log the actions I have taken to debug the problem for my own reference. Probably this will be helpful for others who are new to this.  Debug Heap Corruption in .NET 4:  How to suspect the heap corruption?  Briefly:  The application crashes randomly with no regards to the applied exception catching and even goes through blankets like which are supposed to catch all exceptions.  Examining the CLR stack in the application crash dumps shows the garbage collector on the top of the stack:  The CLR stack always shows different points. Whether the crash occurred or the code which is shown is clearly irrelevant, like StringBuilder's method which is shown to cause the exception.  Going step by step. Each next step is used if the previous one doesn't help.  Step 1. Check the code.  Check the code for unsafe or native code usages:  Review the code for , statements.  Download .NET Reflector and use it to analyze the application assemblies for . In the same way, analyze the third-party assemblies which are used by the application.  If unsafe or native code usage is found, direct extra attention to those. The most common cause of the heap corruption in such cases is a buffer overflow or an argument type mismatch. Ensure that the buffer supplied to the native code to fill is big enough and that all arguments passed to the native code are of the expected type.  Step 2. Check if this corrupted state exception can be caught.  To handle such exceptions, one need to decorate the method which contains the statement with the attribute or apply the following in the file:  In the case the exception was caught successfully, you can log and examine it. This means this is not a corrupted heap issue.  In this step, we debug the crashing application live in the production environment (or where we can reproduce the crash).  Download Debugging Tools for Windows from Microsoft Windows SDK for Windows 7 and .NET Framework 4 (a web installer will be downloaded which will allow selecting the required components to install - mark all components). It will install both 32 and 64 bit (if your system is x64) versions of the required debugging tools.  Here one needs to know how to attach WinDbg to a live process, how to take crash dumps and examine them, how to load SOS extension in WinDbg (google for details).  Enable debugging helpers:  Launch Application Verifier ( - use the required edition, either x86 or x64, depending on your executable compilation mode), add your executable there in the left pane and in the right pane check one node "Basics / Heaps". Save the changes.  Launch Global Flags helper ( - again select the correct edition, x86 or x64). Once Global Flags is started, go to the "Image File" tab and at the top text box enter the name of your executable file without any paths (for example, "MyProgram.exe"). Then press the Tab key and set the following boxes:  Debugger (type the path to the installed WinDbg in the text box to the right, for example, ).  Go to "Control Panel/System and Security/System" (or right-click "Computer" in the Start menu and select "Properties". There click "Advanced system settings", in the displayed dialog, go to "Advanced" tab and click the "Environment Variables" button. In the displayed dialog, add a new System variable (if you are an system administrator - a User variable otherwise - you need need to logout/login in this case). The required variable is "COMPLUS_HeapVerify" with a value of "1". More details can be found in Stack Overflow question .NET/C#: How to set debugging environment variable COMPLUS_HeapVerify?.  Now we are ready to start debugging. Start the application. WinDbg should start automatically for it. Leave the application running until it crashes into WinDgb and then examine the dump.  TIP: To quickly remove Global Flags, Application Verifier and the debugger attachment settings, delete the following key in the registry: x64 -  MDAs must be used along with WinDbg. I used them even along with Global Flags and Application Verifier.  Step 5. Enable GCStress.  Using GCStress is an extreme option, because the application becomes almost unusable, but it is still a way to go. More details are in GCStress: How to turn on in Windows 7?.  Step 6. Compile for x86.  If your application is currently being compiled for "Any CPU" or "x64" platform, try to compile it for "x86" if there is no difference for you which platform to use. I saw this reported to solve the problem for somebody.  Step 7. Disable concurrent GC - this is what worked for me  You have managed heap corruption. It is not easy to find the root cause of the problem for managed heap corruption, because the problem usually demonstrates itself long after the heap is corrupted. In your case, the is a red herring. Corruption happened sometime before.  What I would do is the following:  Check if you have any unsafe C# code. If you have any, double check the logic there.  Enable paged heap for your application. Running it with paged heap will help uncover problems with unmanaged code -- in case unmanaged code is corrupting the managed heap.  Run in different places. This way you might be able to localize the place in your code where corruption happens.  If you have the server type of garbage collection enabled for your application, temporarily change that to workstation garbage collection -- you will get more predictable behavior this way.  Note that when you will be running your code under WinDbg, you will come across occasional first chance AV. It is safe to ingore that, just type once you attach WinDbg to the process, and investigate only second chance AVs.  11.3k22 gold badges3030 silver badges5252 bronze badges  12  I have another crash stack after enabled paged heap, now it points to another code, could you please take a look. !VerifyHeap didn't give anything this time.  @net_prog, was this a second chance AV this time? You only need to look at second chance AVs for the heap corruption. If !VerifyHeap does not report any corruption, this means the heap is still fine, and you are hitting some other issue, not a heap corruption.  I suppose it was a first chance: "(f24.103c): Access violation - code c0000005 (first chance)" and I didn't continue to see whether the program would exit, I just stopped the debugging. I will have to wait for another crash for details.  I enabled workstation GC and it seemed to work fine for more than a week, than I removed that workstation GC and got another crash, I have updated the first post, it was a first chance exception which lead to program termination and the heap had errors as written in the post update. Unfortunately Pageheap didn't show the actual cause of the problem, again points to StringBuilder. What can I do else?  In most cases that I came accross pageheap always caused second chance AV. However I could easily imagine it might not get to the second change AV. This would happen if: a) there is explicit handler for all exceptions; and b) application thinks it is much smarter than OS and it swallows exceptions it is not supposed to. In well written applications if you don't know how to recover from exception, you should pass it on to OS (and debugger, if attached).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  