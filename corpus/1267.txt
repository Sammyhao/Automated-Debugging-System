 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  The map has n elements (lets take for this example these 9)  Now I want to iterate over this map, and remove the n-th element using the iterator.  From the javadoc, I'd assume, the semantics of the remove are well defined.  But depending on the implementation of the map - i.e. HashMap vs TreeMap there is a difference whether the is done before or after .  for HashMaps the behavior is  for TreeMap the behavior is same, when I remove the current entry from the iterator after I have accessed it:  results in  so far so good, but if I remove the element before I access the entry:  The output is unexpectedly  Apparently, the of the modifies the , because the is made up of and the iterator actually returns the actual elements of the map. And depending on the current position in the tree, the internal references of the Entry point to the next or the current (removed) element.  But I'm not sure if this is a bug or if this is intentional. If the latter is the case, I wonder about the rationale behind?  9,77622 gold badges4242 silver badges6464 bronze badges  6  I do not get the behavior you describe in either map... what Java version do you use? What happens if you output the entry's value both before and after the remove()?  jdk1.8.0_121 ... it's reproducible with a TreeMap with only 3 entries (1,2,3), removing the middle element (2). But it doesn't show up in HashMap  I get it too now. I cannot imagine this is intended. The code that does this has a comment "If strictly internal, copy successor's element to p and then make p point to successor"... it's not really stricly internal.  We have just encoutered this also. I have made a bug report for it at Oracle - when it is out of review, I'll add a link for it.  2 Answers 2  the behavior of a map entry is undefined if the backing map has been modified after the entry was returned by the iterator, except through the setValue operation on the map entry  If the mapping has been removed from the backing map (by the iterator's remove operation), the results of this call are undefined.  Calling after is forbidden. Java makes no promises about what will happen if you try it. You should retrieve the value before removing the entry.  This is a partial answer, but hopefully will tip someone else off on how to give a more exact answer.  Assuming, the call you make to returns a view sitting on top of the underlying map,  Then it may not be a surprise that we might get some undefined behavior when trying to access the value after the underlying map entry has been removed from the map.  By your own observations, the behavior seems to be implementation specific, implying that the implementation of the particular map is involved in which behavior is observed.  426k2222 gold badges227227 silver badges292292 bronze badges  5  I can remove this answer if you feel it adds no value here. By the way, if you can find source code for an implementation of you just might have an answer.  Yes, I know why it happens, but not why it is implemented this way and if the effect is intentional (IMO it violates the interface contract).  Where does the contract say that after removing an entry the entry still has to be valid? Also, without seeing the source code for a map iterator, how can you know why it happens?  The contract only mentions that 1) the entrySet returned by Map is backed by the Map, 2) the iterator.remove() modifies the underlying collection (and thus the backing map). But nothing is said about the effects on the Entries themselves. Calling remove and by this modifying the entry (it's still the same object!) is quite a side-effect IMO and I wonder if that is intentional?. ... and I did have a look at the source code, therefore I know what's going on internally :)  @GeraldMücke Please provide some links to implementation source codes in your question. This alone would be very useful information for others reading your question in the future.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  