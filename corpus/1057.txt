 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  The first one can't be actual code, because that is going to raise a . If you want us to debug your code, you have to show us code that actually demonstrates the problem, not just vaguely similar code.  As a side note, , , and are all bad names for variables, because they're the names of built-in functions that you may want to use.  1) Trying to return the INDEX of the target in the original list being passed in, before it is halved. Getting the target is the easy part.  2) Only want to have to pass in 2 arguments: (list, target) instead of 4 arguments including the upper/lower (right/left) bounds of each array being passed in recursively.  3) Don't want out of bounds, maximum recursion depth, or target not found errors.  Doesn't list slicing create a copy of the array? By using indexes you'd be able to save space, if that's a concern.  Not in the way you think. It creates an array of pointers that refer to the memory address of the original array. In other words, it copies the references, which in this case is exactly what we want to return (IE the index of the target) -- that, without its original reference, would be lost when using indexes. Also, I heard using the slice approach in these situations is actually faster. While that might not always be the case, it would be cool to test out.  @Dev can you please elaborate on the code part with callback_response? Did I get it right that we need it here to increment the value of the mid value on every iteration while searching right half for the index?  @EugeneAnufriev you are correct sir – so if the target isn't found, slice either side of the array based on the new mid, and pass that as well as the target as arguments to its recursive function. Sorry for the confusion of the "callback_response" variable assignment – I always thought a recursive function was a type of callback function, so then the response for that call would be the callback-response. Please help me find a better name.  The first solution looks wrong because it doesn't index the list.  This problem tripped me up too the first time I wrote a solution so be sure to test your algorithm well.  Here's what I ended up with:  And when I test it, the answers look correct:  Btw, Python has a library module for just this kind of thing named bisect.  Hi Sonal, we can't compare 2 variable mid and element because mid is index and element is value. Line number 6 "if (element == mid)" should be "if (element == list1[mid])" or else you output will be always False.  There are a lot of solutions here already. Below is one more solution without slicing and that just requires element and list as arguments:  RecursionError: maximum recursion depth exceeded while calling a Python object when you pass in a value not in the list. Is there a base case to address this?  `Please correct me if I am wrong as I am a new programmer but here is my solution:  Welcome to SO. Your solution might be correct. However, it would be nice to add some explanation/commented to the code the answer you posted.  Your first one won't even get started, because will immediately raise a .  If you fix that (by using ), your next problem is that you ignore the and arguments you receive, and instead set them to and each time. So, you will infinitely recurse (until you eventually get a for hitting the stack limit).  Think about it: the first call to recursively calls . But that call ignores that and acts as if you'd passed , so it recursively calls . Which calls . And so on.  If you fix that (by removing those two lines), you've got another problem. When you give it the number , will call l, 10, 6, 10)binarySearch(, then l, 10, 9, 10)binarySearch(. And that last one will check . But is going to raise an , because there aren't 11 elements in the list.  And once you fix that off-by-one error, there are no problems left. The problem you asked about cannot possibly ever occur. Here's an example run:  Your second version isn't recursive. never calls , and that's the whole definition of recursion.  There's nothing wrong with writing an iterative algorithm instead of a recursive algorithm (unless you're doing a homework problem and recursion is the whole point), but your function isn't iterative either—there are no loops anywhere.  (This version also ignores the and arguments, but that's not as much of a problem in this case, because, again, you're not doing any recursion.)  Anyway, the only in the function is in that first . So, for any non-empty list, it's either going to return , or a number. With your input, it will return for anything less than the value at the midpoint of the list (5), and for anything else.  Your problem here is that you're redeclaring min and max in each loop, so although it should be recursive, passing in a new min or max each time, this isn't in fact happening.  You can solve this by using defaults in the arguments:  If you're not familiar with the syntax on line 2, max = max or len(list)-1 max will be set to len(list)-1 only if max is not passed in to the method.  This solution doesn't index the list. Try this test case: for val in range(7): print(val, binary_search(val, [1, 2, 3, 5]))  @GrantJ You're right: I assumed a sequential list starting from zero, as you would get from range(10) but yours is a better answer.  Thank you for this code snippet, which might provide some limited short-term help. A proper explanation would greatly improve its long-term value by showing why this is a good solution to the problem, and would make it more useful to future readers with other, similar questions. Please edit your answer to add some explanation, including the assumptions you've made.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  