 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I got this problem while I was solving a problem of self crossing. It's like the snake game.  Given x = [2, 1, 1, 2], we start from 0, and then we go up for 2, go left for 1, go right for 1 and go down for 2. The goal is to calculate if it will self cross or not. As the given steps are always integers, I thought about using a matrix and every time when it get through a point, I set the point to 1. Like this I could check if the point has been visited or not.  I think in this way, all the memory that Python will make is just the assignment of the matrix. That's why I don't understand when the input x is huge, and why it says "memory out of limit". For me, I think the memory is the same as the matrix has been initiated before.  38111 gold badge44 silver badges1818 bronze badges  4  1  That code should only use around 4MB on 32 bit Python. How are you calling that function? And why is it in a class?  It's in a class because I'm solving the problem here: leetcode.com/problems/self-crossing When I submit my answer, there is a memory limit exceed problem and I really don't know why for small test sets there isn't a memory limit exceed problem but for large sets there is a memory limit exceed problem.  You still didn't tell us how you're calling . The reason that I asked for that info is that I suspected that you were inadvertently creating multiple instances of the Solution class. BTW, you can safely initialize using , but I seriously recommend you try doing it with a set instead.  Thanks for the set explanation . I called the isSelfCrossing like this: ... I don' t think it's the problem of calling Solution class ;)  2 Answers 2  Using lists for a boolean matrix in Python rarely makes sense. Try storing pairs of integers in a and replace  Alternatively, you can create a flat with the same number of elements as and index it as . This, however, might lead to subtle indexing bugs, so I strongly suggest to give a try first.  May I ask why using lists for a boolean matrix doesn't make sense in Python please? Cause I was using it like this in C++ a lot...I don't see a difference in memory allocation of this action between C++ and Python.  Let me first clarify that I suggested assuming the matrix might be sparse, but even for the dense case I would prefer a nested list of 0/1 integers to a set, because conceptually that is the structure I want to represent, and in Python you often optimize for readability rather than anything else. If you do need to optimize for memory consumption in the dense case and you can't use NumPy, an or a is the way to go.  As for the memory differences, in Python a nested list is represented as (roughly) a dynamic array of pointers to the element lists, whereas if you allocate a matrix on the stack in C++ it would be a fixed-size contiguous block of memory.  Also, you can check memory consumption of your Python object using asizeof from the Pympler package. E.g. , which is ~8.6Mb on a 64-bit Python.  @YilingLiu: My guess: maybe the leetcode.com site only gives your process a small amount of memory. So you should try Sergei's recommendation and use a set for instead of a list of lists, since only a small number of entries in get set to 1.  How huge could "x" be? If "x" is not so big, does your code run successfully?  Assuming "x" is really really huge, it might be related to your "m" initialization which is the straw that broke the camel's back. In other words, your "x" (and some other memory allocations) might consume almost all of the allowed memory allocation of the process, and "m" initialization passes over the limit.  Hello Aviad, the x is not really huge, it's just like 100 numbers. But the memory is not in my computer, it's in the memory of here: leetcode.com/problems/self-crossing. When I'm solving this problem, for large set there is a memory exceed limit, but in my option, for large test set and for small test set the memory should be almost the same. I don't understand why this answer doesn't work.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  