 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I need a data structure that can insert elements and sort itself as quickly as possible. I will be inserting a lot more than sorting. Deleting is not much of a concern and nethier is space. My specific implementation will additionally store nodes in an array, so lookup will be O(1), i.e. you don't have to worry about it.  6,8181212 gold badges4141 silver badges5555 bronze badges  4  if you're looking up via an array, why do you need the data structure to be sorted? Does it need to be in order after every insert?  Yes, it needs to be in order after insert. I won't be indexing the element directly, but rather the node, which should have access to it's neighbouring nodes.  You've contradicted yourself. The question says "I will be inserting a lot more than sorting", but your comment says "it needs to be in order after [every] insert". If the former is true, then my answer may be appropriate. If the latter is true, then your are probably better off with a tree, as suggested by squadette (although I'm not sure it needs to be balanced, as he suggests, since lookups are not much of an issue).  Oops, wasn't thinking properly. I meant it doesn't have to be in order after every insert. Sorry.  6 Answers 6  8,05144 gold badges2727 silver badges3939 bronze badges  2  I was wondering if there's something faster, plus I'd like to manually balance/sort.  If you want it sorted after every insert, with an arbitary number of elements so that you can't just have buckets for each item, then a tree is the way to go. That inserts & sorts in teh same operation; you aren't going to get much faster than that I'm afraid.  If you're inserting a lot more than sorting, then it may be best to use an unsorted list/vector, and quicksort it when you need it sorted. This keeps inserts very fast. The one1 drawback is that sorting is a comparatively lengthy operation, since it's not amortized over the many inserts. If you depend on relatively constant time, this can be bad.  1 Come to think of it, there's a second drawback. If you underestimate your sort frequency, this could quickly end up being overall slower than a tree or a sorted list. If you sort after every insert, for instance, then the insert+quicksort cycle would be a bad idea.  27.4k88 gold badges6666 silver badges8989 bronze badges  3  @"although I'm not sure it needs to be balanced, as he suggests, since lookups are not much of an issue" Won't inserting be quicker if it's balanced? P.S. By "lookup" I don't mean search.  @someguy: Well, I suppose that depends on how much balancing overhead actually occurs, and how much traversal it prevents.  You can be smart about the sort. If you create a wrapper for the list/vector, you can keep track of what portion has already been sorted (its the front of the list, so you just need a single index). Then when you want to resort, you just sort the unsorted portion and merge. Then the complexity is far less than the normal O(n log n) for sorting.  Use any of the Balanced binary trees like AVL trees. It should give O(lg N) time complexity for both of the operations you are looking for.  If you don't need random access into the array, you could use a Heap.  Worst and average time complexity:  O(log N) insertion  O(1) read largest value  O(log N) to remove the largest value  Can be reconfigured to give smallest value instead of largest. By repeatedly removing the largest/smallest value you get a sorted list in O(N log N).  If you can do a lot of inserts before each sort then obviously you should just append the items and sort no sooner than you need to. My favorite is merge sort. That is O(N*Log(N)), is well behaved, and has a minimum of storage manipulation (new, malloc, tree balancing, etc.)  HOWEVER, if the values in the collection are integers and reasonably dense, you can use an O(N) sort, where you just use each value as an index into a big-enough array, and set a boolean TRUE at that index. Then you just scan the whole array and collect the indices that are TRUE.  You say you're storing items in an array where lookup is O(1). Unless you're using a hash table, that suggests your items may be dense integers, so I'm not sure if you even have a problem.  Regardless, memory allocating/deleting is expensive, and you should avoid it by pre-allocating or pooling if you can.  I had some good experience for that kind of task using a Skip List  At least in my case it was about 5 times faster compared to adding everything to a list first and then running a sort over it at the end.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  