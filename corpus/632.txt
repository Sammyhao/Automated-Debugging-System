 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Interview question on building and searching an adjacency tree, but I've never worked with them before, so I'm not sure where to begin.  I have a file containing data like:  formatted as such:  Every edge has length 1.  I then need to calculate the shortest path between two of the nodes (the two are specified in the question). Then, I need to provide the estimated complexity in big-O notation.  The latter I can probably fudge, though I've never even heard of it until now and wikipedia doesn't help me much in terms of understanding how to break down a search function into big-O, but I'll worry about that later (unless someone has a good link they could share).  My concern now is trying to model this data and then search it for the shortest path. Like I said, I've never worked with this kind of structure before so I'm kind of at a loss as to where to even begin. I found another question on adjacency lists here, but it doesn't appear to be quite what I'm looking for, unless I'm just totally missing the point. Seems to me, the input data would need to be re-organized to satisfy the structure used in that question, whereas I'm reading my data from a file so I would think I'd need to traverse every node and list of nodes to determine if I have already entered a parent and that could take a long time, potentially. I also don't see how I'd create a bfs search using that structure either.  There are lots of examples of searching out there, so I can likely sort out that part, but any help in getting a data model started that would be suitable for loading from the data file and suitable for a bfs search (or, if there's a better search option out there, please school me), would be of great help.  1 Answer 1  You'll like be storing this data in a (Dictionary) (Links), key being int (NodeID) and value being , where these are the possible destinations from the node which is the key.  You'll need to have another (ShortestPathLastStep), which will store two NodeIDs. This will represent the last step in the shortest path to arrive at a given node. You need this to be able to play back the shortest path.  To perform a BFS (Breadth-First-Search) you'll use a (bfsQueue). Push the start node (given in your question) onto the queue. Now execute the following algorithm  This solution assumes traveling between any two nodes is a constant cost. It is ideal for BFS because the first time you arrive at the destination you will have taken the shortest path (not true if links have variable length). If links are not constant length you'll have to add more logic when deciding to overwrite the ShortestPathLastStep value, you won't be able to exit until your queue is EMPTY and you'll only be pushing nodes onto the queue if you've never been to the node (it won't exist in the short path list) or you've discovered this new way of arriving there is shorter than the last way of getting there (now you'll have to recalculate shortest distances for the nodes you can get to from this node).  4,70333 gold badges2828 silver badges5151 bronze badges  7  Would that List<int> not be a List<Nodes>? As I build that HashTable though, I'd need to iterate through each List<> for each hashtable entry to find if I've already got a reference to that node, then add the new list of child nodes to it, soas to create the tree, would I not? As for searching it, what if I've been building the ShortestPathLastStep hashtable and I come to the end of a path without having found my desired end node? I'd have to earase it and start over from /somewhere/ in the tree (because starting over from the beginning would give me the same result), correct?  @Jon The first HashTable is a "lookup node by id" table. Since there is not extra data in the node, I just put the list of children as the value instead of creating a node class. Either way I'd probably store children as an list of IDs (if they have IDs) instead of the full class. As for creating the table, I'm still not clear on how your input is structured, so it hard to say.  @Jon The idea of BFS is that you are searching by evaluating all Paths of length 1, then all paths of length 2, and then so on. A DFS would be finding a full path to the destination, and then try to find a shorter one until it has exhausted all possible paths.  @Jon You may find it helpful to look into Graphs and shortest distance, lowest cost algorithms.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  