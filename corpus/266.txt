 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am struggling to understand why the function below counts all the nodes in a BST.  If we assume we have the following BST:  If I call then wouldn't the relevant statement:  simply look at node and say, yes it is not null, add 1 to the counter , and then call which would then just send us down the left branch again to . Then when at the and variables are and hence the whole function just returns equal to .  I guess I am struggling to understand exactly when the value of the argument to is updated. Do we look and check if its and update the counter before we update the argument value in the first recursive call to in the left look even though the right look appears after the left recursive call in the code?  89133 gold badges1111 silver badges1818 bronze badges  9  4  I would avoid the global variable . It's quite wrong using global variables with side effects in the recursion...  I suggest you try to find a solution where is a local variable instead of global.  At first, you absolutely should define n as a local variable of . Then by assigning n as result of recursive call, you lose previous information. You'd need instead...  Actually, you can do it really simple: – the null-check in next recursive call compensates the dropped check for children being available. counts current node itself, which replaces the you have now.  1 Answer 1  There is also another bug in that you are counting this node twice if the node has a left and right tree and never counting it if the node has no subtrees.  I think you should be doing:  The next thing is that you check for null on entry into the function. So you don't need to test for null before doing a recursive call.  242k8080 gold badges318318 silver badges538538 bronze badges  1  Actually, you don't even need those two if's, if you drop them, the null-check for root in recursive call will catch up and thus resulting in n += 0...  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  