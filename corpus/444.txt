 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Never had to deal with the DP. We have N stones with weights W_1,...,W_N. Need divide all stones for 2 parts, that difference between them was minimal.  As we have n = 6, and weight = 1,4,5,6,7,9 then difference is 0.  I don't see a question mark, but more concerningly I honestly have no idea what you're trying to accomplish here. Please reword your question so that it is a question, or at least explains what you're trying to accomplish better. If your English is lacking, you might see if some pseudocode or examples (the output generated for certain input, how this output is found, etc.) can help explain what you're trying to do.  I don't know much about dynamic programming, but a style-thing which came to my mind: consider using instead of a dynamically allocated array of to simplify the code.  2 Answers 2  The idea of Dynamic Programming is to calculate the answer iteratively, on each step using the answers already calculated on previous steps. Let's see how this might be implemented for your problem:  Let be the sum of all elements:  Let's construct a set, which contains all possible sums that can be achieved in a single part:  Note how DP works here: having already constructed all possible sums which can be achieved using first stones we try to add -th stone to each of them to get the same all possible sums for stones. Also we add the weight if -th stone itself to the set after the loop to avoid getting an impossible weight (because each stone can be used at most once). After this step we get all possible weights formed with each stone used at most once.  Obviously if the weight of one part is (one of the set elements) then the weight of other part will be , so their difference will be . Let's find that minimum:  6,51544 gold badges3232 silver badges6262 bronze badges  3  +1, very interesting. One question: when you use set, do you assume that all stones have different weights?  1 - If you are coding for ACM, avoid dynamic allocation / . It is slower and is an esay source of segfaults. Try to statically allocate everything by looking at the bounds from the problem statement.  2 - The problem you want to solve is the Knapsack Problem. If you want, you can find tons of resources and solutions to it on the internet / Wikipedia now.  3 - The deal with DP is using cacheing to only need to compute the values of a recursive function once. In your case you have 2^n possible spplitings of the stones, but assuming each stone is of maximum weight W, there are only n*W possible weights for a set of stones.  So, can we make a function F(w) that determines if there is a set of stones in the that add up to w? If so, we can find an algorithm with only n*W iterations instead of 2^n!  The answer is yes! But you probably need to put some ordering in to do make it work. Let G(w, n) be defined by:  All we need to do now is compute G(w, NROCKS) to find F(w)!  It is easy to find a recursive definition that allows us to compute G:  While you could just directly implement this function, it would still have an exponential runtime (I won'texplain this. But think about the traditional fibonacci function example).  The trick with DP, is exactly noticing that there is a limited number of inputs we will ever use for this function (W from 0 to NROCKS*max(MAXWEIGHT) and N from 0 to NROCKS), so we can use a NROCKS*MAXWEIGHT by NROCKS matrix (or something similar) as a lookup table to avoid calculating things twice.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  