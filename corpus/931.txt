 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  But unfortunately it becomes "time limit exceeded".  The algorithm for finding the path from the first A[0][0] to the last A[n][n] two-dimensional array.  Please make your code minimal reproducible example by adding hard-coded test values of (instead of using scanner)  1 Answer 1  You have to clarify what is the boundary of n and m. However I guess that in this question m would be much smaller than than n * n. If it's the case, instead of creating a n * n array, you can define a hash table with m elements, with each element has pair of (v, u) as key, and "is it visited" as boolean value.  Cause reading and writing in a hash table has constant time complexity, it's not different from defining a n * n array, in time complexity, but much more memory efficient.  m is the number of directional edges of our graph n is the number of graph nodes I want to know if there is a path from first node to last node or not?  @MHSHG well i understand that. but it's important to know how much big m could be. can it be n*n? or it's just as much as n, and this graph is more like a tree?  @MHSHG well. this indicates that you have to use hash map. because n^2 (your 2 dimensional array) is 10^10 Bytes which is too much. but by using hash map you just allocate 10^5 Bytes of memory.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  