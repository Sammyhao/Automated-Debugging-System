 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Currently, I'm trying to find the height and size of a binary tree, however I'm running into some issues. My code currently will not compile and I cannot find out what I'm doing wrong for the life of me.  my thought process is to keep traversing the left and right subtrees and adding 1 for every level of the tree we decend. However, the errors I'm getting are saying:  left of '->height' must point to class/struct/union/generic type  '_Ty std::max(std::initializer_list<_Elem>,_Pr)' : expects 2 arguments - 1 provided ect.  I've tried a few things like this->right.height() ect.  Next, the size function  My thoughts were to use the inorder traversal that I've already written and tested to try and walk through each node, and instead of printing the vertex, add 1 to size for every vertex.  I'm getting the same errors for my getSize operation. Obviously there must be some fundamental flaw with my C++ code, but I cannot figure it out myself. Any help would be greatly appreciated.  What is and what is ?  – user2556165  Nov 17 '14 at 8:14  Did you mean ? I suspect that you define free function whereas you want class methods.  number = max(right->height(), left->height()) + 1;, yet you return height, which is set to 0 and doesn't change. Furthermore, your code here is out of context - post your binary tree implementation etc.  A Node is a vertex of my binary search tree. Think of it as a linked list. _root is the base of that binary search tree.  1 Answer 1  First of all, it is best here to get rid of the manual memory management and use for the left and right child nodes. These should be correctly initialized to . The non-owning parent node pointer can remain a raw pointer, but be careful that you do not its content.  Then, a recursive height definition in class might look like this:  The above function gives the root node -- if it is the only avilable node -- a depth of zero. As written, I assume that either both nodes are set or unset, i.e. the case that only the left or only the right node is set does not occur (strictly, one could then omit one check for for both child nodes). If this doesn't hold, the code can be easily adjusted.  Further, you could also abbreviate the check by using the conversion-to-bool property of  12.8k11 gold badge3535 silver badges6868 bronze badges  2  still doesn't work. For some reason it does not actually access the left and right node.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  