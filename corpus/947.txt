 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Store objects that have multiple properties, including unique ID in addition to a Priority integer used for sorting.  Priority will have duplicate values.  Retrieval / checking for the existence of an object by its ID (i.e., Dictionary / Hashtable key) is O(1).  Retrieval of "the top 10 items" by Priority must be as fast as possible. My assumption is this means there must be a separate List / LinkedList that keeps references to the items in the dictionary / hash table. If so, this List / LinkedList must be maintained whenever an item is added or removed, or an item's Priority value changes.  Re-sorting the items upon adding / removing an item, or changing an item's Priority, is as fast as possible.  What data structure would you use? Does one already exist in .NET? Or should it be custom built? I'm leaning toward the latter.  1 Answer 1  SortedList gives you sequential access and O(log n) retrieval, which is the best you can do with the supplied .NET collections.  When I needed to do this, I married a priority queue and a dictionary. It looked something like:  Whenever I inserted an item, I'd insert it into the queue, which returned a . I inserted that into the dictionary.  That gave me O(1) retrieval and O(log n) insertion. You can get amortized O(1) insertion if you use a pairing heap rather than the binary heap priority queue that I used.  Retrieving the top k items is an O(n log k), where n is the number of items in the priority queue. I used a heap select for that. I wrote a little about heap selection in When theory meets practice. Considering that the items are already in a heap, you should be able to do it in O(k), using a technique based on An Optimal Algorithm for Selection in a Min-Heap. I think it's possible, but I haven't done it.  I have a heap-based priority queue that might do the trick for you. Source is at http://mischel.com/pubs/priqueue.zip. Unfortunately, the article I wrote about it is no longer available online. But if you email me (jim AT mischel.com) and mention this posting, I'll see if I can dig it up.  I no longer have the code for the combined dictionary / priority queue, though. Sorry.  Answers to questions in comments  Whether you want a priority queue or a list / linked list really depends on how you use it and how many items are in the collection. If you use a linear list, add and change priority are O(n). Removal is O(1) if you remove by key. Remove by priority is O(n) because you have to find the item before you can remove it. But finding the top k items is trivial: you take the first k items.  In a binary heap priority queue, insert, remove, and change priority are O(log n). Getting the top k items is O(k), but in real terms slower than with a linear list. Although if you know it's always the top 10 that you want, you could find and cache them in a separate list. That way you could return them quickly most of the time. You'd set a dirty flag whenever you add, remove, or change priority so that you know to regenerate the top 10 list the next time somebody asks for it.  The pairing heap might very well be what you're looking for. It does add and remove in O(1) amortized time. Changing priority isn't too bad (see the linked Wikipedia article and the original paper [linked above]). Remove is O(log n). Worst case for finding the top 10 would be O(n log k), but again you could cache the items and only regenerate the top 10 if the heap changes. The caching idea works best if k is a constant or the maximum k is some small percentage of the total number of items.  You might take a look at the C5 Generic Collection Library, which has several priority queue implementations. I've not used it, but have heard good things about it.  It really comes down to how many items are in the collection and the frequency of changes versus requests for the top 10. It doesn't take a lot of items (a few thousand, I suspect) for the cost of operations in a linear list to really kill you. And since you can easily cache a top 10 list and recreate it as needed, the priority queue's lower cost for the other operations is very attractive when the collection size increases.  Come to think of it, the might be what you want given your mix of operations. Getting the top 10 items is very fast. It's easy to use. Why not whip up a prototype and see if it will give good enough performance?  125k1717 gold badges168168 silver badges324324 bronze badges  1  Quite possibly a dumb question. If I'm looking to read "the top 10 items" by Priority very often, modify Priority values of random items sometimes, and add / remove items once in a while, is a queue the best supplementary structure to choose? Would it be preferred over a List or LinkedList that I simply sort each time modification / addition / removal occurs? Especially since, when reading, I have no desire to pop things off the queue and would rather they remain stored?  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  