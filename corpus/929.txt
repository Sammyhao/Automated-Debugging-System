 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  In the "Exited" callback, i dispose the resource :  When I profile the code, i still have a root referenced "Item" object but I don't know where I can dispose..., The exited method is triggered and the _queue has removed the "Item" object from the queue.  When I read documentation, the concurrentqueue copy the reference into the queue.  Can you help me to find out where the memory leak is?  Not sure where your memory leak is. There was a memory leak in the .NET 4.0 version of , but it's been fixed for 4.5. You might consider looking into , which is a much nicer wrapper around concurrent collections. The default behavior used internally.  I'd hesitate to call .NET 4's leaky -- mainly this only happened if you were not using it much (it would not set the data to until several items had been popped) -- in which case, what's the point of a ?  Thank you Jim but i'm already in .NET 4.5 and i need FIFO queue, does the blocking collection is FIFO?  If it fits your need you could create a synchronized wrapper for a standard queue using Queue.Synchronized(normalQueue).  2 Answers 2  Unlike a standard .NET Queue, calling Dequeue() does not remove the reference to the object from the collection. While this behavior has changed from the 4.0 version to the 4.5 version (I have read this, but have not tested it) it is not a bug, but a conscious design decision made by the framework team as a part of designing a thread-safe, enumerable collection.  This article has more information, including a workaround by using StrongBox to wrap the objects that go into the ConcurrentQueue. That should be a suitable work-around until you can move to the 4.5 framework.  I have tried this StrongBox approach but only delays the issue. memory still increases to about 1.7GIG, then the app has delay issues and crashes.  I have looked implementation of the Concurrent Queue. There are cases when the queue will hold references to the object after Dequeue() was called.  Concurrent Queue uses Segments to store data. There it is a part of the TryRemove method of the segment:  So when you have a different thread that enumerates the queue at the same time you dequeue an object references to the object will not be set to null.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  