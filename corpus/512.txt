 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Given a binary tree (with left and right child only), how do you write a recursive function to make it into a simple linked list in-place? (no new data structure should be created. Pseudo code is ok). Suppose each node has an integer value, like 123, or 2, or 3. The final link list should have all the nodes in the tree. The order is not important.  Update: needs to be in-place. no new data structure should be created.  136k123123 gold badges430430 silver badges694694 bronze badges  2  For anyone that wants to downvote homework questions, consider answering in such a way that it makes the person asking the question think, instead of giving away the solution. In any case, it is still a valid question.  9 Answers 9  PreOrder  PostOrder  You can choose either of them to form your list...  For example (pseudocode, PreOrder):  Remenber: If you perfomed an InOrder on a binary search tree you would get the elements in sorted order.  Not to be rude, but this sounds a bit like homework. Let me give a description as an answer:  You create an empty linked list for the result.  Make a help function which takes a linked list and a node.  The helper function should add the child nodes (if any) to the list and call itself recursively on the child nodes (if any).  Add the root node to the result list.  Call the helper function on the root node and the result list.  Since you've tagged it as homework, I'll reply without source code or pseudo code, but with a more all-round description.  Since your tree will contain all the values you want to contain in the linked list, we have to make sure we reach them all.  To do that, we'll have to make sure we process every leaf node.  To do that, we need to make sure we process every left and right child of every node.  Let's start with the root node, which is generally the one you have a reference to when you're talking about a binary tree.  I'm assuming you know how to produce a linked list by sequentially appending items to it.  So to process the root node, we do this:  If the root contains a value: Append the value to the list  That takes care of the single value that can optionally be stored in the root node. Some binary trees only store values in leaf nodes (nodes without children), most store values also in internal nodes (nodes with children).  But that will of course get us nowhere, since we only add one item, and we don't even know where in all the values this specific value is, so it could be the first, or the last, or any in between.  But, we know that if the root node has children in the left "direction", then any values we might find in all those nodes will come before the node in the root node.  And we also know that if the root node has children in the right "direction", those values will come after it.  Process all nodes in the left sub-tree  Append the value in the node  Process all nodes in the right sub-tree  Node values are ordered (ie. left sub-tree comes before the value of the node itself, etc.)  You want the values in their ordered sequence  If you define the above approach as a method, you'll have something like this:  In the above pseudo-code, where you see the word "process", you apply the same process to those nodes as described above.  Here's the C# code to process a simple binary tree and append the result to a given linked list:  To get a doubly-liked list that is sorted in the same way as the original tree, C# code:  You are really asking how do I walk a binary tree. The answer can be found in any book on algorithms and data structures.  Assume the tree has nodes containing pointers to nodes called left and right. We'll end up with a list using only the right node pointers.  In Scheme, using memoized recursion, an in-order algorithm would be:  This assumes that a tree structure is represented as:  N.B. I could have used the literal for the but SO messes up the color coding of the block quoted code.  You can "walk a tree" in many orders, the main ones being pre-, post-, and in-order. Here's some pseudocode for in-order, for example:  I hope the assumptions in this pseudocode are obvious: a tree has left and right links, which can be null meaning "nothing more to walk here", and a root node; you can pass a function or closure that does the right think (append to a linked list or whatever) given a node argument.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  