 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  every tree node presents by a ID(string), the functions on the tree data only 2:  , give a ID, get children (no need include childrens' children), if ID is null, get all root nodes  , return parent ID if have, or null if is root  Since once the tree decided, will not change, so I think put all code in static will be best. So I start to try use Dictionary  Since theres about 1000+ catalog, I found I quickly mess myself up, lots of mistake in the static data, and make final result on usable. Also, now I only wrote dozens and the code is looking like mess.  Please advice a way create this simple catalog tree with high performance. Thanks  original data is on another total different language, so I need to write this in c#, plain hard coded c# code is fine for me since once done, the structure will not change.  @Jeroen, maybe need change, then I just put extra code, recompile, redeployment. It will not happen everyday.  13.2k33 gold badges3535 silver badges6060 bronze badges  24  1  @EricYin See updates and edits, and also note that you can make the Add method private if you wish, by making the static TreeNode ctor build the static tree, or you could "signal" the tree to become read-only so the Add method will become obsolete or throw a readonly exception.  @YoryeNathan: +1 Nice work. You might consider an method for setting the parent, and the parent's children accordingly. Maybe a method also.  The getChild method is an instance mehod. It returns the child of the tree node that has the specified name. To get all childs of Cat2, for example, you should the instance of Cat2 as an IEnumerator. Regarding the root - you should keep a static reference to the root, as ot is your entry point for all other nodes. To find a node with a specific id, not necesseraly a direct child of a node, you should use a static recursion based method using the root as the search start, or also keep a static dictionary to contain ALL nodes.  With Net Core I was required to cast the IEnumerator IEnumerable return to a IEnumerator type.  I created a Node class that could be helpfull. It is fast and has some extra properties, like:  -1 Doesn't answer his need at all. He wants a tree for a product catalog. Binary tree is far from what he needs, and even after that, he doesn't need it balanced or sorted in any matter, as the catalog has a logical structure to maintain.  +1: Not what I was thinking of, but the OP didn't give a preference to the type of tree structure.  @YoryeNathan: I disagree. The OP didn't give a preference except for 2 requirements: simple, performance. This answer provides both. Simplicity may be lost on those that don't understand what the tree is doing, but it is certainly more efficient than the linear (or unbalanced) tree.  @IAbstract One thing is to read what the person is asking for, and another thing is understanding what he needs. He needs to represent a catalog, which has no binary-tree properties/constraints whatsoever.  @YoryeNathan: I understood what the OP was asking and my initial thought was the same sort of structure you presented. This answer has merit and could be implemented to serve the OP's needs. If performance is going to be an issue, then this is the better of the two options. If simplicity is preferred, then the standard unbalanced tree is the better of the two options.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  