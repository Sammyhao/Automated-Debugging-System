 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Environment: - Win7 pro x64 - VS2010 - C++ - Empty Project  Goal: Implementation of Dijkstra's shortest path algo using a priority queue.  Problem: When the program runs it gets a Debug assertion failed, Expression: invalid heap error. If the user inputs the source vertex as 1, everything works fine. The assertion only occurs when the source vertex is other than 1. Also, if the assertions are ignored, the code finishes eventually and outputs the proper paths through the graph. I am guessing the error has something to do with altering the data that pointers in the priority queue point to, but if this is the case, I don't understand why using 1 as the source allows the code to complete successfully.  @Oli, actually it is the push_back, but more precisely when I stepped into the code it was during the push_heap call that priority queue uses from the 'algorithm' include.  3 Answers 3  You should pop the top element from the priority_queue right after your call to q.top(). Instead you do q.pop() after pushing a new element into the queue with  That seems to me to be not what you want because you could now potentially be popping an element different from what you thought was the top element.  9,58966 gold badges3737 silver badges4545 bronze badges  3  I tried changing the code to q.pop() after assigning q.top() to temp. Unfortunately the error still occurs, and to make matters worse it happens regardless which vertex is chosen as the source, 1 included.  Putting the pop() after top() is the right thing to do algorithmically, even thought it doesn't fix your problem. Maybe you have some un-initialized stuff. I would try to comment out some stuff in your priority_queue and see what happens. First thing would be to comment out the map<> in the Vertex structure.  Your struct Vertex is just has a bunch of data members, which is why I immediately suspect that something is not being initialized properly.  Its possible you're pushing instances with distances. Comparing two distances would yield none of them being smaller than the other, therefore invalidating your comparator.  If this is strictly a learning exercise and you don't really require distances, I suggest you use integer distances and use a "large" number in place of .  Using bit integers it is a good idea to use as your value, because adding them would yield which is still representable by a signed N bit integer (not so ), and it is a larger value than a simple , i.e. , which keeps your ordering sane.  You should avoid modifying elements that are currently in the priority queue, at least not in a way that modify their priority. The priority of the vertices is given by , which depends on the value of . In the "find path section" you have  The assignment to affect an element currently in the queue. When you call q.push(), the queue realizes it's in an invalid state and complains  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  