 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have an error in map iterators. The problem is the following:  In another module:  Call:  And when I assign result of to I get pointing to a deallocated memory (pointer to a previous ).  Not solving your issue, but names with beginning underscore followed by an uppercase letter as well as names beginning with double-underscores are reserved for the C++ implementation.  thanks. I use underscores to distinct private, protected from public. I'll consider your recommendation in the future projects  Have you implemented your copy constructor (and assignment correctly)? It's not apparent from your snippet hence the simple question..  No, I didn't. I left it to compiler. When I thried to add to I got the followin error in xutility xutility(3133) : error C2679: binary '=' : no operator found which takes a right-hand operand of type 'const JacobianCol' (or there is no acceptable conversion)  2 Answers 2  JacobianCol has the _col_data member. i.e, the input instance JacobianCol Y has a _col_data instance and _L_Begin of this is initialized with that map's iterator. When you return the result, a different _col_data member is created. Now, the _L_Begin iterator is copied from the original Y instance. That is why you get the observed behavior.  To resolve this implement the copy constructor, copy the map and the re-initialize the iterator by explicitly calling _col_data.begin() in the copy constructor  5,05722 gold badges2424 silver badges3636 bronze badges  2  Thank you. I'm trying to implement this. I just thought there is any other compiler-based way :) Thank you  Unfortunately compiler cannot know that your iterator need to be 'copied' in a different way.  result._L_begin keep pointing to Y._col_data.begin(). When the object which Y is a reference to is deleted, result._L_begin keep pointing to that location, which is now invalid.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  