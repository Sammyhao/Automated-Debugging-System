 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I come to c++ from c# and I don't understand what dynamic object is. So imagine you have class A and to create object like A *a = new A() is Normal but what is object a? It's the same thing like an array or what? We can write like a[0] or a[1]? But what going on if we overload operator [] and want to create dynamic object if we have data there and want to get data normally?  is a pointer that holds the address of a dynamically allocated instance of class . In general you don't need to use to create new instances (and should avoid that like the plague).  Overloading operator[] on a class has nothing to do with using [] on a raw pointer. If you want to invoke the class' operator[] then you'd have to first dereference the pointer.  There isn't much of a difference between A *a = new A; and A *a = new A[1]; The differences, I think, are that in the latter version you need to call delete [] on it and you can probably only invoke the default constructor of the type.  3 Answers 3  A pointer is just about what it sounds like, it's something which points somewhere else.  Take your example  That declares the variable as a pointer. It points to an instance (an object) of the class.  Somewhat graphically it can be seen as  In C# (and Java) this is basically the only way to create instances of classes. All variables are (a little simplified) pointers.  In C++ you have other alternatives as well:  The definition above says that the variable is an instance of the class. It's not a reference, it's not a pointers, it is an object.  Now for another difference between the two above definitions: In the first case the instance of is created at run-time. The memory is allocated for the instance when the program is running. In the second case, the space for the instance is allocated by the compiler, at the time of compilation. However in both cases the constructor is called at run-time.  374k3333 gold badges376376 silver badges576576 bronze badges  4  This is a great answer! I would suggest adding a bit addressing the confusion between pointers and arrays. It seems like a significant part of the question to me.  I'm sorry, maybe you don't understand my question. I mean how dynamic object is represented? Is it an array? And if we create object like that A *a = new A(); can we write like that a[1]->data = 0;?  It's not an array. It's a single instance. If it were an array, how many elements would you expect it to contain? Arrays do not expand automatically when you access elements out of bounds.  Your comment about run-time versus static (compiler) allocation is a bit off. If I declare a variable inside a function it is allocated at run time when that object's scope is entered. Only if an object is global (or namespace) or static of various stripes is it allocated statically by the compiler.  If you write the default constructor of the class is called and it dynamically allocates memory for one object of the class and the address of the memory allocated is assigned to the pointer . So points an object of the class and not an array. However, if you want an array of objects dynamically, then you'll have to write something like this . This will allocate memory of 10 objects of . And you can write to access the objects of the array.  Now, what would happen if we overload the operator? If we overload operator, then it should mean that the class has some sort of array inside, and by writing , where is an object of class , we want to get the element situated at second index. (Speaking generally, you can mean anything else using the subscript operator, but you should try to stick to the original meaning of the subscript operator). But we cannot invoke operator on pointers as it would mean to dereference the pointer. So to invoke the subscript operator on a pointer of an object, we have to explicitly call the subscript operator. Like this:  It creates one object of the class , and writing . It explicitly calls the overloaded subscript operator. What if we create an array dynamically?  The first subscript operator is for getting the first object in the array of objects. The second subscript operator is calling the overloaded subscript operator of the object  EDIT: I was wrong about invoking subscript operator of a class A. Thanks to jschultz410, who corrected me.  "It creates one object of the class A, and writing a[0] it gives the first element of the inside array, or maybe something else which the subscript operator was overloaded to mean." This isn't (typically) correct. Writing a[0] dereferences the pointer a to give a reference to the underlying class. It doesn't invoke the operator[]() on the class. Your second example looks correct.  Oh. Sorry. I did not know that. I learned it now though. Thanks. Should I remove it from my answer? Although, what if I wanted to invoke operator[]() ? Will I have to call it manually like this -> ?  Because it looks so terrible you usually wouldn’t write but . It’s still not pretty, but shorter and more idiomatic. Both syntaxes do exactly the same thing.  'a' is a pointer (memory address) to the memory where object 'A' is allocated. Yest it behaves as an array. However you have only one element in it, so 'a[0]' will be equivalent to '*a'. Do not try a[1] in your case. It will compile, but most likely crash at run. If you overload [], it is your problem now :-). Though you cannot overload [] on pointers.  BTW, in c# 'a' would also be a pointer (reference) to the object, not the object itself.  The biggest difference between the languages is that c++ does not manage memory allocation. So, if you said 'new', make sure that you also say 'delete' when you do not need the object any longer.  In 'c+' you can also create references instead of the pointers.  @icegas is a class, not a pointer. As such, you can overload for it just fine (and actually does that). You might want to read through a good C++ book to get a firmer grasp on basic C++ concepts and how they differ (or not) from C#.  pointer is not an object. Most of the operators can be overloaded in objects only. There are few which can be overloaded statically, but not '[]'; If you need to overload [], you need to do in in your object. In this case you can use references as a more convenient way then pointers. or use pointers, but you will need this kind of syntax to use it: (*pointer)[index].  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  