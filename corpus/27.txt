 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to learn recursion, so I tried one program to create a complete binary tree and then print the sum of all its elements, I wrote the insertion part myself and I am confused that my pointer variable which points to a tree node, why I am able to do as it is just a pointer to a node. shouldn't only the actual tree node contain these left and right fields ? Just give me a heads up on this novice doubt. I am surprised that my program does the job though.  82511 gold badge1111 silver badges2626 bronze badges  7  Well is a pointer to an instance of the structure. The structure has the members and . I'm not exactly sure where your confusion is coming from?  Thanks for quick reply @some programmer dude , actually my confusion is whether the node pointer that we create to point to an actual node , also contains these fields as the actual node does ?  Maybe this helps: curr->left is the same as (*curr).left. The pointer does not contain any fields. It just points to the struct that does.  As a side note: you create a heavy memory leak there... for a tree with depth 3, you 3 times but you only use the last one.  1 Answer 1  Regarding the question title I suggest a recursive method, that follows a root in, root out pattern:  As long as you don't rebalance the tree, this would basically result in a behavior where any valid input would return itself with the new value added somewhere down the tree hierarchy and a input would return the newly created node as output.  Use like:  For now, the return value only helps in keeping the comparisons in a single place. But as said, this signature and usage also allows a lot more sophisticated insert methods, where the subtree structure is completely changed on inserts.  12.5k11 gold badge1919 silver badges4848 bronze badges  2  Thanks for pointing out my mistake of memory leak @grek40, one more doubt, should the complete binary tree be sorted as in the left child should be of low value than that of right child or it can be just any value located at any child ? Furthermore, to add up the values I must need a pointer to the root node right ? (so that I can traverse it )  @CodeSpy Actually, the sorting is only relevant for binary search trees. I just used it because I didn't think of any better criteria - your idea of always going left when the current node already contains a right child will create very unbalanced trees. You can decide between left and right any way you want - but it's good to chose a strategy where the resulting tree will be somewhat balanced. Also, as commented, if you really need a complete binary tree, you have to change your approach.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  