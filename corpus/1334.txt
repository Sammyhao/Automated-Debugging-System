 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  What are Null Pointer Exceptions () and what causes them?  What methods/tools can be used to determine the cause so that you stop the exception from causing the program to terminate prematurely?  12 Answers 12  When you declare a reference variable (i.e., an object), you are really creating a pointer to an object. Consider the following code where you declare a variable of primitive type :  In this example, the variable is an and Java will initialize it to for you. When you assign the value of on the second line, your value of is written into the memory location referred to by .  But, when you try to declare a reference type, something different happens. Take the following code:  The first line declares a variable named , but it does not actually contain a primitive value yet. Instead, it contains a pointer (because the type is which is a reference type). Since you have not yet said what to point to, Java sets it to , which means "I am pointing to nothing".  In the second line, the keyword is used to instantiate (or create) an object of type , and the pointer variable is assigned to that object.  The (NPE) occurs when you declare a variable but did not create an object and assign it to the variable before trying to use the contents of the variable (called dereferencing). So you are pointing to something that does not actually exist.  Dereferencing usually happens when using to access a method or field, or using to index an array.  If you attempt to dereference before creating the object you get a . In the most trivial cases, the compiler will catch the problem and let you know that "," but sometimes you may write code that does not directly create the object.  For instance, you may have a method as follows:  In which case, you are not creating the object , but rather assuming that it was created before the method was called. Note, it is possible to call the method like this:  In which case, is , and the statement will throw a .  If the method is intended to do something to the passed-in object as the above method does, it is appropriate to throw the because it's a programmer error and the programmer will need that information for debugging purposes.  In addition to s thrown as a result of the method's logic, you can also check the method arguments for values and throw NPEs explicitly by adding something like the following near the beginning of a method:  Note that it's helpful to say in your error message clearly which object cannot be . The advantage of validating this is that 1) you can return your own clearer error messages and 2) for the rest of the method you know that unless is reassigned, it is not null and can be dereferenced safely.  Alternatively, there may be cases where the purpose of the method is not solely to operate on the passed in object, and therefore a null parameter may be acceptable. In this case, you would need to check for a null parameter and behave differently. You should also explain this in the documentation. For example, could be written as:  What methods/tools can be used to determine the cause so that you stop the exception from causing the program to terminate prematurely?  Now Java 14 has added a new language feature to show the root cause of NullPointerException. This language feature has been part of SAP commercial JVM since 2006.  In Java 14, the following is a sample NullPointerException Exception message:  in thread "main" java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "list" is null  "The best way to avoid this type of exception is to always check for null when you did not create the object yourself." If the caller passes null, but null is not a valid argument for the method, then it's correct to throw the exception back at the caller because it's the caller's fault. Silently ignoring invalid input and doing nothing in the method is extremely poor advice because it hides the problem.  I would add a remark about this post explaining that even assignments to primitives can cause NPEs when using autoboxing: can throw an NPE if b is an . There are cases where this is confusing to debug.  Is it possible to capture NPE thrown by a webapp from the web browser?like will it show in the view page source from the web browser..  Yes check if the object equals null before you invoke a method on it or try to access a variable it might have. Some times structuring your code can help avoid null pointer exception. eg when checking an input string with a constant string you should start with the constant string like here: if ("SomeString".equals(inputString)) {} //even if inputString is null no exception is thrown. So there are a bunch of things that you can do to try to be safe.  An additional way of avoiding problems in your code is to use and annotations. The following answer has more information on this. Although this answer is specificially about the IntelliJ IDE, it is also applicable to other tools as is apparanet from teh comments. (BTW I am not allowed to edit this answer directly, perhaps the author can add it?)  s are exceptions that occur when you try to use a reference that points to no location in memory (null) as though it were referencing an object. Calling a method on a null reference or trying to access a field of a null reference will trigger a . These are the most common, but other ways are listed on the javadoc page.  Probably the quickest example code I could come up with to illustrate a would be:  On the first line inside , I'm explicitly setting the reference equal to . This means I have a reference, but it isn't pointing to any object. After that, I try to treat the reference as though it points to an object by calling a method on it. This results in a because there is no code to execute in the location that the reference is pointing.  (This is a technicality, but I think it bears mentioning: A reference that points to null isn't the same as a C pointer that points to an invalid memory location. A null pointer is literally not pointing anywhere, which is subtly different than pointing to a location that happens to be invalid.)  I understood everything you wrote there, but only because I've been coding for a while and know what a 'pointer' and a 'reference' are (and what null is, for that matter). When I try to dive right into explanations like that, my students look at me crosseyed, because there's not enough background.  A more common way to get a NullPointerException in practice would be forgetting to explicitly initialize a member variable to something other than before using it, like this. With local variables, the compiler would catch this error, but in this case it doesn't. Maybe that would make a useful addition to your answer?  @EJP I think your points are valid, so I've updated the answer to be clearer and to avoid saying 'points to null' where it did.  @StevePowell I indicated a long time ago that I didn't want my answer to change. Please respect the intent of the original author.  Sorry, I was "improving the answer" as requested in the top of this stackoverflow item (This question's answers are a collaborative effort: if you see something that can be improved, just edit the answer to improve it!) I disagree that your version is better, IMO @EJB has valid points; but you are quite welcome to keep your answer intact, confusing though it is.  What is a NullPointerException?  A good place to start is the JavaDocs. They have this covered:  Thrown when an application attempts to use null in a case where an object is required. These include:  Calling the instance method of a null object.  Accessing or modifying the field of a null object.  Taking the length of null as if it were an array.  Accessing or modifying the slots of null as if it were an array.  Throwing null as if it were a Throwable value.  Applications should throw instances of this class to indicate other illegal uses of the null object.  It is also the case that if you attempt to use a null reference with , that will also throw this exception, per the JLS:  Otherwise, if the value of the Expression is null, a is thrown.  How do I fix it?  So you have a . How do you fix it? Let's take a simple example which throws a :  Identify the null values  The first step is identifying exactly which values are causing the exception. For this, we need to do some debugging. It's important to learn to read a stacktrace. This will show you where the exception was thrown:  Here, we see that the exception is thrown on line 13 (in the method). Look at the line and check which values are null by adding logging statements or using a debugger. We find out that is null, and calling the method on it throws the exception. We can see that the program stops throwing the exception when is removed from the method.  Trace where these values come from  Next check where this value comes from. By following the callers of the method, we see that is passed in with in the method, and is null.  Trace where these values should be set  Where is set? In the method. With some more debugging, we can see that this method isn't called at all. If the method was called, make sure to check the order that these methods are called, and the set method isn't called after the print method.  This is enough to give us a solution: add a call to before calling .  Other fixes  The variable can have a default value (and can prevent it being set to null):  Either the or method can check for null, for example:  Or you can design the class so that always has a non-null value:  I still can't find the problem  If you tried to debug the problem and still don't have a solution, you can post a question for more help, but make sure to include what you've tried so far. At a minimum, include the stacktrace in the question, and mark the important line numbers in the code. Also, try simplifying the code first (see SSCCE).  +1 Good to have an example that includes going through the stacktrace; it's important to show why reading it is important for debugging NPE. (and why we almost always look for a stacktrace when someone posts a question about an error)  You mentioned debugging...How does that work? I have been researching the topic for a while now, but can find nothing. I'm sure an amazing teacher like you can teach it to me in a second! Thanks so much! :-)  @RuchirBaronia A debugger allows you to step through a program line by line to see which methods are called and how variables are changed. IDEs should have some tools to do this. See vogella.com/tutorials/EclipseDebugging/article.html for example.  @RuchirBaronia You set breakpoints on the methods around any NullPointerExceptions as seen in the stacktrace, and check the values of variables against what you expect them to be. If you know a variable is null when it shouldn't be, then you can set breakpoints around any code that changes the value. There are also conditional breakpoints you can use which will tell you when a value changes.  Question: What causes a (NPE)?  As you should know, Java types are divided into primitive types (, , etc.) and reference types. Reference types in Java allow you to use the special value which is the Java way of saying "no object".  A is thrown at runtime whenever your program attempts to use a as if it was a real reference. For example, if you write this:  the statement labeled "HERE" is going to attempt to run the method on a reference, and this will throw a .  There are many ways that you could use a value that will result in a . In fact, the only things that you can do with a without causing an NPE are:  assign it to a reference variable or read it from a reference variable,  assign it to an array element or read it from an array element (provided that array reference itself is non-null!),  pass it as a parameter or return it as a result, or  test it using the or operators, or .  Question: How do I read the NPE stacktrace?  Suppose that I compile and run the program above:  First observation: the compilation succeeds! The problem in the program is NOT a compilation error. It is a runtime error. (Some IDEs may warn your program will always throw an exception ... but the standard compiler doesn't.)  Second observation: when I run the program, it outputs two lines of "gobbledy-gook". WRONG!! That's not gobbledy-gook. It is a stacktrace ... and it provides vital information that will help you track down the error in your code if you take the time to read it carefully.  So let's look at what it says:  The first line of the stack trace tells you a number of things:  It tells you the name of the Java thread in which the exception was thrown. For a simple program with one thread (like this one), it will be "main". Let's move on ...  It tells you the full name of the exception that was thrown; i.e. .  If the exception has an associated error message, that will be output after the exception name. is unusual in this respect, because it rarely has an error message.  The second line is the most important one in diagnosing an NPE.  This tells us a number of things:  "at Test.main" says that we were in the method of the class.  "Test.java:4" gives the source filename of the class, AND it tells us that the statement where this occurred is in line 4 of the file.  If you count the lines in the file above, line 4 is the one that I labeled with the "HERE" comment.  Note that in a more complicated example, there will be lots of lines in the NPE stack trace. But you can be sure that the second line (the first "at" line) will tell you where the NPE was thrown1.  In short, the stack trace will tell us unambiguously which statement of the program has thrown the NPE.  1 - Not quite true. There are things called nested exceptions...  Question: How do I track down the cause of the NPE exception in my code?  This is the hard part. The short answer is to apply logical inference to the evidence provided by the stack trace, the source code, and the relevant API documentation.  Let's illustrate with the simple example (above) first. We start by looking at the line that the stack trace has told us is where the NPE happened:  How can that throw an NPE?  In fact, there is only one way: it can only happen if has the value . We then try to run the method on and... BANG!  But (I hear you say) what if the NPE was thrown inside the method call?  Well, if that happened, the stack trace would look different. The first "at" line would say that the exception was thrown in some line in the class and line 4 of would be the second "at" line.  So where did that come from? In this case, it is obvious, and it is obvious what we need to do to fix it. (Assign a non-null value to .)  OK, so let's try a slightly more tricky example. This will require some logical deduction.  So now we have two "at" lines. The first one is for this line:  and the second one is for this line:  Looking at the first line, how could that throw an NPE? There are two ways:  If the value of is then will throw an NPE.  If the value of is then calling on it will throw an NPE.  Next, we need to figure out which of those scenarios explains what is actually happening. We will start by exploring the first one:  Where does come from? It is a parameter to the method call, and if we look at how was called, we can see that it comes from the static variable. In addition, we can see clearly that we initialized to a non-null value. That is sufficient to tentatively dismiss this explanation. (In theory, something else could change to ... but that is not happening here.)  So what about our second scenario? Well, we can see that is , so that means that must be . Is this possible?  Indeed it is! And that is the problem. When we initialize like this:  we allocate a with two elements that are initialized to . After that, we have not changed the contents of ... so will still be .  What about on Android?  On Android, tracking down the immediate cause of an NPE is a bit simpler. The exception message will typically tell you the (compile time) type of the null reference you are using and the method you were attempting to call when the NPE was thrown. This simplifies the process of pinpointing the immediate cause.  But on the flipside, Android has some common platform-specific causes for NPEs. A very common is when unexpectedly returns a . My advice would be to search for Q&As about the cause of the unexpected return value.  It's like you are trying to access an object which is . Consider below example:  At this time you have just declared this object but not initialized or instantiated. And whenever you try to access any property or method in it, it will throw which makes sense.  If we give System.out.println(a.length()); // NullPointerException will be thrown, to skip this we can handle with try catch block. thank you  A null pointer exception is thrown when an application attempts to use null in a case where an object is required. These include:  Calling the instance method of a object.  Accessing or modifying the field of a object.  Taking the length of as if it were an array.  Accessing or modifying the slots of as if it were an array.  Throwing as if it were a Throwable value.  Applications should throw instances of this class to indicate other illegal uses of the object.  Keep it simple, I like this answer, add this if you consider correct - Access to uninitialized attribute of an object  @Emiliano - simply accessing an initialized attribute does not cause an NPE. It is what you >>do<< with the uninitialized attribute value that causes the NPE.  If you want more cases: 1) using a as the target of a block, 2) using a as the target of a , and unboxing .  A pointer is one that points to nowhere. When you dereference a pointer , you say "give me the data at the location stored in "p". When is a pointer, the location stored in is , you're saying "give me the data at the location 'nowhere'". Obviously, it can't do this, so it throws a .  In general, it's because something hasn't been initialized properly.  "A NULL pointer is one that points to nowhere" I disagree. Null pointers don't point to nowhere, they point to null values.  A lot of explanations are already present to explain how it happens and how to fix it, but you should also follow best practices to avoid s at all.  Avoid returning null in methods, for example returning empty collections when applicable.  Use annotations and  Fail fast and use asserts to avoid propagation of null objects through the whole application when they shouldn't be null.  Use equals with a known object first:  Prefer over .  Use null safe methods .  Use Java 8 Optional as return value in methods, Optional class provide a solution for representing optional values instead of null references.  In j2ee projects,Nullpointer exception is very common.Some cases reference variables got null values.So You should check the variable initialization properly.And during conditional statement you should always check that flag or reference contains null or not like:- if(flag!=0) { ur code that uses flag }  It is worth mentioning that some IDEs (e.g. Eclipse) offer automatic nullity analisys based on customizable annotations (e.g. as listed above) and warn about potential errors. It is also possible to infer and generate such annotations (e.g. IntelliJ can do that) based on existing code structure.  First thing should do is before using a nullable object, you should check whether is it null, using .If it is null then you should write code to handle that also.  IMO, it is preferable to avoid returning null objects in methods when possible and use annotation when null input parameters are not allowed in order to, by contract, reduce the amount of ´if (obj==null)´ in the code and improve the code readability.  A null pointer exception is an indicator that you are using an object without initializing it.  For example, below is a student class which will use it in our code.  The below code gives you a null pointer exception.  Because you are using , but you forgot to initialize it like in the correct code shown below:  While this is a nice example, may I ask what it adds to the question that isn't already covered by all the other answers?  It is simply inappropriate to use the word "uninitialized" here. The example you shown is in fact "initialized", and it is initialized with null. For uninitialized variables, compiler will complain to you.  A NullPointerException often occurs when calling method of an instance.For example, if you declare a reference but does not make it point to any instance, NullPointerException will happen when you call its method. such as: YourClass ref = null; // or ref = anotherRef; // but anotherRef has not pointed any instance ref.someMethod(); // it will throw NullPointerException. Generally fix it in this way: Before the method is called, determine whether the reference is null. such as: if (yourRef != null) { yourRef.someMethod(); }  Or use exception capture: such as: try { yourRef.someMethod(); } catch (NullPointerException e) { // TODO }  In Java all the variables you declare are actually "references" to the objects (or primitives) and not the objects themselves.  When you attempt to execute one object method, the reference asks the living object to execute that method. But if the reference is referencing NULL (nothing, zero, void, nada) then there is no way the method gets executed. Then the runtime let you know this by throwing a NullPointerException.  Your reference is "pointing" to null, thus "Null -> Pointer".  The object lives in the VM memory space and the only way to access it is using references. Take this example:  And on another place in your code:  This an important thing to know - when there are no more references to an object (in the example above when and both point to null) then the object is "unreachable". There is no way we can work with it, so this object is ready to be garbage collected, and at some point, the VM will free the memory used by this object and will allocate another.  Another occurrence of a occurs when one declares an object array, then immediately tries to dereference elements inside of it.  This particular NPE can be avoided if the comparison order is reversed; namely, use on a guaranteed non-null object.  You must initialize the elements in the array before accessing or dereferencing them.  operation on uninitialized object at instance level(not the class level) will lead to NullPointerException. operation need to be instance specific. if operation is at class level, saying calling a static method on uninitialized object then it will not throw NullPointerException exception. Even primitive wrapper class objects throws NullPointerException.  1. NullPointerException is a RuntimeException, that means will appear when your program is running, you will not at compilation time.! :(, but most of the IDE help you to discover this. 2. Minimize the use of the keyword 'null' in assignment statements. :) Reference url:  @tomj0101 I'm thoroughly unclear as to why you made that comment... But to your second point, a pattern before was to return null. The keyword is fine. Knowing how to guard against it is critical. This offers one common occurrence of it and ways to mitigate it.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  