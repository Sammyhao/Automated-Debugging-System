 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  In my C++ code I have a class Object equipped with an id field of type int. Now I want to create a vector of pointers of type Object*. First I tried  but this failed because here the same address just repeats itself n times. If I used the new operator I would get what I want but I'd like to avoid dynamic memory allocation. Then I thought that what I need is somehow to declare n different pointers before the for loop. Straightforward way to this is to declare an array so I did this :  Is there still possibility to get a memory leak if I do it this way? Also going through an array declaration is a bit clumsy in my opinion. Are there any other ways to create vector of pointers but avoid manual memory management?  EDIT: Why do I want pointers instead of just plain objects?  Well I modified the original actual situation a bit because I thought in this way I can represent the question in the simplest possible form. Anyway I still think the question can be answered without knowing why I want a vector of pointers.  Actually I have  In derived class I want to fill the member field with objects of type . If the superclass didn't use pointers I would have problems with object slicing. So in class constructor I want to initialize as vector of pointers of type .  EDIT2  Yes, it seems to me that dynamic allocation is the reasonable option and the idea to use an array is a bad idea. When the array goes out of scope, things will go wrong because the pointers in vector point to memory locations that don't necessarily contain the objects anymore.  In constructor for class B I had  This caused very strange behavior in objects of class B.  27211 gold badge22 silver badges1010 bronze badges  3  2  If you do not want dynamic memory allocation then why are you using pointers? You can might as well work with an array of Object.  The problem with you second method is that's it's not legal C++. is not legal unless n is a constant. Also since according to your edit you have a class hierarchy but with you only have Objects, not Superobjects. BTW your first method is also wrong for the reason that you are storing the addresses of objects which have been destroyed. I would just use dynamic memory allocation.  3 Answers 3  You are creating n times Object instance on stack. At every iteration there is created and removed element. You can simply avoid this using that:  thanks that every new element exist on heap not on the stack. Try to add to in class Object constructor something like that:  and the same in the destructor:  If you dont want to create these objects with "new" try reason written by @woolstar  Your question about memory leaks makes me think you are worried about the lifecycle and cleanup of these objects. I originally proposed wrappers, but C++11 gave us , and C++14 filled in the missing . So with all that we can do:  Which you create in place with the wonderfulness of perfect forwarding and variadic templates,  Yes you are going to have to live with some heap allocations, but everything will be cleaned up when goes away.  Someone proposed a boost library, , but that requires not only adding boost to your project, but educating all future readers what this is and does.  No there is no memory leak in your version. When the program leaves your scope the vector as well the array are destroyed. To your second question: Why not simply store the objects directly in an vector?  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  