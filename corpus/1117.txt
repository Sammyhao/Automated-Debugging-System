 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I can take a guess that it has something to do with working with the unsigned long long int.  Upon looking at the Wikipedia link I posted, I realized they have puesdocode (skipped over that and came up with what I have) and realized that had this note: Large ranges may not fit entirely in memory. In these cases it is necessary to use a segmented sieve where only portions of the range are sieved at a time.[14] For ranges so large that the sieving primes could not be held in memory, space-efficient sieves like that of Sorenson are used instead. Therefore I will have to think of a way to do this using a "segmented sieve" method.  Edit3:  Changed the array to account for the [0] element so the "issue" is only focused on the array memory size being too large for future references; also stored the array as a bool instead of a uint64.  5,0562020 gold badges7474 silver badges142142 bronze badges  9  Why do you suspect to be the culprit? Have you run the application in a debugger? What is the offending line?  Dev-C++ isn't letting me debug it correctly. Haven't worked with C++ in a while just downloaded a compiler (bloodshed dev-C++) and running into the issue. Perhaps I'll try another compiler.  - does that actually compile? The number_in_question is a runtime variable, not define or enum. Also, the code goes beyond the array dimensions, you should allocate it like this:  @Pelya: Gcc has an extension to allow c dynamic sized arrays in c++, so it might.  3 Answers 3  You are trying to allocate an array of length . For 8 byte that means this array will take up which is roughly of memory. Even if your system can allocate that much memory (unlikely) you are trying trying to put it on the stack which has typically a size bound to only a few MB. Furthermore you are trying to write to index , while the last index in the array is .  18.6k33 gold badges5757 silver badges7575 bronze badges  1  4.5TB memory, I wish. It makes sense. Also, bloodshed never gave me an error with the last index thing but I realize I must define the array as + 1 as it has the 0th element.  I would assume your are blowing the stack when it attempts to create the array. That size of array is tremendously large and would have to be created on the heap to even have a chance of succeeding.  24.2k66 gold badges4646 silver badges7575 bronze badges  2  Yes, I have same opinion, this array will be created on stack, but you can not have stack of this size  You'll even have trouble on the heap. Few boxes come with over 4TB of RAM+swap nowadays.  Your array has "number_in_question" elements, numbered 0 to number_in_question - 1. But, your for loop will try to access primes_array[number_in_question], which is outside the available space, if that large of an array will even be allocated to you.  Why are you allocating an array of uint64 and storing either 0 or 1 in each element?  Edit: also, you can't allocate an array on the stack with a variable size like that. You'd have to use new to allocate that space on the heap. Again, assuming your system will allow you to allocate that much space.  You are right, for some reason I thought having a uint64 amount of elements would require uint64 type but the array should be defined as a bool. This was fixed in edit 3.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  