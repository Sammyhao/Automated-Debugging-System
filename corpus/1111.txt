 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm trying to write a merge sort algorithm in C. It compiles and works fine for a small array but I get a "glibc detected" error when I try to run it for a bigger (n=100) array. I did some debugging and found that "glibc detected" happened right after the free() function. I have no idea how to fix it, I did some reading and it seems it's caused by freeing an unallocated memory, but I don't see how that can happen. Any advice is appreciated. Here's my code and error messages:  update: I took out the cast on malloc and ran valgrind and got the following. But I'm having trouble understanding it.  1,51144 gold badges1818 silver badges2727 bronze badges  12  2  Build with debugging symbols ( for gcc) then run it through valgrind (valgrind.org). It should be able to help you track exactly what is happening.  You should not cast the return value of -- after function prototypes were added to C89, they have not been necessary, and including them can hide important warnings or errors from the compiler. Rewrite the allocation to .  For those who might not be aware, the in refers to section 3 of the Unix man pages (i.e., you'd type to read the documentation if you're on a system with the command). Calling with an argument of 3 is neither what @sarnold meant, nor likely to be a good choice.  1 Answer 1  Valgrind is pointing you at the bug. Here is how to interpret what it says:  Your program tried to write four bytes of memory at an invalid address.  This is a stack trace. The invalid write happened at line 99 of , which is in the function . Your example program doesn't have the same line numbers, but I get the error on this line:  It's not immediately obvious what's wrong there, so moving on:  "Address " is the invalid address to which the program tried to write. "0 bytes after a block of size 12 alloc'd" means the bad write was just past the end of a heap allocation of 12 bytes. That's almost certainly the memory pointed to by .  So your actual bug is not that you are calling on the wrong thing. It is that you wrote past the end of . Figure out why that happens.  P.S. You can ignore the bit -- that's just the process ID of the program that made the invalid write. It can be helpful when you use valgrind on something that calls .  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  