 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm trying to find the definition of a binary search tree and I keep finding different definitions everywhere.  Some say that for any given subtree the left child key is less than or equal to the root.  Some say that for any given subtree the right child key is greater than or equal to the root.  And my old college data structures book says "every element has a key and no two elements have the same key."  Is there a universal definition of a bst? Particularly in regards to what to do with trees with multiple instances of the same key.  EDIT: Maybe I was unclear, the definitions I'm seeing are  1) left <= root < right  2) left < root <= right  3) left < root < right, such that no duplicate keys exist.  12 Answers 12  Many algorithms will specify that duplicates are excluded. For example, the example algorithms in the MIT Algorithms book usually present examples without duplicates. It is fairly trivial to implement duplicates (either as a list at the node, or in one particular direction.)  Most (that I've seen) specify left children as <= and right children as >. Practically speaking, a BST which allows either of the right or left children to be equal to the root node, will require extra computational steps to finish a search where duplicate nodes are allowed.  It is best to utilize a list at the node to store duplicates, as inserting an '=' value to one side of a node requires rewriting the tree on that side to place the node as the child, or the node is placed as a grand-child, at some point below, which eliminates some of the search efficiency.  You have to remember, most of the classroom examples are simplified to portray and deliver the concept. They aren't worth squat in many real-world situations. But the statement, "every element has a key and no two elements have the same key", is not violated by the use of a list at the element node.  So go with what your data structures book said!  Edit:  Universal Definition of a Binary Search Tree involves storing and search for a key based on traversing a data structure in one of two directions. In the pragmatic sense, that means if the value is <>, you traverse the data structure in one of two 'directions'. So, in that sense, duplicate values don't make any sense at all.  This is different from BSP, or binary search partition, but not all that different. The algorithm to search has one of two directions for 'travel', or it is done (successfully or not.) So I apologize that my original answer didn't address the concept of a 'universal definition', as duplicates are really a distinct topic (something you deal with after a successful search, not as part of the binary search.)  @Pacerier I think instead of maintaining a list, we can maintain a reference count at each node and update the count when duplicate occurs. Such an algorithm would be much easier and efficient in searching and storing. Also, it would require minimal changes to the existing algorithm which does not support duplicates.  @SimpleGuy If you meant a reference list, I can agree with that. If you really meant a reference count (i.e. have multiple nodes but one stores the count), I think that's not going to work. Which node will maintain the count? What if the tree needs to rebalance that node to a lower level etc.?  If your binary search tree is a red black tree, or you intend to any kind of "tree rotation" operations, duplicate nodes will cause problems. Imagine your tree rule is this:  left < root <= right  Now imagine a simple tree whose root is 5, left child is nil, and right child is 5. If you do a left rotation on the root you end up with a 5 in the left child and a 5 in the root with the right child being nil. Now something in the left tree is equal to the root, but your rule above assumed left < root.  I spent hours trying to figure out why my red/black trees would occasionally traverse out of order, the problem was what I described above. Hopefully somebody reads this and saves themselves hours of debugging in the future!  11.1k99 gold badges5757 silver badges8787 bronze badges  7  23  Don't rotate when you have equal nodes! Traverse down to the next level and rotate that.  Other solutions are to either change the tree rule to be , or only insert before the first occurrence of a value.  What problems can this cause in practice? Seem to me that if you are ok with left <= node <= right, then all the red-black tree operations will work out anyhow.  @BjörnLindqvist As mentioned in another answer, the problem with allowing is that you're basically destroying one of the main purposes of having a BST in the first place: to have quick operations on your sorted collection. Unless you do what Rich said or you just put all of the duplicates into the same node, you're then going to have to traverse down possibly to the very bottom of the tree to check for any duplicates.  @Rich One problem I have with your solution is it basically assumes that there won't be many, many duplicates of the same key. If there are, then your tree will end up extremely unbalanced. So this should only be considered, if ever, imo, if you're certain that the duplicates won't ever be a very common occurrence. It seems like for a general-purpose BST, duplicates using the same node is the way to go.  All three definitions are acceptable and correct. They define different variations of a BST.  Your college data structure's book failed to clarify that its definition was not the only possible.  Certainly, allowing duplicates adds complexity. If you use the definition "left <= root < right" and you have a tree like:  then adding a "3" duplicate key to this tree will result in:  Note that the duplicates are not in contiguous levels.  This is a big issue when allowing duplicates in a BST representation as the one above: duplicates may be separated by any number of levels, so checking for duplicate's existence is not that simple as just checking for immediate childs of a node.  An option to avoid this issue is to not represent duplicates structurally (as separate nodes) but instead use a counter that counts the number of occurrences of the key. The previous example would then have a tree like:  and after insertion of the duplicate "3" key it will become:  This simplifies lookup, removal and insertion operations, at the expense of some extra bytes and counter operations.  I'm very surprised that this was never even mentioned in the textbook I'm using. The prof didn't mention it either, nor the fact that duplicate keys are even an issue smh...  @OloffBiermann Probably because most people just think, "We've covered Binary Search Trees, ./" without considering the significant implications of allowing duplicates. Perhaps they decided if you understand BST's then you can make your own modifications as needed. In their defense, the number of tree structures alone that are possible is humongous; there are sooooo many different implementation details about them. As just a starter, take a look here: en.wikipedia.org/wiki/List_of_data_structures#Trees  In a BST, all values descending on the left side of a node are less than (or equal to, see later) the node itself. Similarly, all values descending on the right side of a node are greater than (or equal to) that node value(a).  Some BSTs may choose to allow duplicate values, hence the "or equal to" qualifiers above. The following example may clarify:  This shows a BST that allows duplicates(b) - you can see that to find a value, you start at the root node and go down the left or right subtree depending on whether your search value is less than or greater than the node value.  This can be done recursively with something like:  and calling it with:  Duplicates add a little complexity since you may need to keep searching once you've found your value, for other nodes of the same value. Obviously that doesn't matter for since it doesn't matter how many there are, just whether at least one exists. It will however matter for things like , since it needs to know how many there are.  (a) You could actually sort them in the opposite direction should you so wish provided you adjust how you search for a specific key. A BST need only maintain some sorted order, whether that's ascending or descending (or even some weird multi-layer-sort method like all odd numbers ascending, then all even numbers descending) is not relevant.  (b) Interestingly, if your sorting key uses the entire value stored at a node (so that nodes containing the same key have no other extra information to distinguish them), there can be performance gains from adding a count to each node, rather than allowing duplicate nodes.  The main benefit is that adding or removing a duplicate will simply modify the count rather than inserting or deleting a new node (an action that may require re-balancing the tree).  So, to add an item, you first check if it already exists. If so, just increment the count and exit. If not, you need to insert a new node with a count of one then rebalance.  To remove an item, you find it then decrement the count - only if the resultant count is zero do you then remove the actual node from the tree and rebalance.  Searches are also quicker given there are fewer nodes but that may not be a large impact.  For example, the following two trees (non-counting on the left, and counting on the right) would be equivalent (in the counting tree, means copies of item ):  Removing the leaf-node from the left tree would involve rebalancing (since it now has a height differential of two) the resulting subtree such as below (this is one option, there are others that also satisfy the "height differential must be zero or one" rule):  Doing the same operation on the right tree is a simple modification of the root node from to (with no rebalancing required).  799k218218 gold badges15121512 silver badges18741874 bronze badges  3  1  For the duplicate case, can you just check if the right child is the same as the current node in the node.val == srchval: clause, and then if so go right?  @bneil Way late, but: No, you cannot, because, due to the way self-balancing BST's rebalance to the medians in order to maintain reasonable heights/weights of subtrees (you don't want a doubly linked list), you can easily have situations where the left child, the current node, and the right child are all the same value, unless you were to explicitly ensure that e.g. with a comparison, only the leftmost node of a set of duplicates can be the parent (thus ensuring all are right children); this could lead to a disastrous tree if there are many of the same duplicates though.  @bneil Lazy Ren's answer explains it well: "...even if search() finds the node with the key, it must traverse down to the leaf node for the nodes with [the] duplicate key." As an example, take the tree in paxdiablo's answer here and swap out that 28 with another 29. You can imagine there might be more 29's in their children as well. duilio's answer has another great example.  In the book "Introduction to algorithms", third edition, by Cormen, Leiserson, Rivest and Stein, a binary search tree (BST) is explicitly defined as allowing duplicates. This can be seen in figure 12.1 and the following (page 287):  "The keys in a binary search tree are always stored in such a way as to satisfy the binary-search-tree property: Let be a node in a binary search tree. If is a node in the left subtree of , then . If is a node in the right subtree of , then ."  In addition, a red-black tree is then defined on page 308 as:  "A red-black tree is a binary search tree with one extra bit of storage per node: its color"  Therefore, red-black trees defined in this book support duplicates.  A binary search tree doesn't have to allow duplicates, that's just an option. It could also disallow odd numbers, or primes, or strings with too many vowels, or any other type of data. The only real requirement is that it's ordered in some way, and preferably self-balancing.  Any definition is valid. As long as you are consistent in your implementation (always put equal nodes to the right, always put them to the left, or never allow them) then you're fine. I think it is most common to not allow them, but it is still a BST if they are allowed and place either left or right.  20k33 gold badges4848 silver badges8686 bronze badges  13  1  if you have a set of data which contains duplicate keys, then those items should all be stored within the 1 node on the tree via a different method (linked list, etc). the tree should only contain unique keys.  Also note from the wiki that the right subtree contains values "greater than or equal to" the root. Hence the wiki definition is self-contradictory.  +1: Different people use different definitions. If you implement a new BST, you need to make sure you're explicit about which assumptions you're making about duplicate entries.  Seems like the consensus is (left <= root <= right) when allowing duplicates. But that some folks definition of a BST does not allow dups. Or maybe some people teach it that way to avoid the additional complexity.  incorrect! it's EITHER left <= root < right OR left < root <= right, OR left > root >= right OR left >= root > right  I just want to add some more information to what @Robert Paulson answered.  Let's assume that node contains key & data. So nodes with the same key might contain different data. (So the search must find all nodes with the same key)  left <= cur < right  left < cur <= right  left <= cur <= right  left < cur < right && cur contain sibling nodes with the same key.  left < cur < right, such that no duplicate keys exist.  1 & 2. works fine if the tree does not have any rotation-related functions to prevent skewness. But this form doesn't work with AVL tree or Red-Black tree, because rotation will break the principal. And even if search() finds the node with the key, it must traverse down to the leaf node for the nodes with duplicate key. Making time complexity for search = theta(logN)  3. will work well with any form of BST with rotation-related functions. But the search will take O(n), ruining the purpose of using BST. Say we have the tree as below, with 3) principal.  If we do search(12) on this tree, even tho we found 12 at the root, we must keep search both left & right child to seek for the duplicate key. This takes O(n) time as I've told.  4. is my personal favorite. Let's say sibling means the node with the same key. We can change above tree into below.  Now any search will take O(logN) because we don't have to traverse children for the duplicate key. And this principal also works well with AVL or RB tree.  This was a great answer. I'd mark it as the answer if I could. #4 is definitely the "right" way. (P.S. There's a 6th way not addressed here, but I responded to it with a comment below: stackoverflow.com/a/339597/1599699)  Working on a red-black tree implementation I was getting problems validating the tree with multiple keys until I realized that with the red-black insert rotation, you have to loosen the constraint to  Since none of the documentation I was looking at allowed for duplicate keys and I didn't want to rewrite the rotation methods to account for it, I just decided to modify my nodes to allow for multiple values within the node, and no duplicate keys in the tree.  I suppose you could reverse your tree and put the smaller keys on the right, but really the "left" and "right" concept is just that: a visual concept to help us think about a data structure which doesn't really have a left or right, so it doesn't really matter.  3.) left < root < right, such that no duplicate keys exist.  I might have to go and dig out my algorithm books, but off the top of my head (3) is the canonical form.  (1) or (2) only come about when you start to allow duplicates nodes and you put duplicate nodes in the tree itself (rather than the node containing a list).  Have a look at the accepted answer by @paxdiablo - You can see the duplicate value can exist with . Ideal depends on your requirements, but if you do have a lot of duplicate values, and you allow the duplicates to exist in the structure, your bst can end up being linear - ie O(n).  Duplicate Keys • What happens if there's more than one data item with the same key? – This presents a slight problem in red-black trees. – It's important that nodes with the same key are distributed on both sides of other nodes with the same key. – That is, if keys arrive in the order 50, 50, 50, • you want the second 50 to go to the right of the first one, and the third 50 to go to the left of the first one. • Otherwise, the tree becomes unbalanced. • This could be handled by some kind of randomizing process in the insertion algorithm. – However, the search process then becomes more complicated if all items with the same key must be found. • It's simpler to outlaw items with the same key. – In this discussion we'll assume duplicates aren't allowed  One can create a linked list for each node of the tree that contains duplicate keys and store data in the list.  The elements ordering relation <= is a total order so the relation must be reflexive but commonly a binary search tree (aka BST) is a tree without duplicates.  Otherwise if there are duplicates you need run twice or more the same function of deletion!  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  