 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I wrote a Java lock free queue implementation. It has a concurrency bug. I cannot find it. This code is not important. I just worry about I cannot explain observed behavior related with volatile variables.  The bug is visible by the exception ("null head"). This is impossible state because there is atomic integer holding current queue size. The queue has a stub element. It provides that a reader thread doesn't change tail pointer and a writer thread doesn't change head pointer.  Queue length variable guarantee that the linked list will never be empty. It's as a semaphore.  The take method behaves like it gets stolen length value.  4,59166 gold badges3535 silver badges4343 bronze badges  4  How does this code prevents data races, when no locking mechanism is used? Why dont you want to use a lock?  When do you see the problem? Do you get it with a single reader thread or do you need multiple readers before you see the problem? I suspect the issue is around multiple reader threads being in the second while loop of takeOrNull.  1 Answer 1  I think there is an error in how you use the counter in takeOrNull(), when you remove the stub, you decrease Length by 1, but don't re-increase it when adding the stub back at the end, since you use addNode() instead of add(). Let's say you added an element successfully, so your queue looks like this:  So now one thread starts doing takeOrNull(), length decreases to 1, Head moves to FIRST_NODE, and since this is the STUB node, it gets re-added to the end, so now you have:  Do you see? Length is 1 now! On the next takeOrNull(), you will get NULL, even if FIRST_NODE is still in the queue and has never been returned... You just (temporarily) lost a piece of data. Further, you can now repeat this ad infinitum and start accumulating nodes. Like if you add three nodes, Length is 4 and you have FIRST, STUB, NEW1, NEW2, NEW3. If you then do three takeOrNull(), you end up with NEW2, NEW3, STUB and Length 1. So this way you end up loosing elements, but I admit to not being completely sure about how this would ever trigger the exception. Let me eat and think about it some more. ;-)  EDIT: Ok food did me good, I came up with a sequence that triggers the head null exception. Let's start with a valid queue with one element like before:  Now we have four threads, two that try to takeOrNull() and two that add() concurrently. Both add threads have moved the tail pointer correctly, the first one moved tail from FIRST to SECOND, and then was paused. The second add thread moved then tail from SECOND to THIRD, then updated the old tail's (SECOND's) next pointer, and then incremented the counter and exited. We're left with:  Now the two takeOrNull threads wake up and execute, since Length is 3, both will be able to get an element! The first one moves Head from STUB to FIRST, the second moves Head from FIRST to NULL. And now HEAD is null, and whenever takeOrNull() gets called next, EXCEPTION!  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  