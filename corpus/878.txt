 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  As I understand it, the time complexity of pushing a node onto the heap is , and since this happens once for each node in the graph, I would expect the total time complexity to be , which it would seem should be an 'efficient' solution.  Is there some inefficiency in this algorithm that I overlooked?  1 Answer 1  Your assumption that each coordinate tuple gets pushed only once to your queue may not be right. You might push the same position twice if you come at it from two different neighboring positions before it's been accessed itself.  Bad ASCII-art diagram:  If you start at the position, you'll add its two neighbors, the two positions, to the queue as you process . You'll then process both of the nodes before you process their mutual neighbor, . Because each of the positions add their neighbors to the queue, will be added twice. That duplication will continue, as each time you process , you'll add its neighbor to the heap.  A generic version of Dijkstra's algorithm can't easily avoid positions from being put into the queue multiple times (because a new path to a node might be shorter than one you've pushed but not explored yet, and there's no easy way to lookup and modify values in a heap). But you can prevent one instance of repetition from perpetuating itself. Just refuse to process any position that has already been visited:  I'd also note that your code probably has another issue (unrelated to performance). They way you're generating neighbors, you're will only ever change direction when a current path dead-ends. For example, I don't think you can solve this maze (where you're trying to go from to , with the s being the maze's open spaces:  Your neighbor code will tell you that 's only neighbor is the rightmost dot and that position's only neighbor will be (which you've already visited). You'll never stop in the middle of the top row, so that you can change direction to go down to the exit.  90.8k1111 gold badges107107 silver badges155155 bronze badges  2  Indeed after adding the optimization all the tests passed on LeetCode. Regarding your second point, this is part of of the problem statement: "There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.". I realize that the question might only be visible to LeetCode Premium members; I'll add details to the question for future reference.  Ah, OK, it sounds like you were matching the maze rules correctly then. Sorry I jumped to the conclusion you were doing it wrong! I just thought it might have been an optimization (versus going square by square) that had lead you astray.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  