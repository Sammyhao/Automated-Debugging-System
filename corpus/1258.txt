 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I initially had this recursive solution for a topological sort:  and it seemed to work for my purposes. But I'm having trouble translating it into an iterative solution. This is my attempt:  But the ordering is completely messed up! I think it might be due to the positioning of my , but I don't know how to approach this. Any help would be appreciated it.  I mused in the past couple of days that the trick usually is, to invert the recursion exit condition and use it for the while condition of the non-recursive function. Then, I theorize, you can keep most of your old logic.  The main difference is that in the recursion you have different states of , while in the iterative version you modify only one such list, and you unset when backtracking.  1 Answer 1  I think I solved my own problem. Essentially, you can get the topological order by sorting the nodes by the time they finish. But instead of doing sorting and getting an O(nlogn) solution, we can keep this as O(n). When you are finished with a node, instead of recording its finish time, we can pop a unique identifier for the node onto a stack. Since we are only dealing with positive vertices in my case, it would be sufficient to make the unique identifier simply the negative of the vertex value. Thus if we pop our stack successively, we will get our topological order.  this answer worked pretty well to me. Your sign flip trick is really smart, modulo having all entries > 0 as you mentioned, which is definitely my case. Thanks  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  