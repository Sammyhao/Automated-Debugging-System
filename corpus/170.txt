 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a project in C# which uses an unmanaged C++ static library. I am getting a weird bug when C# gets back a string from the unmanaged code. The program crashes and VS tells me of possible heap corruption. The string is a field in an object in the unmanaged code - so it's not a local variable problem. What's weird is that the crash happens always when in debug mode, but only in some very specific cases when actually running the program. Furthermore, although the debug crash is reproducible on all computers, the runtime crash only happens on some computers.  I should note that I have many functions exported from unmanaged code, and none of them cause a problem except this function and another one that does almost the same thing (GetBlockInfo).  Here is the line of code that causes the crash:  CppToCsharpAdapter is my managed/unmanaged code adapter. The CppToCsharpAdapter.GetFileInfo call caries out a call to the GetFileInfo function in my unmanaged code.  Here is the export function in .cpp:  Here is the GetFileInfo function in unmanaged code:  Here is the call stack leading up to the crash:  EDIT: Updated the call stack, now I get the line which clearly seems to indicate that the problem is there.  Any help will be greatly appreciated. Thanks in advance.  EDIT: I ended up solving the problem by having the C# CppToCsharpAdapter.GetFileInfo() function return an IntPtr, and then converting that to a string within C#.  Naming style: I'd use "native" instead of "unmanaged" ("native C++", "managed C#").  2 Answers 2  The problem lies in your P/Invoke definition of , which you did not include with your question. At a minimum, it needs the following attribute added:  If you omit this attribute, the P/Invoke layer will assume the returned string is represented in code by a , but you are actually using a null-terminated ANSI string. This link has more information:  Your DLL-exported function returns a raw , but I'm not sure this is a correct type for managed code (unless you use a proper P/Invoke signature...).  Have you considered returning a instead? is a typical COM string, and I think .NET understands COM very well, so it can also automatically free the COM-allocated string returned by native code.  EDIT:  As a side-note, the other (not DLL-exported) function, returns a , but I'd suggest you to just return a by value (i.e. just return , not ).  39.2k1212 gold badges7979 silver badges146146 bronze badges  4  Returning by value is a problem because the variable that's passed around between native and managed code gets wiped in the middle, and I end up with trash on the managed end  Not able to try out your solution because my file with export functions is defined with extern "C" which doesn't allow using COM  Oh, I didn't know how. When I tried including the comutil header to try your solution, my export function gave all kinds of errors. Thank you for your help.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  