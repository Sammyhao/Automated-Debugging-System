 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  We are given an array of 2m - 1 distinct, comparable elements, indexed starting from 1.  We can view the array as a complete binary tree:  For instance, the array  is the tree  Now when viewed as a binary tree, these elements satisfy the heap property, a node is greater than both its children:  Are there reasonably fast, in-place algorithm to shuffle the elements of the array around so that the resulting binary tree (as described above) is a binary search tree?  Recall that in a binary search tree, a node is greater than all its left descendants, and less than all its right descendants.  For instance the reshuffle of the above array would be  I think this question is interesting. I have edited it with an interpretation that seemed the most reasonable to me. (As R.. said, if you know the terms, it does make sense).  – Aryabhatta  Feb 11 '11 at 6:32  1  What does in-place mean for you? , which is very strict, or which is the practical definition?  3 Answers 3  First we note that we can -- without loss of generality -- assume that we have the elements 1,2,3,... in our binary tree. So, from now on, we assume that we have these numbers.  Then, my attempt would be some function to convert a sorted array (i.e. ) into an array representing a sorted binary tree.  In a sorted binary tree with elements we have always that the "bottom" of the tree consists of all the uneven numbers, e.g. for :  This means, in the corresponding array, we have that the last numbers are all the uneven numbers:  So we can construct the last "row" of the binary tree by ensuring that the last numbers in the corresponding array are all the uneven numbers. So all we need to do for the last row is to construct a function that moves all elements at positions with uneven indices to the last row.  So let us for now assume that we have a routine that -- given a sorted array as input -- establishes the last row correctly.  Then we can call the routine for the whole array to construct the last row while all other elements stay sorted. When we apply this routine on the array , we have the following situation:  After the first round, we apply the routine for the remaining subarray (namely ) which constructs the second last "row" of our binary tree, while we leave the remaining elements unchanged, so we get the following:  So all we have to do is to construct a function that installs the last row (i.e. the second half of the array) correctly!  This can be done in where is the input size of the array. Therefore, we just traverse the array from end to the beginning and exchange the uneven positions in such a way that the last row (i.e. the latter half of the array) is correct. This can be done in-place. Afterwards, we sort the first half of the array (using e.g. heapsort). So the whole runtime of this subroutine is .  So the runtime for an array of size in total is:  which is the same as . Note that we have to use a in-place sorting algorithm such as Heapsort so that this whole stuff works completely in-place.  I'm sorry that I can't elaborate it further, but I think you can get the idea.  Let n = 2m - 1. In linear time, we can both make a max-heap and extract the elements of a binary search tree in sorted order, so the best we can hope for (assuming comparison-based algorithms) is O(n log n) time and O(1) space. Here is such an algorithm.  For j = n down to 1, pop the max element from the j-element max-heap and store it at (newly vacated) location j. This sorts the array.  Convert the sorted array to a binary search tree with a divide and conquer strategy. (Naively this is Omega(log n) space, but I believe we can compress the stack to O(1) log(n)-bit words.)  a. Treeify the elements less than the root.  b. Treeify the elements greater than the root.  c. Merge the trees by rotating the leaves less than the root into position (= three reverses) so as to leave a subproblem of half the size (O(n)).  Both children of the root are either nil or themselves binary search trees  The values satisfy the following condition: left child < root < right child  Condition 1 is not problem - the heap is a binary tree as well. Condition 2 is problematic but suggests a bottom up approach. Condition 3 is not satisfied as well.  Bottom up means: - We start with all leaves - this is unproblematic, they are binary search trees. - Now we continue with a recursive walk through each level of parents up to the root. - Swap the subtrees if the left child is larger than the right child. - Swap the root with the larger value of the 2 children (it's the right child) - This might not be enough - you might need to continue to correct the right subtree until it is a binary search tree again.  This should work. But still - removing the top element and inserting it into a self balancing tree will be the faster/better approach and a lot easier to implement (e.g. using standard components like std::map in c++).  Another idea: for binary search trees holds the property that a left-root-right walk through the tree obtains the sorted values. This could be done reverse. Getting the values sorted from the heap should be easy as well. Just try to combine this - reading from the heap and writing the tree directly from the sorted values. This can be done in O(n) I think - but I'm not sure wether it can be done in place or not - I guess not.  10.3k55 gold badges4242 silver badges7373 bronze badges  2  1  There's no way that this can be done in . Besides the fact that reading the popping the max element from a heap is in , it would contradict the theorem that sorting takes at least . Building a heap takes and extracting a sorted sequence from a binary tree takes as well. Somewhere inbetween, you need a higher-complexity step.  The question is about converting a heap tree to a binary search. I don't see that the heap property of the input being mentioned. It you don't use the heap property then it all comes down to built a binary search tree in-place, isn't it ?  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  