 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Just writing a simple C program to read a long binary file, break it into 12-bit chunks with a 4 bit CRC appended, then output to another file. When I run the code in debug mode (Visual Studio 2012), it returns garbage, but as soon as I switch to Release mode it works fine.  Switching back to debug mode doesn't seem to bring back the problem either... just trying to understand what is going on here. Whatever VS is doing with "release mode" makes the code work there, but I always get the same garbage as debug mode when I use Dev-C++ to compile.  EDIT: I have made the suggest change of using malloc in the calc function, and free in my main, but I am still getting garbage output. VS actually crashes on running now.  The definition of is the size in multiples of the size of a , so is one, by definition. You can drop that from your code.  4 Answers 4  is a Local (array) variable with automatic storage duration and references to it will become invalid once it leaves its declaring scope, i.e., when your function returns. When the function ends, the array ceases to exist and when you access that pointer/address later its Undefined behavior.  Instead of making a local array placed on stack, it:  And use to clear the memory when you do not need it.  22k66 gold badges6060 silver badges9090 bronze badges  5  1  If one wants to keep it static, the way is to pass a pre-allocated buffer to the function.  Then just create your array like this using once and pass the char pointer in your calc functon and keep overwriting it. So your function prototype could be like  In this case the array can be allocated statically (). No need to mess with heap.  Of course you could pass a stack based array here - it all depends on your algo requirements. That is if you needed resizing of array then you would have to use and .  "Trust me it has nothing to do with that." - It has. In release mode functions are often inlined, and then the memory on the stack is still there after the called function ends. It is still UB, but this is why it works in release.  You are returning a pointer to a local variable. Though this may fool the compiler  it will not work when returning .  Because the data is stored in the stack frame of the function, and hence it will be destroyed when the function returns.  You need to copy the value using and like this  you should be careful since the array cannot be used as a string because it has not terminator.  And then you will need to call on the return value of  To avoid all of this you could pass the array as an argument to the function, like this  and then in the caller function  without returning a value, and you should of course remove the declaration of and inside the function.  Your array is local to the function, i.e. it is released after the function is returned. So the values in the returned pointer can be overwritten by other parts of the program. So most likely you will get garbage. Sometimes (like in your Release) you can get lucky and get something useful from there. But it is totally unreliable.  It has been a long time that I did C programming, but to me it seems you are returning a wrong pointer from calc(). bit16 points to bits16[0], but this becomes invalid the moment the function ends.  So you have an invalid pointer for the short period between the two calls:  I believe, if you just add something between those two lines, that consumes and frees memory, you will be able to make your error more reproducable.  bits16[16] should probably be a static char array outside of calc.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  