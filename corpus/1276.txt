 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  The following code is the the beginning of an adjacency list representation of a graph. In the buildGraph, which is immediately called by main, two vertices are created, then an edge is created between them. But then asking for the size of the edgelist of a vertex should return 1, not 0. I have tried putting couts in various places, and I'm just not able to figure out what the problem is, but I suspect it's due to a misunderstanding of pointers in some way. Thank you for your help!  As a general design comment, if your edge has a start and an end, it is a directed edge. This means that it should really only be in the adjacency list of the start vertex. If you want undirected behavior with this model, you might want to consider changing your naming conventions to be more clear.  2 Answers 2  EDIT: Your problem is in , e1 and e2 are just copies, so changes don't affect the actual vertex objects. Here's my solution, seems to be working:  That's embarrassing -- I changed it, but I am still getting the same result of 0.  In general, yes. The default behavior of the assignment operator is memberwise copy. However, you can overload this (though a better option is to overload the copy constructor).  In addition to @PatLillis's answer, I think you're also going to run into problems here:  The pointers and refer to and in your function. However:  Since you're passing and by value to , you're going to get copies of those vertices in . That means your pointers in will be pointing one place, and the copies will be somewhere else.  Since you're storing your vertices by value in a , you'll have the same problem again. The list will hold copies of the copies in , and your pointers will still be pointing to the originals in .  One way to fix this is to deal with in e.g. and in your . Alternatively, if you want your graph to "own" the vertices (as opposed to them having potentially separate lifetimes from the graph) you could switch to .  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  