 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  My question involves and the data that this pointer points to. If in thread 1 I have  and if in thread 2 I observe that points to , can I be guaranteed that is 4 and is 2?  Does the default memory model for the atomic pointer (sequentially consistent) guarantee that assignments on non-atomic (in this case ) that happen before an atomic store will be seen by other threads before it sees the assignment of the same for both cases?  If it helps or matters, I am using x64 (and I only care about this platform), gcc (with a version that supports atomics).  2 Answers 2  C++11 atomics use by default the memory ordering, which means that operations are sequentially consistent.  The semantics of this is that ordering of all operations are as if all these operations were performed sequentially :  C++ standard section 29.3/3 explains how this works for atomics: "There shall be a single total order S on all memory_order_seq_cst operations, consistent with the “happens before” order and modification orders for all affected locations, such that each memory_order_seq_cst operation that loads a value observes either the last preceding modification according to this order S, or the result of an operation that is not memory_order_seq_cst."  The section 1.10/5 explains how this impacts also non-atomics: "The library defines a number of atomic operations (...) that are specially identified as synchronization operations. These operations play a special role in making assignments in one thread visible to another."  The answer to your question is yes !  Risk with non-atomic data  You shall however be aware that in reality the consistency guarantee is more limited for the non-atomic values.  Suppose a first execution scenario:  Here, is 4. Because is atomic, thread (2) safely gets the value when it reads the pointer. The memory ordering ensures that all assignments made BEFORE are seen by the other threads ("happens before" constraint).  But suppose a second execution scenario:  Here the result is undefined. It could be 4 because of the memory ordering guaranteed that what happens before the assignement is seen by the other threads. But nothing prevents assignments made afterwards to be seen as well. So it could be 8.  If you would have had instead of then you would have certainty again: would be 8.  You can verify this experimentally with this for example:  Conclusions  To conclude, the answer to your question is yes, but only if no other change to the non atomic data happens after the synchronisation. The main risk is that only is atomic. But this does not apply to the values pointed to.  To be noted that especially pointers bring further synchronisation risk when you reassign the atomic pointer to a non atomic pointer.  By default, C++-11 atomic operations have acquire/release semantics.  So a thread that see's your store will also see all operations performed before it.  171k1717 gold badges195195 silver badges264264 bronze badges  1  10  +1. (Actually the default is , which has even stronger guarantees than acquire/release, but indeed that's all that would be required here anyway.)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  