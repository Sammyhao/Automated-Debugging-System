 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  E has 2 attributes (priority, name), All elements in container have unique 'name'  I want to support following operations on this container C as effeciently as possible.  insert:- inserts element1(name1, priority1) to the container: C.insert(element(name1, priority1))  update :- update priority of element with name=name1 as priorityNew1: C[name1] = priorityNew1  delete:-deletes the element with name=name1: C.delete(name1)  get and remove element with highest priority: C.pop()  get element with highest priority: C.peek()  Basically I want a combination of map and heap. map on element's 'name', and heap on element's 'priority'. Most ideally I would like every operation as O(1). Otherwise insert, update, delete as O(log N) and pop and peek as O(1) is also fine.  I could think of following two approaches  1) Using a hash map of elements, hashed on name. so insert update delete are O(1) pop and peek are O(N), we search whole container for highest priority.  2) Using SQLite with table 'element' having two columns 'name' and 'priority'. running times will be based on SQLite implementations.  I am interested to know more thoughts on this problem, I am facing a real world problem related to this. Thanks for your inputs.  @Evgeny Uh, the treap depends on the randomness of the priority values used for the heap structure. The OP wants his own priority values.  It sounds like a Boost bimap should do the job pretty easily. If you might want more than two key fields at some point, Boost multi_index can do that, but as long as you only want two, bimap is probably simpler.  "Otherwise insert, update, delete as O(log N) and pop and peek as O(1) is also fine." Than it sounds like a regular heap would be fine.  2 Answers 2  If for each operation is acceptable, obviously will suffice. This works like a two-sided . You can get almost the same by maintaining two together or write your own wrapper (but why should you?). A binary search tree with self balancing has a for minimal retrieval, which is slightly less efficient than a heap.  If efficiency is really that important, you should implement your own container with both a heap and a hash map. Then, maintain the mapping from to subscription in heap array in the hash map as you swaps around in the heap. This gives insertion, deletion, reassign priority a and minimal/maximal priority element in . (which is not a piece of cake to implement but not tedious either)  You could keep an in index on priority to allow you get at those quickly as well as insert Elements too. I've used boost mutli index for MRU/LRU situations similarly.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  