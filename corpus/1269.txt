 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm going count the most used words in a text and I want to make it this way just need little help how i'm gonna fix the Treemap.. this is how its look like now ...  //While there is still something to read..  So what i wanna do is if the NewWord is in the list then add one on Integer(key) and if not Add the word to the next list.  You do realise that word length cannot be <0 or >N where N is pretty small. You could use an ArrayList instead of a Map.  6 Answers 6  You want to have your word as the key and the count as the value. There is little value in using a sorted collection, but it is many time slower so I would use a HashMap.  ... if you want to key by length. I would use a This is because your word length is positive and bounded, and you want to ignore duplicate words which is something a Set is designed to do.  All the examples above are correctly storing the count into a map, unfortunately they are not sorting by count which is a requirement you also have.  Do not use a TreeMap, instead use a HashMap to build up the values.  Once you have the complete list of values built you can then drop the from the HashMap into a new and sort that array list by .  Or to be neater create a new "Count" object which has both the word and the count in and use that.  because your key (count) can be same sometimes where as the words will be unique... Do it the other way around... keep reading the words and check if your map contains that word... If yes, increment the count, else add the word with count = 1.  The way to solve this in a time-efficient manner is to have two maps. One map should be from keys to counts, and the other from counts to keys. You can assemble these in different passes. The first should assemble the map from keys to counts:  The second phase inverts the map so that you can read off the top-most keys:  Note that the first stage uses a HashMap because we don't need the order at all; just speedy access. The second stage needs a TreeMap and it needs a non-standard comparator so that the first value read out will be the list of most-frequent words (allowing for two or more words to be most-frequent).  124k1818 gold badges134134 silver badges202202 bronze badges  2  Yes, this would work. The second Map is overkill unless he needs a dynamic count though.  The cost of using a TreeMap to sort is asymptotically equivalent to a good sort, and does relieve the programmer from having to cook up so many classes themselves. (It's also closer to where they started from.)  7,50422 gold badges2727 silver badges3737 bronze badges  2  He's using a treemap in order to sort the results by count, this will not do that.  @TimB - Then he must be adding the words of the same length to the list (value) of the map for each count... But what makes more sense is if he uses a hashmap (yes.. I saw your answer... and you are right... )  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  