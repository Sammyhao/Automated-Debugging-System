 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I want to write a comparator that will let me sort a TreeMap by value instead of the default natural ordering.  I tried something like this, but can't find out what went wrong:  I guess what am I asking is: Can I get a passed to the comparator?  9 Answers 9  You can't have the itself sort on the values, since that defies the specification:  A that further provides a total ordering on its keys.  However, using an external collection, you can always sort however you wish, either by keys, values, or even a combination(!!) of the two.  Here's a generic method that returns a of , given a whose values are :  Now you can do the following:  Note that funky stuff will happen if you try to modify either the itself, or the within, because this is no longer a "view" of the original map like is.  Generally speaking, the need to sort a map's entries by its values is atypical.  Note on for  Your original comparator compares using . This is almost always wrong, since with operands is a reference equality, not value equality.  358k123123 gold badges550550 silver badges615615 bronze badges  7  5  if you add map.put("D", 2); the result is still "[C=1, B=2, A=3]" and not "[C=1, B=2, D=2, A=3]"  new Integer(0) == new Integer(0) You do compare a references to an objects, and You do create two objects! The out put is absolutely correct and predictable.  "Generally speaking, the need to sort a map's entries by its values is atypical" I’m a beginner here but i feel like it should be a very common thing to do? For example if i want to retrieve the 3 oldest persons in a map {"ana"=37, "peter"=43, "john"=4, "mary"=15, "Matt"=78}  @igormilla There is a simple reason, why your code works: Autoboxing uses Integer.valueOf. And that has a cache of instances for -128 to 127!  polygenelubricants answer is almost perfect. It has one important bug though. It will not handle map entries where the values are the same.  This code:...  Would output:  Note how our cow dissapeared as it shared the value "1" with our ape :O!  -1. AFASIK no implementation contain an element more than once. You just violated that constraint. From the API: Note that the ordering maintained by a sorted set must be consistent with equals.... The solution would be to change to a implementation.  @bellum: We are talking about s here. Since the violates the contract , etc doesn't work! Check this example at ideone.  Just a note, if you switch into , you have a descending values order instead of ascending.  A is always sorted by the keys, anything else is impossible. A merely allows you to control how the keys are sorted.  If you want the sorted values, you have to extract them into a and sort that.  This can't be done by using a , as it will always get the key of the map to compare. can only sort by the key.  288k5555 gold badges533533 silver badges596596 bronze badges  4  2  if the TreeMap will only pass the key to Comparator, would it feasible if i make a reference of the TreeMap in comparator's constructor, then using the key to get the value, something like this(not sure how to pass by reference) : class byValue implements Comparator { TreeMap theTree; public byValue(TreeMap theTree) { this.theTree = theTree; } public int compare(String k1, String k2) { //use getKey method of TreeMap to the value } }  @vito: no, because usually one of the two keys will not yet be in the map and you won't be able to get its value.  Isn't this an example of doing this within the Comparator of TreeMap? (even though, as mentioned above, this does break the specification for which specifies sorting by keys) beginnersbook.com/2014/07/…  @Marcus: that uses an existing map to get the values to sort by. In other words, it can't sort arbitrary values put into the later on, only values that are already in the original Map.  Olof's answer is good, but it needs one more thing before it's perfect. In the comments below his answer, dacwe (correctly) points out that his implementation violates the Compare/Equals contract for Sets. If you try to call contains or remove on an entry that's clearly in the set, the set won't recognize it because of the code that allows entries with equal values to be placed in the set. So, in order to fix this, we need to test for equality between the keys:  "Note that the ordering maintained by a sorted set (whether or not an explicit comparator is provided) must be consistent with equals if the sorted set is to correctly implement the Set interface... the Set interface is defined in terms of the equals operation, but a sorted set performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the sorted set, equal." (http://docs.oracle.com/javase/6/docs/api/java/util/SortedSet.html)  Since we originally overlooked equality in order to force the set to add equal valued entries, now we have to test for equality in the keys in order for the set to actually return the entry you're looking for. This is kinda messy and definitely not how sets were intended to be used - but it works.  I know this post specifically asks for sorting a TreeMap by values, but for those of us that don't really care about implementation but do want a solution that keeps the collection sorted as elements are added, I would appreciate feedback on this TreeSet-based solution. For one, elements are not easily retrieved by key, but for the use case I had at hand (finding the n keys with the lowest values), this was not a requirement.  A lot of people hear adviced to use List and i prefer to use it as well  here are two methods you need to sort the entries of the Map according to their values.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  