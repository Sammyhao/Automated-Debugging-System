 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Not exactly sure how to word the title but I'll explain as best I can. I have a program that originally used a 2D array of a set size and so it was defined as:  I'm now trying to dynamically allocate memory for it and it has now also become of variable size based on input. It's now defined as:  In my main method, I originally had:  Basically readUserInput takes the map array as a parameter, and assigns values to it based on user input. The map then contains values and is used in other functions.  I've updated the readUserInput function so that it dynamically sizes the array and it allocates/deallocates memory for it. This works fine, but the problem comes from the fact that now in the main method, map is not being updated. The above code in main now looks like:  but after running the readUserInput function, map is still null. Inside of the function, map is updated fine, so I'm not understanding the difference made between the changes.  3 Answers 3  What you pass to function is a pointer to array and fuction can't change it. But replacing array with pointer to pointer is incorrect in most case.Pointer to pointer suggest that have a 1D array of pointers. Which may (or may not) point to other arrays. Such data organization sometimes referred to as jagged arrays, because it allows each row to be of separate length. But on practtice jagged arrays and their subclass, sparse matrices, usually implemented as 1D array to avoid re-allocation.  To avoid decaying and to actually store a monolithic array in memory, you should use 1d array and, preferably, encapsulation for pointer arithmetic and reallocation, and then pass reference to object that stores all required states. Reference ensures that object is mutable by function ( a smart-pointer-less version for an example):  NB: this class requires a copy and move operations to be implemented if any copy must be allowed.  The function prototype would be:  With such class you can do dynamic resizing, store its size, and address element as simple as this:  248k1818 gold badges161161 silver badges285285 bronze badges  1  1  .. and here comes three star code (even if one star is hidden as reference). It must be said that we don't really need pointer to pointer to address storage of two-dimensional array.  The code you have used is a pure C-style code, and is prone to many mistakes:  You use instead of:  You use a function which gets a pointer and fills it, which is more common in C than in C++.  You use raw pointer instead of smart pointers (added in C++11), which may cause a memory leak in the end.  I've updated the readUserInput function so that it dynamically sizes the array and it allocates/deallocates memory for it.  This means that now it should be a class named Map, since it should be able to allocate/deallocate, insert and remove values, and is a valid container. Actually, you are creating a type of here, and if you don't create it for you own learning process, I strongly suggest you to use the containers!  It is possible to pass both pointer and references in C++, notice that:  You can pass a reference only if the value isn't nullptr.  When there should be a value, reference is recommended.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  