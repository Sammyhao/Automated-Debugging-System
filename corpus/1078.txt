 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have written a 2x2x2 rubiks cube solver that uses a breadth first search algorithm to solve a cube position entered by the user. The program does solve the cube. However I encounter a problem when I enter in a hard position to solve which would be found deep in the search, I run out of heap space. My computer only has 4 GB of RAM and when I run the program I give 3GB to it. I was wondering what I could do to reduce the amount of ram the search takes. Possibly by changing a few aspects of the BFS.  1 Answer 1  By definition, "Best first search" keeps the entire search frontier of possible paths through the space.  That can be exponentially large. With 3x3x3 Rubik's cube, I think there are 12? possible moves at each point, so a 10 move sequence to solve arguably requires 12^10 combinations which is well over a billion (10^9). WIth this many states, you'll want to minimize the size of the state to minimize total storage. (Uh, you actually print all the states? " outputStream.println(cubesFoundSoFar);" Isnt that a vast amount of output?)  With 2x2x2, you only have 8 possible moves at each point. I don't know solution lengths here for random problems. If it is still length 10, you get 8^10 which is still pretty big.  Now, many move sequences lead to the same cube configuration. To recognize this you need to check that a generated move does not re-generate a position already visited. You seem to be doing that (good!) and tracking the number of hits; I'd expect that hit count to be pretty high as many paths should lead to the same configuration.  What you don't show, is how you score each move sequence to guide the search. What node does it expand next? This is where best comes into play. If you don't have any guidance (e.g., all move sequences enumerated have the same value), you truly will wander over a huge space because all move sequences are equally good. What guides your solver to a solution? You need something like a priority queue over nodes with priority being determined by score, and that I don't see in the code you presented here.  I don't know what a great heuristic for measuring the score as a quality of a move sequence, but you can start by scoring a move sequence with the number of moves it takes to arrive there. The next "best move" to try is then the one with the shortest path. That will probably help immensely.  (A simple enhancement that might work is to count the number of colors on a face; 3 colors hints [is this true?] that it might take 3-1 --> 2 moves minimum to remove the wrong colors. Then the score might be #moves+#facecolors-1, to estimate number of moves to a solution; clearly you want the shortest sequence of moves. This might be a so-called "admissible" hueristic score).  You'll also have to adjust your scheme to detecting duplicate move sequences. When you find an already encountered state, that state will now presumably have attached to it the score (move count) it takes to reach that state. When you get a hit, you've found another way to get to that same state... but the score for new path, may be smaller than what is recorded in the state. In this case, you need to revise the score of discovered duplicate state with the smaller new score. This way a path/state with score 20 may in fact be discovered to have a score of 10, which means it is suddenly improved.  90.5k2121 gold badges164164 silver badges321321 bronze badges  16  The terminology for the 2x2x2 cube is slightly different. There are 8 pieces and they can be laid out in 8! potential orders, and each piece has 3 possible orientations (because each piece is a corner with 3 colors). That would give us 8! * 3^7 possible combinations. Most notably, the entire cube has 6 possible sides that could be facing towards us, and for each of those 6 sides facing us we could rotate the cube clockwise or counter clockwise to make 4 different colors show up on the top. That means there are 8! * 3^7 / (6*4) potential combinations (3.6 million). @Ira Baxter  Also I do write these positions out because I intend on having a file that contains all the positions and when the user wants to solve their cube it will search the file containing all of them and with each position in the file is the turns it took to get from that position to a solved state. So I would just fetch that position and its solution with it and print it out on the screen which is much shorter than searching all again.  I also avoid duplicate positions because the cube never rotates I perform moves on a cube for testing that can reach any position of the puzzle without having to rotate the puzzle so running into duplicate positions is not an issue each position is unique. To answer your question about what guides my solver to solve the cube is that I have a Set of turns I try on the puzzle that could potentially solve it and it goes though those move patterns over and over again to different states of the cube looking for a solution.  My guess for 2x2x2 cube with a good best first solver, that it isn't worth writing the answers to a file. You can probably solve it faster than opening a file, so just solve it. I suspect things aren't so good for 3x3x3 or larger.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  