 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have the following code that implements a BST tree in JavaScript.  I am trying to implement a function which can do a breadth first traversal of the tree. This is what I have tried so far.  I am unable to implement a function that could scale with a large number of data. I am not sure if a recursive method to traverse would be better or using a while loop. How can I implement the function? I know that the function gives unexpected behavior? What correction should I make?  2 Answers 2  You currently traverse the path from the root node to the left-most leaf.  A simple non-recursive breadth-first traversal function invoking a callback on each traversed node could look as follows:  It works by keeping an array of already discovered or traversed nodes which initially contains just your root node. Now, you iteratively replace each node in that list with its children. In above function, the children are stored in a array. At the end of each iteration, all nodes of the current level in are replaced with all their children of the next deeper level in . See also the first suggestion given by @DavidKnipe's answer.  A non-recursive approach has the advantage of not being subject to the call stack size limit. This theoretically allows you to handle larger data structures when the call stack size is limited.  17k99 gold badges5858 silver badges7171 bronze badges  2  Thanks for the detailed answer, can you explain me a bit on how the code is working?  If you're looking for a way to BFS using O(1) memory, I don't think there's a nice way to do it. (DFS is another matter though. Are you sure it has to be BFS?)  There are two ways I can see to do this. You could start with the array , and write a function that iterates over an array of nodes and then returns an array of children of those nodes. Then call that function on the array of children, and keep going down the tree until you get an empty array.  If memory is an issue, there's another way to do it. Instead of remembering the array of nodes at a given level, you could just remember the depth, then redo the iteration each time. So you'd have a function which takes a natural number and iterates over the tree, but without going deeper than , and does whatever it is you're trying to do at the th level only; then call this function for all values of until there are no more nodes left.  That last one might sound very wasteful, but it might not be too bad if the last few levels of the tree contain most of the nodes. It depends on your dataset and computational capabilities.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  