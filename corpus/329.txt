 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to use a custom class as key for an , like the following:  However, g++ gives me the following error:  I guess, I need the tell C++ how to hash class , however, I am not quite sure how to do it. How can I accomplish this tasks?  6 Answers 6  To be able to use (or one of the other unordered associative containers) with a user-defined key-type, you need to define two things:  A hash function; this must be a class that overrides and calculates the hash value given an object of the key-type. One particularly straight-forward way of doing this is to specialize the template for your key-type.  A comparison function for equality; this is required because the hash cannot rely on the fact that the hash function will always provide a unique hash value for every distinct key (i.e., it needs to be able to deal with collisions), so it needs a way to compare two given keys for an exact match. You can implement this either as a class that overrides , or as a specialization of , or – easiest of all – by overloading for your key type (as you did already).  The difficulty with the hash function is that if your key type consists of several members, you will usually have the hash function calculate hash values for the individual members, and then somehow combine them into one hash value for the entire object. For good performance (i.e., few collisions) you should think carefully about how to combine the individual hash values to ensure you avoid getting the same output for different objects too often.  A fairly good starting point for a hash function is one that uses bit shifting and bitwise XOR to combine the individual hash values. For example, assuming a key-type like this:  With this in place, you can instantiate a for the key-type:  It will automatically use as defined above for the hash value calculations, and the defined as member function of for equality checks.  If you don't want to specialize template inside the namespace (although it's perfectly legal in this case), you can define the hash function as a separate class and add it to the template argument list for the map:  How to define a better hash function? As said above, defining a good hash function is important to avoid collisions and get good performance. For a real good one you need to take into account the distribution of possible values of all fields and define a hash function that projects that distribution to a space of possible results as wide and evenly distributed as possible.  This can be difficult; the XOR/bit-shifting method above is probably not a bad start. For a slightly better start, you may use the and function template from the Boost library. The former acts in a similar way as for standard types (recently also including tuples and other useful standard types); the latter helps you combine individual hash values into one. Here is a rewrite of the hash function that uses the Boost helper functions:  And here’s a rewrite that doesn’t use boost, yet uses good method of combining the hashes:  If you didn't shift the bits and two strings were the same, the xor would cause them to cancel each other out. So hash("a","a",1) would be the same as hash("b","b",1). Also order wouldn't matter, so hash("a","b",1) would be the same as hash("b","a",1).  I am just learning C++ and one thing I always struggle with is: Where to put the code? I have written a specialize method for my key as you have done. I put this at the bottom of my Key.cpp file but I am getting the following error: . I am guessing that the compiler is not finding my hash method? Should I be adding anything to my Key.h file?  @Ben Putting it into the .h file is correct. is not actually a struct, but a template (specialization) for a struct. So it isn't an implementation -- it will be turned into an implementation when the compiler needs it. Templates should always go into header files. See also stackoverflow.com/questions/495021/…  @nightfury returns an iterator, and that iterator points to an "entry" of the map. An entry is a consisting of key and value. So if you do , you'll get the key in and the value (i.e. the string ) in . If you want the string directly, you can either use (that will throw an exception if the key doesn't exits), or (that will create an empty value if the key doesn't exist).  I think, jogojapan gave an very good and exhaustive answer. You definitively should take a look at it before reading my post. However, I'd like to add the following:  You can define a comparison function for an separately, instead of using the equality comparison operator (). This might be helpful, for example, if you want to use the latter for comparing all members of two objects to each other, but only some specific members as key of an .  You can also use lambda expressions instead of defining the hash and comparison functions.  All in all, for your class, the code could be written as follows:  Notes:  I just reused the hashing method at the end of jogojapan's answer, but you can find the idea for a more general solution here (if you don't want to use Boost).  My code is maybe a bit too minified. For a slightly more readable version, please see this code on Ideone.  @WhalalalalalalaCHen: Please take a look at the documentation of the constructor. The represents the so-called "bucket count". A bucket is a slot in the container's internal hash table, see e.g. for more information.  @WhalalalalalalaCHen: I picked at random. Depending on the content you want to store in your , the bucket count can affect the performance of the container.  Most basic possible copy/paste complete runnable example of using a custom class as the key for an (basic implementation of a sparse matrix):  For enum type, I think this is a suitable way, and the difference between class is how to calculate hash value.  STL Does not provide hash function for pairs. You need to implement it yourself and either specify as template parameter or put into namespace std, from where it will be automatically picked up. Following https://github.com/HowardHinnant/hash_append/blob/master/n3876.h is very useful for implementing custom hash functions for structutres. More details are well explained in the other answers to this question, so I won't repeat that. There is also similar thing () in the Boost.  must create a hash function for the class (for primitive types like int and also types like string the hash function is predefined)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  