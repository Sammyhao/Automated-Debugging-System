 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Basically the problem is to find the no of connected components in the graph and no of ways of choosing a one node from each connected component,which is equal to the product of the no of nodes in each connected components in the graph.  Eg: {1,2,3} and {3,4} no of ways of choosing one node is 3*2=6  This solution is giving me time limit exceeded.I have seen other solutions in C++ with exactly same logic using vector get accepted,but I am not comfortable with C++ as of now. Please help me with further optimization of this code to get this solution accepted! :-)  16922 gold badges22 silver badges1111 bronze badges  3  Is this actually providing a correct solution? You are using new in your insert function as a variable which is a keyword in C++. That might be your problem.  Yeah,it does provide the correct solution.I have checked with multiple test cases.However,recursive dfs doesn't seem to be the problem as many solutions have been accepted with it.  2 Answers 2  I submitted the answer on the Codechef site and it got accepted and the reason for slowing of your code is:  So the trick is to keep a pointer to the last node of every vertex linked list.  First declare an array of pointers to hold the last pointers.  7,71333 gold badges2323 silver badges4444 bronze badges  1  That never occurred to me,now I realize it is a good way to optimize in all types of cases where lists are used.Nice one.  You could of course just insert the new node at the beginning of the list instead of appending it since the order of edges in the adjacency list doesnt matter. In C++ it would be:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  