 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Debugging some code in Visual Studio 2008 (C++), I noticed that the address in my function pointer variable is not the actual address of the function itself. This is an extern "C" function.  The disassembly of taking the function address is:  EDIT: I viewed the code at address 013C4F10 and the compiler is apparently inserting a "jmp" instruction at that address.  There is actually a whole jump table of every method in the .exe.  Can someone expound on why it does this? Is it a debugging "feature" ?  19.5k11 gold badge5454 silver badges7878 bronze badges  8  1  Hmm, what is telling you the address of is ? Looking at the disassembly it seems like the address of print is indeed and that's the value being stored in  @Martin: When I switch to release mode the jump table goes away and the address is indeed the actual function address.  There's a book called 'Linkers and Loaders' (amazon.com/Linkers-Kaufmann-Software-Engineering-Programming/dp/…) which explains about this. It's a while since I read it, and the MS environment wasn't of primary interest - but there is indeed a jump table which allows for dynamic loading of shared libraries.  it's probably to do with the interaction between the linker, and the need to call code in DLLs This article talks about it, I'm not 100% sure how it applied to your example but it seems like it might help you understand msdn.microsoft.com/en-us/library/aa271769(VS.60).aspx  3 Answers 3  That is caused by 'Incremental Linking'. If you disable that in your compiler/linker settings the jumps will go away.  I'm going to hazard a guess here, but it's possibly to enable Edit-and-Continue.  Say you need to recompile that function, you only need to change the indirection table, not all callers. That would dramatically reduce the amount of work to do when the Edit-and-Continue feature is being exercised.  sounds reasonable, but then the function pointer would still point to the old (non-edited) function... perhaps there's a bug in the debugger? :)  @Martin: no, the function pointer always points to the jump table, so that when edit and continue recompiles the function, only the jump table gets modified. The function pointer value does not change, ever. That's the beauty of it, really. Imagine your code stores a function pointer somewhere in memory. Edit and Continue has no way to update that. But by pointing it to a jump table, modifying the jump table catches all the potential usages of the function at once.  that's not what the disassembly above looks like since the pointer isn't set to point at the jump table but directly to the function instead  The compiler is inserting a "jmp" instruction at that address to the real method.  There is actually a whole jump table of every method in the .exe.  It is a Debugging feature. When I switch to release mode the jump table goes away and the address is indeed the actual function address.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  