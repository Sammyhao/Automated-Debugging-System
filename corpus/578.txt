 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  4,07366 gold badges1818 silver badges1515 bronze badges  3  14  This question appears to be off-topic because it is about computer science and should be asked on cs.stackexchange.com  I feel like it relates to both stack exchange and stack overflow. So having it here is fine  7 Answers 7  All average times on this table are the same as their worst times except for Insert.  : everywhere in this answer, BST == Balanced BST, since unbalanced sucks asymptotically  : using a trivial modification explained in this answer  : for pointer tree heap, for dynamic array heap  Advantages of binary heap over a BST  average time insertion into a binary heap is , for BST is . This is the killer feature of heaps.  binary heaps can be efficiently implemented on top of either dynamic arrays or pointer-based trees, BST only pointer-based trees. So for the heap we can choose the more space efficient array implementation, if we can afford occasional resize latencies.  search for arbitrary elements is . This is the killer feature of BSTs.  For heap, it is in general, except for the largest element which is .  "False" advantage of heap over BST  heap is to find max, BST .  This is a common misconception, because it is trivial to modify a BST to keep track of the largest element, and update it whenever that element could be changed: on insertion of a larger one swap, on removal find the second largest. Can we use binary search tree to simulate heap operation? (mentioned by Yeo).  Actually, this is a limitation of heaps compared to BSTs: the only efficient search is that for the largest element.  bottom tree levels have exponentially more elements than top levels, so new elements are almost certain to go at the bottom  In a binary heap, increasing the value at a given index is also for the same reason. But if you want to do that, it is likely that you will want to keep an extra index up-to-date on heap operations How to implement O(logn) decrease-key operation for min-heap based Priority Queue? e.g. for Dijkstra. Possible at no extra time cost.  GCC C++ standard library insert benchmark on real hardware  I benchmarked the C++ (Red-black tree BST) and (dynamic array heap) insert to see if I was right about the insert times, and this is what I got:  The zoomed graph excludes essentially only the array resize points, and shows that almost all inserts fall under 25 nanoseconds.  BST is logarithmic. All inserts are much slower than the average heap insert.  gem5 is a full system simulator, and therefore provides an infinitely accurate clock with with . So I tried to use it to estimate timings for individual inserts.  Interpretation:  heap is still constant, but now we see in more detail that there are a few lines, and each higher line is more sparse.  This must correspond to memory access latencies are done for higher and higher inserts.  TODO I can't really interpret the BST fully one as it does not look so logarithmic and somewhat more constant.  With this greater detail however we can see can also see a few distinct lines, but I'm not sure what they represent: I would expect the bottom line to be thinner, since we insert top bottom?  Heap operations only need to bubble up or down a single tree branch, so worst case swaps, average.  Keeping a BST balanced requires tree rotations, which can change the top element for another one, and would require moving the entire array around ().  Heaps can be efficiently implemented on an array  Parent and children indexes can be computed from the current index as shown here.  There are no balancing operations like BST.  Delete min is the most worrying operation as it has to be top down. But it can always be done by "percolating down" a single branch of the heap as explained here. This leads to an O(log(n)) worst case, since the heap is always well balanced.  If you are inserting a single node for every one you remove, then you lose the advantage of the asymptotic O(1) average insert that heaps provide as the delete would dominate, and you might as well use a BST. Dijkstra however updates nodes several times for each removal, so we are fine.  The dynamic array implementation is more space efficient. Suppose that each heap element contains just a pointer to a :  the tree implementation must store three pointers for each element: parent, left child and right child. So the memory usage is always (3 tree pointers + 1 pointer).  Tree BSTs would also need further balancing information, e.g. black-red-ness.  the dynamic array implementation can be of size just after a doubling. So on average it is going to be .  On the other hand, the tree heap has better worst case insert, because copying the backing dynamic array to double its size takes worst case, while the tree heap just does new small allocations for each node.  Still, the backing array doubling is amortized, so it comes down to a maximum latency consideration. Mentioned here.  Philosophy  BSTs maintain a global property between a parent and all descendants (left smaller, right bigger).  The top node of a BST is the middle element, which requires global knowledge to maintain (knowing how many smaller and larger elements are there).  This global property is more expensive to maintain (log n insert), but gives more powerful searches (log n search).  Heaps maintain a local property between parent and direct children (parent > children).  The top node of a heap is the big element, which only requires local knowledge to maintain (knowing your parent).  Comparing BST vs Heap vs Hashmap:  BST: can either be either a reasonable:  unordered set (a structure that determines if an element was previously inserted or not). But hashmap tends to be better due to O(1) amortized insert.  sorting machine. But heap is generally better at that, which is why heapsort is much more widely known than tree sort  heap: is just a sorting machine. Cannot be an efficient unordered set, because you can only check for the smallest/largest element fast.  hash map: can only be an unordered set, not an efficient sorting machine, because the hashing mixes up any ordering.  Doubly-linked list  A doubly linked list can be seen as subset of the heap where first item has greatest priority, so let's compare them here as well:  insertion:  position:  doubly linked list: the inserted item must be either the first or last, as we only have pointers to those elements (unless we have a pointer to the position of interest e.g. during iteration)  binary heap: the inserted item can end up in any position. Less restrictive than linked list.  time:  doubly linked list: worst case since we have pointers to the items, and the update is really simple  binary heap: average, thus worse than linked list. Tradeoff for having more general insertion position.  search: for both  An use case for this is when the key of the heap is the current timestamp: in that case, new entries will always go to the beginning of the list. So we can even forget the exact timestamp altogether, and just keep the position in the list as the priority.  This can be used to implement an LRU cache. Just like for heap applications like Dijkstra, you will want to keep an additional hashmap from the key to the corresponding node of the list, to find which node to update quickly.  Comparison of different Balanced BST  Although the asymptotic insert and find times for all data structures that are commonly classified as "Balanced BSTs" that I've seen so far is the same, different BBSTs do have different trade-offs. I haven't fully studied this yet, but it would be good to summarize these trade-offs here:  Red-black tree. Appears to be the most commonly used BBST as of 2019, e.g. it is the one used by the GCC 8.3.0 C++ implementation  AVL tree. Appears to be a bit more balanced than BST, so it could be better for find latency, at the cost of slightly more expensive finds. Wiki summarizes: "AVL trees are often compared with red–black trees because both support the same set of operations and take [the same] time for the basic operations. For lookup-intensive applications, AVL trees are faster than red–black trees because they are more strictly balanced. Similar to red–black trees, AVL trees are height-balanced. Both are, in general, neither weight-balanced nor mu-balanced for any mu < 1/2; that is, sibling nodes can have hugely differing numbers of descendants."  WAVL. The original paper mentions advantages of that version in terms of bounds on rebalancing and rotation operations.  285k8181 gold badges10431043 silver badges844844 bronze badges  27  6  I +1ed, but the "paper" justifying average O(1) binary heap insertion is now a dead link, and the "slides" just state the claim without proof. Also I think it would help to clarify that "average case" here means the average assuming that inserted values come from some particular distribution, so I'm not sure how "killer" this feature really is.  BST and balanced BST seem to be used interchangably. It should be made clear that the answer refers to balanced BST to avoid confusion.  @Bulat I feel we're digressing a little, but if we want both max and min at the same time, we might run into issues with maintaining two heaps if we're not careful - stackoverflow.com/a/1098454/7154924. It's probably better to use a max-min heap (due to Atkinson et al.), which is specifically designed for this purpose.  @CiroSantilli新疆改造中心六四事件法轮功 : I don't understand why the delete operation of a binary heap is O(log n). This only works if you have a pointer to the element in the heap, but in most use cases, you have the key and you need to find the element first which takes O(n).  Heap just guarantees that elements on higher levels are greater (for max-heap) or smaller (for min-heap) than elements on lower levels, whereas BST guarantees order (from "left" to "right"). If you want sorted elements, go with BST.  10.8k99 gold badges4646 silver badges7777 bronze badges  2  11  "Heap just guarantees that elements on higher levels are greater (for max-heap) or smaller (for min-heap) than elements on lower levels, …" – the heap does not enforce this per level, but only in parent–child-chains. represents a valid min-heap, but the on level 3 is smaller than on level 2. For a visualization, see e.g. the and elements in the sample Wikipedia image for heaps. (Also note that the inequality relations between elements are not strict, since elements are not necessarily unique.)  Sorry for late entry but I just want to get clarity. If the Binary Heap is sorted, then worst case for search would be log n right. So in that case, are sorted Binary Heaps better than Binary Search Trees(Red-Black BST). Thank you  Heap is better at findMin/findMax (), while BST is good at all finds (). Insert is for both structures. If you only care about findMin/findMax (e.g. priority-related), go with heap. If you want everything sorted, go with BST.  First few slides from here explain things very clearly.  While insert is logarithmic for both in the worst case, the average heap insert takes constant time. (Since most of the existing elements are on the bottom, in most cases a new element will only have to bubble up one or two levels, if at all.)  @Yeo: Heap is better for findMin xor findMax. If you need both, then BST is better.  I think this is just a common misconception. A binary tree can be easily modified to find min and max as pointed by Yeo. This is actually a restriction of the heap: the only efficient find is min or max. The true advantage of the heap is O(1) average insert as I explain: stackoverflow.com/a/29548834/895245  As mentioned by others, Heap can do or in O(1) but not both in the same data structure. However I disagree that Heap is better in findMin/findMax. In fact, with a slight modification, the BST can do both and in O(1).  In this modified BST, you keep track of the the min node and max node everytime you do an operation that can potentially modify the data structure. For example in insert operation you can check if the min value is larger than the newly inserted value, then assign the min value to the newly added node. The same technique can be applied on the max value. Hence, this BST contain these information which you can retrieve them in O(1). (same as binary heap)  In this BST (Balanced BST), when you or , the next min value to be assigned is the successor of the min node, whereas the next max value to be assigned is the predecessor of the max node. Thus it perform in O(1). However we need to re-balance the tree, thus it will still run O(log n). (same as binary heap)  I would be interested to hear your thought in the comment below. Thanks :)  You could certainly store the maximum and/or minimum value of a BST, but then what happens if you want to pop it? You have to search the tree to remove it, then search again for the new max/min, both of which are O(log n) operations. That's the same order as insertions and removals in a priority heap, with a worse constant.  @JustinLardinois Sorry, I forget to highlight this in my answer. In BST, when you do pop min, the next min value to be assigned is the successor of the min node. and if you pop the max, the next max value to be assigned is the predecessor of the max node. Thus it still perform in O(1).  Correction: for or it is not O(1), but it is O(log n) because it has to be a Balanced BST which need to be rebalance every delete operation. Hence it the same as binary heap or which run O(log n)  You can get the first min/max, but getting kth min/max would go back to normal BST complexity.  A binary search tree uses the definition: that for every node,the node to the left of it has a less value(key) and the node to the right of it has a greater value(key).  Where as the heap,being an implementation of a binary tree uses the following definition:  If A and B are nodes, where B is the child node of A,then the value(key) of A must be larger than or equal to the value(key) of B.That is, key(A) ≥ key(B).  92544 gold badges2020 silver badges3333 bronze badges  1  "heap, being an implementation of binary tree" - just pointing out that a heap is a kind of binary tree, not a kind of BST  Another use of BST over Heap; because of an important difference :  finding successor and predecessor in a BST will take O(h) time. ( O(logn) in balanced BST)  while in Heap, would take O(n) time to find successor or predecessor of some element.  Use of BST over a Heap: Now, Lets say we use a data structure to store landing time of flights. We cannot schedule a flight to land if difference in landing times is less than 'd'. And assume many flights have been scheduled to land in a data structure(BST or Heap).  Now, we want to schedule another Flight which will land at t. Hence, we need to calculate difference of t with its successor and predecessor (should be >d). Thus, we will need a BST for this, which does it fast i.e. in O(logn) if balanced.  EDITed:  Sorting BST takes O(n) time to print elements in sorted order (Inorder traversal), while Heap can do it in O(n logn) time. Heap extracts min element and re-heapifies the array, which makes it do the sorting in O(n logn) time.  74022 gold badges99 silver badges2424 bronze badges  5  1  Yes. It is from unsorted to sorted sequence. O(n) time for inorder traversal of a BST, which gives sorted sequence. While in Heaps, you extract min element and then re-heapify in O(log n) time. SO, it will take O(n logn) to extract n elements. And it will leave you with a sorted sequence.  Well, from unsorted sequence to BST I don't know a method based on key comparison with less than O(n logn) time, which dominates the BST to sequence part. (Whereas there is O(n) heap construction.). I'd consider it fair (if pointless) to state heaps being close to unsortedness and BSTs sorted.  What I am trying to explain here is that if you have a BST and also a Heap of n elements => then all elements could be printed in sorted order from both data structures and BST can do it in O(n) time (Inorder traversal), while Heap would take O(n logn) time. I don't understand what you are trying to say here. How do you say BST will give you sorted sequence in O(n logn).  I think you are also considering time taken to build a BST and a Heap. But I assume you already have it, that you have build it over the time and now you want to get the sorted result. I am not getting your point?  Insert all n elements from an array to BST takes O(n logn). n elemnts in an array can be inserted to a heap in O(n) time. Which gives heap a definite advantage  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  