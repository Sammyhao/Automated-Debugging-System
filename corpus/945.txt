 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I developed the following sorting algorithm but there are some run time errors that I cant figure out. The program terminates when it comes to the part of filling the array. I'm still a beginner in ada so I couldn't figure out where the problem is...  Does your compiler not output an actual error message, perhaps with a stack trace or (at least) an indicator of the line that it fails on?  The compiler clearly won't output anything for a runtime error : it's good, but it can't see the future! However (assuming Gnat) compiling with the right flags, the runtime exception will give a stack trace which addr2line can translate into source locations. In my experience, spookily close to what went wrong...  3 Answers 3  Your Problem is that you are insisting on writing Ada code using c - Style programming paradigms.  Firstly:  The declarations:  Where you use as parameters to procedures are useless in Ada. You are trying to pass a pointer to an array in (which you are doing!), but you should just pass your as - The Ada compiler knows to do this as a pointer!  Secondly:  I cannot see where you actually allocate any memory to . This is a possible source of your runtime error. (when you write to or index an array that does not exist, i would expect to have a problem!)  Thirdly: You seem to be mixing fixed length arrays with variable length input. If N > 20, you will have a problem.  Fourthly: Insulting the language is not the best way of getting help from those who like it.  2,98311 gold badge1616 silver badges3434 bronze badges  7  @NMWS What you mentioned is perfectly the right solution. But about the point of N>20... How can I solve this problem, is there is a way I can add size to my array?  – user3459170  Mar 29 '14 at 15:19  For an array of the correct size N, see the first part of my answer.  @BrianDrummond I solved the problem of the runtime error, but it seems there is another problem; the subprograms are mostly not called... The code is updated above. Thanks in advance :)  – user3459170  Mar 29 '14 at 16:58  @BrianDrummond the code above is updated with a variable sized array. But still the subprograms are mostly not called.  – user3459170  Mar 29 '14 at 17:15  And there's a good but more subtle reason for that : the for loop bounds are empty ranges, reversed... see edit to my answer.  NWS has nailed it : there is a pointer, but no array there.  But it's clear that you have learned C, which leaves you with a lot to learn about other languages including Ada. There really are better ways of doing many things, that aren't taught to C programmers because C doesn't allow them.  Allocating variable sized arrays without pointers, malloc and free for example...  Using the type system better...  Bad programming :  This is bad because it violates the DRY principle : loop bounds repeated, and something that hopefully represents the array size passed around as a separate parameter... a maintenance nightmare if you decide to rename to something meaningful for example.  better programming : Use the type system. Recognise that merely declaring an array has declared a new subtype of integer, representing the index of the array. You can access it as , and the high bound as .  And accidents such as redefining n after the array declaration can no longer generate buffer overflows. NOTE: Heapsort now gets its range from the array. (Max_Heapify may still need a separate parameter to operate on subsets of the array)  Arguably best - if it makes the intent clearer - name the index datatype explicitly and use it...  And lastly, which do you prefer; a Storage_Error exception immediately the bug occurs (writing to memory you forgot to allocate) or something odd happening much later because something scribbled across another variable?  EDIT  Having cleared up the major issues two more subtle ones remain...  If I compile the modified program (in Gnat 4.8) I get several warnings : one of them is important and tells you exactly what the problem is...  Most of the warnings stem from the fact that  declares its own loop variable which hides any existing in-scope declaration. So you can tidy up the code by removing the unnecessary declarations.  What remains is:  sort.adb:51:28: warning: loop range may be null sort.adb:51:28: warning: bounds may be wrong way round  The for loop bounds are empty ranges, reversed...  declares a subtype with 3 values  declares the same subtype and iterates backwards over it.  But declares an EMPTY subtype (containing NO valid values) so iterating over it - either way round - does precisely nothing.  Hopefully that is the missing part of the puzzle. I'm not clear why one faulty loop gets this warning while the other (at line 38) doesn't...  17.8k11 gold badge2525 silver badges3939 bronze badges  3  perfectly informative @Brian. You helped me alot :)  – user3459170  Mar 29 '14 at 15:20  And leaving the one at line 38 as-is results in a reverse sort! Amazing and unexpected.  Mr. Brian you helped me a lot today... much appreciated sir. god bless you :) @SimonWright thank you so much sir :)  I think you want just 'and' instead of 'and then,' although I haven't looked at Ada code in years.  This is not the problem, but thanks anyway. Ada is the most retarded lang I've ever seen  – user3459170  Mar 29 '14 at 10:44  2  No, you really DO want to specify the order of the operations, and avoid optimiser scheduling the (potentially out of range) array access before the check. Arguably its the languages that allow one or other of these strategies but not both, that are retarded.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  