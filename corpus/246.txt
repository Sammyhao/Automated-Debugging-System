 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm working on an items system for a game that we're making similar to the old classical Resident evil titles. Currently, I'm implementing items combining, where you combine different items with each other to get something new. Complications come from the fact that there exist items that have more than one level of transformation, and more than one mate for each level. Allow me to clarify, let's assume that we have a green, red and blue herbs. You can't combine red+blue, however you can combine G+B you'd get something like a GreenBlueHerb, or G+R to get GreenRedHerb, now if you combine either of these results to a blue herb, you'd get a GreyHerb. As you see from this example, there are 2 levels of transformation for the green herb, for it to reach the first level, there are two possible mates, (red|blue), from that point going to level two, there's only one mate (blue).  So I came up with an interesting tree, covering all possibilities going down nLevels, not just 2, the more the levels the more complex the tree, have a look at this example of 3 levels, the triangle shape you see in the middle represents an item, and the other colored shapes around it represents possible mates for it to reach the next level:  There's a lot of different combinations, I could first combine my item with the blue one, then the red, then the green, or green, then red, then blue, etc. To reach my final level. I came up with this tree representing all the possible combinations:  (Numbers to the right are the #levels, to the left are the #nodes at each level) But as you can see, it's redundant. If you look at the end nodes they should all be one, because they're all leading to the same final result, which is G+R+B. There are actually 7 possible states in total for this situation, here is the right tree:  This makes a lot of sense, notice the huge difference on the number of nodes.  Now my question is, what is the right data structure for this? - I'm pretty sure there's no built-in one for this, so I'm gonna have to make my own custom one, which I actually did, and manage to get it working but with a problem. (One thing worth mentioning is that I'm getting the nodes information from an XML file, by information I mean the itemRequired to reach a node/level and what's gonna be the name of my item at that node, ex: for the green herb to reach the RedGreenHerb state, it 'requires' a RedHerb, when that combination happens, the name "GreenHerb" will change to "RedGreenHerb" and if you're wondering what happens to the RedHerb, it just disappears, I don't need it anymore), here are my data structures:  Let me explain: The is actually the base node, which has the item's name at start (GreenHerb for ex), the tree has a number of levels (the lines in black you see in the pictures), each level has a number of nodes, each node carries with it a new item data and a number of nodes to point to as well (children nodes). Now you might be asking what is the need to put a list of nodes in the class? - I will answer that after I show you how I'm getting the data from my XML file:  }  Here's an XML sample to make everything clear: ItemName->Level->Path (which is nothing but a node)->Path data  Now the problem with doing it like that, is that the nodes aren't connected with each other, so what, what does that imply? Well, if an item takes a certain path to a certain level, then we certainly don't need to keep storing the other paths, which it didn't take, so why keeping them in memory? (there's no transforming back, once you take a path, that's it you're obliged to follow that path, and never look back) What I would like to have, is when I take out a node, all the rest of nodes under it will fall as well, which makes sense, but currently the way I'm doing it so far is something like this:  As you can see the nodes are not connected, what's holding them is the levels! which means that, there is no way for me currently to take out a node, in a way that it takes out all its child nodes. (Doing it without the fact that nodes are connected is really tough and a will degrade performance a lot) Which brings us to:  I first connect the nodes, and then remove the levels? why, because if I don't, then each node has two references to it, one from its parent node and other from the current level. Now is actually for the long tree I showed, and not for the optimized one that has 7 states:  This is ultimately what I want to have on my other tree, but I don't know how to. I want to connect the nodes and form the 2nd tree I showed, which is relatively simpler than 4 levels for ex, I couldn't even connect the nodes in paint! (when I tried 4 levels)  If you stare at it, you'll find some resemblance to binary numbers, here's my tree in a binary form:  Each '1' represents an actual item, '0' means empty. From my tree, '001'=Blue, '010'=Green, '100'=Red, '011' means Green+Blue, ... '111'=Grey (final level)  So now I got everything explained, first: is my approach correct? If not then what is? If so, then what is the data structure I could use/make to achieve this? and if the data structures I came up with are in their place, how can I store the data from the XML file to my data structure in a way that, connects the nodes together so whenever I take out a node it takes out its children nodes with it?  Thanks a lot in advance for your help and patience :)  EDIT: Interesting to note that, this whole system is for items that occur only once throughout the game (gets picked up once). This is why whenever I take a path, I remove it from memeory, and also whenever I pick up an item, I remove its entry from the database because I won't encounter it again.  EDIT: Please note that I don't only represent my items via just strings, they have a lot of other properties. But in this situation I only care about their names, that's why I'm dealing with strings.  4,89399 gold badges4343 silver badges7575 bronze badges  6  Is your question related to find the best data structure for this, or the best approach to code this problem ?  Well, shouldn't the best approach come from the best/suitable data structure for it?  It depends what you mean by data structure. What i'm trying to ask is "is this a pure theorical approach", or "does this code have to be easily maintainable for future developments" (real game project for instance) ?  By data structure I mean the structure that's gonna hold everything together (how the nodes will communicate/connect with each other, the classes/structs used, etc) - 'real game project'? how much real is real? I'm already doing this for a 'real' game project. And yes, I would like it to be maintainable of course.  2 Answers 2  Difficult to maintain since your xml is based on a graph.  Don't really take advantage of OOP  Source of bugs  Probable use of for small problems (I say small because if your do a such game you'll face far more difficults problems ;) ). This implies unnecessary complexity.  What I like in this solution :  You have just perfectly understood the problem. Each item have a list of transormations with some other objects. Now the problem is how to represent (and not store) it  What i would have do (juste IMHO, your solution is good, too) : use OOP in a node-only point of view. So your tree will become a state machine (as you were speaking about path ;) ) if you want to attach that to a data structure.  Then just call to get the result. You can also do and easily debug.  I try to keep my example as simple as possible. A lot of modifications can be done in order to light up the code (a class , a class , use LINQ queries, etc...)  2,72011 gold badge1919 silver badges3333 bronze badges  8  Actually, what you just came up with is exactly the way I'm gonna handle 'HealthItems' - in general: items that occur more than once in the game, for a number of reasons one of them is there's no need to be a db for them because the numbers are limited (herbs, drugs, syringes, etc). I can pre-define all that via code. And I actually do have a lot of OOP going on, (inheritance, interfaces, etc) I just didn't show it. Also, the part where you mentioned dictionary, I do have a dictionary as well, with something very similar to yours.  But doing this to all 'other' type of items is just a lot of manual work, I can get away with a general solution that covers the "Other" category of items. Check out this thread for more info on my items gamedev.stackexchange.com/questions/59884/… - I have something in mind, I will see if I can answer my self. I will also look into your idea as well.  Plus, the benefit of my db approach is that now the even game designer/artist could set the mates/levels/paths, I've already made a simple C# app for him to interact with and use for generating xml files.  Ok, now it make sense. Do you know that you can generate classes automatically in c# (the same way as your xml)?  What I cant figure out is how your objects exist. Are they just strings ? Because THIS could be a pain to deal with in your game in order to maintain it.  OK, finally after fiddling around and staring at the whole system for a couple of hours, I came up with an idea yesterday, I implemented it, and it worked pretty well :) I just tested it on 3 level of transformations and it worked like magic. (the pic shows only one combo, but I assure you, all the combos work)  Allow me to share my solution. There was a few tweaks I had to make on my previous system, I will say first what the tweaks are, and then why I made each one.  I changed the data stored at each node. In my previous approach, I had each node depend on the previous one, now, nodes requirements comes directly from the root.  Here's how the struct looks now:  Node constructor:  An example of how requirements are handled now:  XML is now:  I added a node to my tree, and removed the list it had, this makes more sense. That previous list is now equal to  Here's how the tree looks now:  Now, why did I make the first change? (the requirements) Because this allowed me to have some communication going on between the nodes, which in turn allowed me to finally connect them the way I exactly wanted (the way they're connected in the 7-states tree ^ above in my Q) How? - In my necklace example, what's the connection between L.1_A and L.2_A? The answer is, L.1_A has one of L.2_A's requirements, which is the BlueGem, they both have it in common which leads us to the conclusion:  Whenever two nodes separated by one level in between have something in common, the node in the above level should point to the one above  So all I do is just go over all nodes in one level, and compare each of that level nodes with each node in the next level, if the node in the first level has one requirement that the node in the next level has, There's is a connection:  Notice the very important line:  It's clear right? - I'm just connecting the root node to the nodes in the first level, and then I connect the nodes of level1 to 2, 2 to 3, etc. Of course, I have to do this before clearing the levels. That didn't change:  Why did I make my second change? (added a root node to the tree). Well, you can clearly see the benefits of having a root node, it makes more sense. But the main reason I implemented this root idea, is to nuke out easily the nodes that I won't take. I mentioned in my Q that whenever I take a path/node, the nodes in that same level should be gone, because that's it, I have taken a road, no going back. With the root at hand, now I could easily say:  No need to go over the nodes I didn't take and null them, just change the root of the tree to the node I took, which has the extra benefit of relieving me from the burden of treating my tree as some sorta linked list, (to access a node down the tree, I have to go through the root, and what's between the root and the node I want to access, and finally reach my destination) - After each transform the root goes down one level, all I need to access now is the root's nodes.  One more problem left. This is a method inside my custom made dictionary to handle items, when an item transforms, it 'notifies' the dictionary to take the necessary actions (update its keys, values, etc)  What does do? My first change introduced a problem. For ex: When I reach L.1_A, I already have the BlueGem in possession right? otherwise I wouldn't have reached this level. But the problem is that all the nodes, after this level that required a BlueGem as well, still require it now, even though I have it! They shouldn't ask for it, ie. BlueGreenNecklace should only require now a GreenGem - Which is why now I have to Update those nodes requirements, by going down recursively starting from my new root:  Here's the method:  All I'm saying, "dear next level node, if you require something I already have, please remove that requirement" - And that's it :) Hope you liked my article XD - I will put my next video demo in the question's update when it's out.  Performance-wise? Hmm, there's a couple of places I could do some optimizations, but for now, testing it with 3 levels was really good, no degrade at all. I doubt my game designer will come up with something that requires more than 4 levels, but even if he does, my code should be fast enough, and if not, I could use in proper places to divide the work on different frames (I'm using Unity3D)  What I really like about this solution is that it works for all kinds of transformation trees, even if it wasn't symmetric, for nPaths and nLevels :)  Thanks to anyone who tried to help, and took the time to read this. -- Vexe  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  