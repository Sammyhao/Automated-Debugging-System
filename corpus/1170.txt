 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  What I am trying to do is to implement a heuristic approach to NP complete problem: I have a list of objects (matches) each has a double score. I am taking the first element in the list sorted by the score desc and then remove it from the list. Then all elements bound to the first one are to be removed. I iterate through the list till I have no more elements.  I need a data structure which can efficiently solve this problem, so basically it should ahve the following properties: 1. Generic 2. Is always sorted 3. Has a fast key access  Right now looks like the best fit.  The question is: is it the most optimal choice for in my case?  3,28655 gold badges2828 silver badges3939 bronze badges  5  Which elements are bound to the first element in the list? How do you maintain this binding?  Obviously you do something with all those removed items, or you could just cleared sortedItems in the first place...  Unfortunately I cannot clear sortedItems - it is not empty after only one iteration.  They are empty after you get out of the top . If you're not doing anything besides removing the items, you might as well skip the whole thing.  3 Answers 3  I assume you're not just wanting to clear the list, but you want to do something with each item as it's removed.  2,51211 gold badge2424 silver badges4242 bronze badges  1  I realized I don't really want to remove anything, since it would be more expensive just hit and run (search and add)  I think you should use two data structures - a heap and a set - heap for keeping the sorted items, set for keeping the removed items. Fill the heap with the items, then remove the top one, and add it and all its dependents to the set. Remove the second one - if it's already in the set, ignore it and move to the third, otherwise add it and its dependents to the set.  Each time you add an item to the set, also do whatever it is you plan to do with the items.  The complexity here is O(NlogN), you won't get any better than this, as you have to sort the list of items anyway. If you want to get better performance, you can add a 'Removed' boolean to each item, and set it to true instead of using a set to keep track of the removed items. I don't know if this is applicable to you.  36.2k1313 gold badges8585 silver badges156156 bronze badges  3  I am currently having a similar idea: I will use a hash set to store all avaliable matches and a list which will be sorted by score. I will iterate over the list (and check if the element is still in the hashset, if yes -> remove, otherwise do nothing.  It looks like you gave the same answer I did, but it took me longer. But why would you claim it's O(NlogN)? Assuming HashSet doesn't degenerate into a linked list, it should be O(N) where N is the total number of DependentElements (instead of the main SortedItems).  what i need to do is: while (dictionary.Any()) { first = dictionary.First(); dictionary.Remove(first); foreach (var dependentFirst in first.DependentElements) { dictionary.Remove(dependentFirst); } } and do it very efficiently  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  