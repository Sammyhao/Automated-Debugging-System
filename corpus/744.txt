 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  For some reason, I have to implement this myself , and can not use libs. To make it map fast, firstly, I map the key to an integer, and use that integer as an internal key. Then I implement the Map, which gives me the mapping function. However, when I use the string key to compute the internal integer key, sometimes I get the same integer from different string. How can I solve the problem?  3 Answers 3  You cannot avoid this. There are more possible strings than integers, therefore hash collisions are imminent. Read up on hashmaps - it's a data structure that explicitly takes collisions into account and works around them.  A map data structure and "collision" cannot be separated. the way you started your implementation seems fine, here's how you should handle collisions :  Adding a new entry into the map  calculate for  compute from hashcode (more or less = % )  if is not null  if keyset[index] != key (ie. for strings, use strcmp) increment modulus , then goto 3  Getting a value from the map  calculate for  compute from hashcode (more or less = % )  if keyset[index] != key (ie. for strings, use strcmp) increment modulus , then goto 3  Deleting an entry from the map  calculate for  if keyset[index] != key (ie. for strings, use strcmp) increment modulus , then goto 3  set and to null  As you can see, you can put step 1 to 3 into a function and most of the work is done  ** EDIT **  Of course, you also have to check if your map is not full before (or while) adding a new entry, otherwise you'll just loop undefinitely.  46.9k2323 gold badges115115 silver badges186186 bronze badges  3  Your loop in "adding a new entry" will never terminate if the same key has already been added.  Your deletion function is also incorrect - if you add followed by which have the same hash, then delete , is lost (won't be found by the function).  This is what is known as a collisions, but the simplest is to make each bucket in your Hashmap a list of items with the same hash. Then on a get all you have to do is iterate through the list until you find the item you are looking for.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  