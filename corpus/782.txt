 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  In the program below I've a . What I want to do is to implement a hash table. I'm trying to use since I heard that is the efficient as it takes O(1) time. I use my everywhere in my main program (another program that I'm working on) so I don't want to change that. I want to implement hash table in one of the functions and I'm trying to figure out how to insert the contents of my map into the hash table and search for the key later. I've inserted a comment in two places where I'm having trouble. Please help.  I appreciate any help or comments.  After reading Jason's comments I understand why i cannot use a as a key in so I tried to use as a key but the function won't work. Could you please help me.  2,52755 gold badges3333 silver badges6666 bronze badges  1  1  Make sure you're compiling with C++0x support ... that may require you to set the proper flag with gcc, such as or ... you'll also need to re-define you key-values, as you can't directly convert an to a without using a helper function.  1 Answer 1  The basic element you're missing to make this work is to define a hashing function for your that you're using as the key. The STL already defines equality and lexicographical ordering for a , so you can use it as the key-value in a as-is without any problems. It does not define a hash function though, so that is something you're going to have to-do by overloading std::hash. This is fairly straight-forward, and can be done by defining the following function:  The above functor object would return an integral type of , and would take a as the argument. You'll have to define it inside of so that will recognize it. An "easy" algorithm could be simply summing the elements since you have a set of type . There are more complex algorithms out there that would reduce the number of collisions such a simple algorithm would create at the expense of hashing time. Once you have this defined though, you shouldn't have any problems inserting your key-values into an , as well as creating new key-values and finding them in the hash table.  30.6k77 gold badges5555 silver badges7474 bronze badges  10  I guess I made a mistake by telling it is ordered. It is not and I'll edit it. But I could still use to find a value in the where is a as defined in the program. Can i do the same with ?  Just as a note: You can define a strict (weak) ordering on a set of strictly (weakly) ordered elements: if . If the first (i.e. smallest) elements are equal you can iterate. If all elements are equal the containers are equal if they are of equal length, otherwise the container with the least elements is smaller. This is the canonical ordering that you would apply to numbers (from right to left, though).  You can do the same, but again, if you stored the key-values as pointers to your sets, you are not going to have to worry about the above rules of equality for your key-values ... the fact that the pointers to two different sets are not going to be equal (can't be equal), gives you a nice way to differentiate sets. Furthermore pointers are easy to hash, and easy to sort, so they make great key-values for both and . For protection against memory leaks you can store them inside a .  @bitmask ... yes, very true ... the same can be done for lexigraphically ordering a string. I wasn't trying to say it can't be done, but that it's just cumbersome ... any quick technique won't work. Defining a lexigraphical order can be a time-consuming process, and using pointers can circumvent this issue altogether.  It would be helpful for me to understand better if you could give an example or edit my code. I'd really appreciate that.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  