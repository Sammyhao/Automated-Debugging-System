 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I want to print out a function pointer using cout, and found it did not work. But it worked after I converting the function pointer to (void *), so does printf with %p, such as  I compiled it with g++ and got results like this:  cout << pf is 1 cout << (void *)pf is 0x100000b0c printf("%p", pf) is 0x100000b0c  So what does cout do with type int (*)()? I was told that the function pointer is treated as bool, is it true? And what does cout do with type (void *)?  Thanks in advance.  EDIT: Anyhow, we can observe the content of a function pointer by converting it into (void *) and print it out using cout. But it does not work for member function pointers and the compiler complains about the illegal conversion. I know that member function pointers is rather a complicated structure other than simple pointers, but how can we observe the content of a member function pointers?  7 Answers 7  There actually is an overload of the << operator that looks something like:  which does what you expect - outputs in hex. There can be no such standard library overload for function pointers, because there are infinite number of types of them. So the pointer gets converted to another type, which in this case seems to be a bool - I can't offhand remember the rules for this.  Edit: The C++ Standard specifies:  4.12 Boolean conversions  1 An rvalue of arithmetic, enumeration, pointer, or pointer to member type can be converted to an rvalue of type bool.  This is the only conversion specified for function pointers.  3,37199 gold badges2424 silver badges4545 bronze badges  answered Jan 14 '10 at 14:27  anonanon  8  5  +1. The only standard conversion applicable to a pointer to function is (save for the lvalue-to-rvalue conversion) the conversion to . Notably, you must perform to convert to .  @avakar Is there a document or so covering the conversion rules of function pointers?  The ultimate document would be the C++ standard, sections 4[conv] and 5.2[expr.post]. The standard isn't free, but you can get the latest draft here: open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf. Beware that it can difficult to read if you're not used to it.  @Neil: is the only conversion, but there's another thing to keep in mind: manipulators are functions whose addresses you pass to the stream. Instead of converting them, the stream invokes them; if you pass a pointer to a function with a signature like a manipulator's, the stream will treat it like a manipulator, and invoke the function instead of attempting to convert its address at all.  @Neil Butterworth @avkar Thank you very much for your help. So cout will treat function pointers as bool after finding out there's not any other type possible to be converted to, right?  Regarding your edit, you can print out contents of anything by accessing it via pointer. An example for pointers to member functions:  You can think of a function pointer as being the address of the first instruction in that function's machine code. Any pointer can be treated as a : 0 is false and everything else is true. As you observed, when cast to and given as an argument to the stream insertion operator (), the address is printed. (Viewed strictly, casting a pointer-to-function to is undefined.)  Without the cast, the story is a little complex. For matching overloaded functions ("overload resolution"), a C++ compiler gathers a set of candidate functions and from these candidates selects the "best viable" one, using implicit conversions if necessary. The wrinkle is the matching rules form a partial order, so multiple best-viable matches cause an ambiguity error.  In order of preference, the standard conversions (and of course there also user-defined and ellipsis conversions, not detailed) are  exact match (i.e., no conversion necessary)  promotion (e.g., to )  other conversions  The last category includes boolean conversions, and any pointer type may be converted to : 0 (or ) is and everything else is . The latter shows up as when passed to the stream insertion operator.  To get instead, change your initialization to  Remember that initializing a pointer with a zero-valued constant expression yields the null pointer.  @curiousguy Uh... Actually I mean when the compiler cannot find the exact signature of the function called as the arguments given, say a pointer of function in this specific example, the compiler will then try to convert it to bool and thus match an overloaded version with argument of bool type.  @ibread Actually the compiler will always consider all possible candidates functions; if there is a function taking the correct function type, it will be the "best" candidate. Since there is no such function, the only candidate is the function taking .  In C++11 one could modify this behavior by defining a variadic template overload of (whether that is recommendable or not is another topic):  11.5k44 gold badges5252 silver badges9393 bronze badges  6  You also need an overload that will take a C-style variadic function (with its trailing ellipsis) and eight overloads for pointers to member functions, each of which can be unqualified, , , or and may or may not have a trailing ellipsis.  @Brian, do you mean to cover the case of a const pointer to function? like ? (feel free to edit the answer to clarify).  You can't put in that position. You'd want to put it just before , if you want a constant pointer to function. Anyway, that case is already covered by your answer, but I mean something like .  @Brian, yes, according to my tests is covered (in fact or not, it is the same function, the is redundant). Yes, the pointer-to-member-function was not covered. I interpreted it was not part of the question. But I added it to the answer now.  @Brian, at tried to generalize the solution but I couldn't but basically all distinct member functions print the same number.  Casting pointers to to print them to is the right thing (TM) to do in C++ if you want to see their values.  242k8282 gold badges339339 silver badges398398 bronze badges  2  1  It's the right thing to do, except of course where it doesn't work at all. Unfortunately, there's no guarantee that a pointer to code is really compatible with a pointer to data. A classic example (truly classic, nowadays) was in the "medium" memory model under MS-DOS, where a pointer to data was only 16 bits, but a pointer to code was 32 bits.  how can we observe the content of a member function pointers?  The answer is, other than converting them to bool to express that it points to something or it doesn't, you can't 'observer' member function pointers. At least not in a compliant way. The reason is because the standard explicitly disallows this:  4.12 footnote 57:  57) The rule for conversion of pointers to members (from pointer to member of base to pointer to member of derived) appears inverted compared to the rule for pointers to objects (from pointer to derived to pointer to base) (4.10, clause 10). This inversion is necessary to ensure type safety. Note that a pointer to member is not a pointer to object or a pointer to function and the rules for conversions of such pointers do not apply to pointers to members. In particular, a pointer to member cannot be converted to a void*.  For example, here is sample code:  I note that my debugger (MSVC9) is able to tell me the actual physical address of the member function at runtime, so I know there must be some way to actually get that address. But I'm sure it is non-conformant, non-portable and probably involves machine code. If I were to go down that road, I would start by taking the address of the function pointer (eg ), casting that to void*, and go from there. This would also require you know the size of pointers (different on different platforms).  But I would ask, so long as you can convert the member-function pointer to bool and evaluate the existance of the pointer, why in real code would you need the address?  Presumably the answer to the last question is "so I can determine if one function pointer points to the same function as another." Fair enough. You can compare function pointers for equality:  95.8k2828 gold badges175175 silver badges309309 bronze badges  3  @John Dibling Thank you very much for your answer. Actually, I'm just curious about the content of member function pointer and that's why I want to print it to check out. :) And, there's several "**" which would cause the compiler to complain. ;)  Part of the standard you are quoting has nothing to do with the answer asked. Pointer to member is totally different thing than pointer to method (that is pointer to member function).  @SergeDundich: Your comment makes no sense -- a pointer to member function is a pointer to member (the other kind of pointer to member is a pointer to non-static data member). All pointers to members (both function and data) get formed the same way, using , and used the same way, using or .  maybe (in one time I stay intersecting about the address of function) one of decision )))  passing the pointer to function or other pointer using use constraint . Let to use register for input argument)).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  