 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Say I have a tree defined as per the recommendation in this post, although it's a vector in my case, which hopefully shouldn't matter (they're vectors in Programming Clojure book):  which should be something like:  Now, I'd like to do a breadth-first traversal of the tree without any of the traditional means such as the queue, and instead use exclusively the stack to pass information around. I know this isn't the easiest route, but I'm doing it mostly as exercise. Also at this point I'm not planning to return a collection (I'll figure that out afterwards as exercise) but instead just print out the nodes as I travel through them.  My current solution (just starting out with Clojure, be nice):  The last line is not working as intended and I'm stumped about how to fix it. I know exactly what I want: I need to peel each layer of vectors and then concatenate the results to pass into recur.  The issue I'm seeing is mostly a:  Basically conj doesn't like appending a vector to a long, and if I swap conj for concat, then I fail when one of the two items I'm concatenating isn't a vector. Both conj and concat fail when facing:  I feel like I'm missing a really basic operation here that would work both on vectors and primitives in both positions.  Any suggestions?  Edit 1:  The tree should actually be (thanks Joost!):  However we still haven't found a breadth-first solution.  7,34866 gold badges4444 silver badges7373 bronze badges  3  Did you have a look at the source of the functions in clojure.walk or the function tree-seq? They implement tree traversal and might be interesting to you.  @Gert: It's my impression that all of those are depth-first, correct? I also considered zippers, but then my brain started melting at the thought.  Ah yes, does depth-first traversal; I missed the breadth-first requirement in your post, oops!  4 Answers 4  Since apparently there is still no breadth-first solution posted, here is a simple algorithm, implemented first eagerly, and then transformed to be lazy:  81.5k77 gold badges137137 silver badges192192 bronze badges  3  1  I'm curious, are you using a PersistentQueue simply because it's faster than a list?  We need to take from the front and add to the end. We could use a lazy sequence with concat, but this will fail if the tree is very large. So in some sense: yes, we could have used a list here. But aside from being much, much slower, it also doesn't express the intent: this is a queue, so why not use an actual queue structure?  So if I'm understanding correctly, both a vector and a list work as stacks (from different sides) if you use conj/pop, however with PersistentQueue you get to pop from the front and conj at the end?  Also, you're mixing the tree traversal with printing and building up a result. Things get simpler if you concentrate on doing the hard part separately:  17.4k33 gold badges4242 silver badges5252 bronze badges  7  That works, thanks! I forgot to mention that I was trying to solve the problem for the general case where there is no maximum number of children nodes, hence my attempt to reduce/into. Also, is there any way to do that with a tail call?  if you really want to you can transform that into a tail call. but I don't see the point since it's inherently stack-based and already lazy.  @Joost Diepenmaat: I have the same question as kotarak... Isn't 1 2 4 5 3 6 DFS while a BFS should give 1 2 3 4 5 6? I mean, it looks like OP constructed his tree precisely so that a BFS give back 1 2 3 4 5 6. The Wikipedia article on BFS does the same with a 'a b c d e f g h'. See animated gif here: en.wikipedia.org/wiki/Breadth-first_search  Note that using here means you will get a stack overflow for a large tree (whether deep or not), for example .  This might help, I was creating an algorithm to evaluate if a tree is symmetric and used a breadth-first traversal:  many combinations of and can be replaced with single call in the case above with reduce you may need to pass an initial empty vector to reduce to get make conjunction happy.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  