 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I cannot put my finger on why my program hangs and crashes when I pass my 2d-array, declared on the heap, between functions which accept double pointers.  I am getting a strong feeling that it has to do with the method I have chosen to declare the 2d array. Before I created a function to allocate the array, the program could manipulate the data inside the array when passed to a function.  So here is the allocate function and then the function which it crashes inside:  4 Answers 4  You have to pass your matrix pointer by reference.  This accepts a copy of matrix. Which means anything you do in on will not affect the one in .  Instead it should be  However I suggest you use vectors instead of raw pointers and allocation. That way you don't need to wory about allocation and deallocation.  matrix has new address, but since it's local copy of pointer - main doesn't know about it.  Without this, the newly-allocated pointer isn't getting propagated back to the caller.  That said, it may be more explicit to return the newly-allocated pointer from the function:  Finally, is there a reason you are not using for this?  455k9797 gold badges905905 silver badges981981 bronze badges  1  I have not studied how to use this vector yet, I will see about that finally and why it would be a good situation for it.  Here, matrix is not going to change - you are copying its value to pass it to the function. What I mean is:  You have multiple solutions :  your matrix malloc can return an int**, and you would simply have to write matrix = matrix_malloc(m, n)  your matrix malloc could take a pointer to int** (int*** - handle carefully)  as mentionned in the other answers, a reference to int**  Here is what a matrix_malloc with an int*** would look like.  This is interesting, but you see if I had a pointer to a double pointer and pass by address, it will not work.  You would have to modify your matrix_malloc accordingly of course. I'll edit my answer to illustrate.  Ahh I did not realize I needed to force precedence for the dereference operator, this is why it did not work. This is good to know. Also, it seems like a bad idea to use this method because what if I wanted to again pass by pointer to a function inside that one? Or would that be unlikely as it is a pointer and can copy the address instead.  It will always depend whether you want to modify the pointed data (anything involving or , in that case you can just copy the pointer itself ()) or where the pointer is, well, pointing (if there's no or - if you want the modification to be carried over,you'll need to pass the address of the pointer ()). Whether or not this method is good is another debate - but in C++ you have plenty of tools to avoid that kind of headache.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  