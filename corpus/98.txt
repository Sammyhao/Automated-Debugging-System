 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm trying to implement a BFS to find all prerequisites required before a certain course can be taken. My method is where my code is messing up. Can someone look at my method and help me find the issue? I figured the finish node would be none, because my the courses in my graph all lead to none. The graph is not cyclic.  This is the text file that I'm passing into the constructor, the first column is the course and followed by the course are its prerequisites:  .  Here's the node class I used to make the nodes and neighbors in the graph:  Here's my test class:  When I run this test my output is:  it should be:  I know I'm posting a lot of code but I don't want to have to edit in more code in later if it is needed to help fix my bug.  2 Answers 2  As a note, prerequisites are more effectively determined with depth first search (DFS) such that a topological ordering can be realized.  During graph construction, when linking neighbors, "lookalikes" are being linked rather than existing graph nodes themselves, so the resulting graph is actually unconnected. To resolve that issue, link the actual nodes of the graph to each other.  An added benefit of the above code snippet is that it adds the terminal "None" node to the graph.  A single line path can't be constructed because a course may have more than one prerequisite. For instance, CS6 depends on both CS2 and CS4. In the constructPath method, the terminal condition would fire after only following one of those paths. So given the current structure of the program, about the best you can achieve is to output the set of prerequisite courses rather than the single line path.  Given this approach, neither arguments startNode nor finishNode are necessary and the creation of the predecessor map is redundant.  Lastly, a course is not a prerequisite of itself so it's incorrect to assign itself as a predecessor.  You should have used instead of . Even if you have encountered null-node, you can have more normal nodes on the queue, which have longer path to the null-node.  You can realize it when you analyze graph starting from CS5  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  