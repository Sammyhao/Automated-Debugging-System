 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I wanted to ask, is dynamically creating a pointer, and then changing a pointer address to something else still deleting the original allocated space?  Note that what you are dynamically creating in the above code is an int, not a pointer. The pointer itself is located on the stack, and it gets set to point at the int you allocated from the heap.  5 Answers 5  When you do you are losing your only tracking of the memory allocated by . Noone keeps track of this for you, there is no garbage collector, it is simply lost and cannot be recovered.  When you then do (where is assigned to ) you are deleting memory that you didn't allocate, and worse you are deleting memory on the stack. Either of these will result in undefined behavior.  This is an excellent preface into why you should avoid using pointers in circumstances where you don't need them. In this case, there is no reason dynamically allocate your . If you really need a pointer, use a smart pointer (or if you don't have ). There are increasingly rare cases where you really do need a raw type pointer. You should read Effective Modern c++ Chapter 4 for excellent detail on this subject.  is dynamically creating a pointer, and then changing a pointer address to something else still deleting the original allocated space?  No. will deallocate the memory to which its operand points. You must the same block of memory that you obtained from .  To be even more clear, doesn't care about what variable it operates on, it only cares about what that variable points to. In the last line above, points to the block that was originally pointed to by and allocated by , so you can safely it. points to statically allocated memory, not something you got from , so you can't it.  Instead of changing where points, though, you can copy the value you want into the space that points to:  Here you're changing the value stored in the location to which points, but you're not changing itself. still points to the block you got from , so it's safe to it.  You code will (try to) delete c. There's no memory management or anything like that in C/C++. delete will try to delete whatever the given pointer points to, and and whatever is not deleted (either by calling delete for variables created with a call to new, or by leaving the scope for local variables) will remain in memory until the program ends.  Notice that trying to delete a local variable will propably cause a crash, since delete actually checks (in a very basic manner) what it deletes - at least to know how much memory has actually been allocated at that address. And at this check, it will propably notice that c doesn't include this information, or that it isn't even at the right end of the memory space, so it will crash.  It will crash because is created in the stack memory section. If you're lucky and the program didn't crash you aren still leaking memory because the q reference is lost.  You would not be lucky if it didn't crash. In all likelihood it will only then crash long after you have integrated this code and it is sitting at a customer site. I would say the best possible result is for it to immediately crash.  I wanted to ask, is dynamically creating a pointer  We don't create a pointer dynamically. Pointers are just a variable like other variable in C and C++. Difference is, pointer is a variable which can store the address of a particular memory location. In run time you just dynamically allocate memory and assign the address of first address location of that memory size into it.  Now what will happen if you don't delete/free the memory and assign a new address to it. In that case memory will not be release/freed and that can not be use anymore as that will never be marked as free by OS. When you free/delete memory O/S mark that area as free to use, and your running process can utilize it in future. That is call proper memory management. Improper memory manage leads your program to memory leak.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  