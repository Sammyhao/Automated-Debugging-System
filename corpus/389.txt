 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I know the code is quite long, but I really do wish for some suggestions:  Is it worthy to really implement a pure functional set of graph algorithm? I do this because I am getting used to and hate now.  Is my implementation too complicated in some parts or all?  Although I like , personally I think the implementation I make seems more complicated than the array-everywhere version. Is my feeling correct?  2 Answers 2  I'm not sure what you mean by worthy. It's worthy to set yourself this task as a learning exercise. It's also worthy to use immutable data to solve actual real world graph problems. It doesn't seem to me that graph processing is an area of application where pure functional code costs more than one is generally willing to pay for the benefits.  You're representing a path as a map from each node to the next. This is nice because you can start up the path in the middle. But a list is a simpler and more natural representation of a path for a lot of applications. At any rate, yours is a pretty heavyweight representation and so it makes your code a little heavier than I would have expected. (BTW it was hard to figure this out--some comments would help.)  I don't personally think this code is more complicated than imperative could would be. I also think that arrays make a poor representation for graphs when viewed as linked structures. So I don't believe an "arrays everywhere" solution is what you want to compare against. I'd compare against a malloc()/struct based (a la C) or against an object-based solution, personally.  When representing graphs as adjacency matrices, I'd say the array representation is more competitive. If your graph changes size a lot, or if you want to access nodes by keys other than integers, maps still have many advantages.  60k22 gold badges6565 silver badges9999 bronze badges  9  Thanks for your advice, I will add comments later. I just feel the thinking in functional dfs is quite different from in imperative dfs. Do you think the logic of my code can be further improved? as @Indicator indicates that I may combine several functions together?  for DFS, maybe it is ok to have path as list, but for BFS, it will cause confusion, right?  maybe my thought was to construct a thing so that we know who comes from whom. Your suggestion of using list will show really the path (order of travel) and don't care about the departure and arrival, right?  jeffrey, do you mind having a rough look at my code. I think it is really looking NOT that nice. I added comments this time.  It is worthy to do that if you cannot find good codes in open source community. Do not reinvent wheels.  There is another post has an extensive explanation on DFS algorithm by OCaml, Topological sort in OCaml What I suggest is to try write bfs, bfs_current and bfs_child into a single function.  thanks for your advice, I am learning OCaml, so want to write as many thing as possible for myself.  I am not sure how to combine bfs, bfs_current and bfs_child into one function. And also are you sure that you are talking about , not ?  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  