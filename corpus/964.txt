 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a data structure that is essentially a hash table. The keys and values are stored separately for cache reasons. I have an iterator that traverses the container and returns pairs of keys and values when dereferenced.  However, I'm having a bit of trouble getting the iterator to behave like others. In particular with . Here's what I have so far:  This works fine for range-for and explicitly dereferencing the iterator  But it doesn't work for 'reaching through' the iterator because I don't have  And I can't figure out how to implement for this iterator. My first thought was to stick a in the iterator and return a pointer to that, but a reference can't be reseated without shenanigans.  Create an instance of the pair in the iterator constructor instead? Then the operators can return pointers (and references) to a non-temporary object instead.  @Someprogrammerdude I consider OPs as more literal than . I mean and can mean everything or nothing. Though, comparable std:: containers (e.g. ) use a as well. So, it shouldn't lead to much "astonishment" by anybody.  2 Answers 2  If you can't return a pointer from the , return a helper class by value. Make that class store a and overload its to return a pointer to the pair.  My answer uses the same idea as RedFog's one, but I tried to make the code less convoluted.  iterator sometimes return a temporary object as a "reference", but usually demands a lvalue to get its pointer. in this case, to let work, we should provide a wrapper of the pointer: (C++11 version)  it works if the "reference" object () is copy constructible. the copy at the constructor of is necessary, because the temporary will be destructed after returning the wrapper.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  