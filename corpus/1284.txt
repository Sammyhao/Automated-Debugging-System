 Understanding The Coin Change Problem With Dynamic Programming  The Coin Change Problem is considered by many to be essential to understanding the paradigm of programming known as Dynamic Programming. The two often are always paired together because the coin change problem encompass the concepts of dynamic programming. For those who don’t know about dynamic programming it is according to Wikipedia,  “both a mathematical optimization method and a computer programming method … it refers to simplifying a complicated problem by breaking it down into simpler sub-problems”.  In other words, dynamic problem is a method of programming that is used to simplify a problem into smaller pieces. For example if you were asked simply what is 3 * 89? you perhaps would not know the answer off of your head as you probably know what is 2 * 2. However, if you knew what was 3 * 88 (264) then certainly you can deduce 3 * 89. All you would have to do is add 3 to the previous multiple and you would arrive at the answer of 267. Thus, that is a very simple explanation of what is dynamic programming and perhaps you can now see how it can be used to solve large time complexity problems effectively. By keeping the above definition of dynamic programming in mind, we can now move forward to the Coin Change Problem. The following is an example of one of the many variations of the coin change problem. Given a list of coins i.e 1 cents, 5 cents and 10 cents, can you determine the total number of combinations of the coins in the given list to make up the number N? Example 1: Suppose you are given the coins 1 cent, 5 cents, and 10 cents with N = 8 cents, what are the total number of combinations of the coins you can arrange to obtain 8 cents.  All you’re doing is determining all of the ways you can come up with the denomination of 8 cents. Eight 1 cents added together is equal to 8 cents. Three 1 cent plus One 5 cents added is 8 cents. So there are a total of 2 ways given the list of coins 1, 5 and 10 to obtain 8 cents. Example 2: Suppose you are given the coins 1 cent, 5 cents, and 10 cents with N = 10 cents, what are the total number of combinations of the coins you can arrange to obtain 10 cents.  Now that we know the problem statement and how to find the solution for smaller values, how would we determine the total number of combinations of coins that add to larger values? We write a program. How do we write the program to compute all of the ways to obtain larger values of N? simple we use dynamic programming. Remember the idea behind dynamic programming is to cut each part of the problem into smaller pieces. Similar to the example at the top of the page. If we don’t know the value of 4 * 36 but know the value of 4 * 35 (140), we can just add 4 to that value and get our answer for 4 * 36 which by the way is 144. Okay so we understand what we have to do, but how is a program going to determine how many ways the list of coins can output N? Well lets look that this example.  This is a array of coins, 1 cent, 5 cents, and 10 cents. The N is 12 cents. So we need to come up with a method that can use those coin values and determine the number of ways we can make 12 cents. Thinking dynamically, we need to figure out how to add to previous data. So what that means is we have to add to previous solutions instead of recalculating over the same values. Clearly, we have to iterate through the entire array of coins. We also need a way to see if a coin is larger than the N value. One way to do this is having an array that counts all the way up to the Nth value. So … Array of ways:  The reason for having an array up to the Nth value is so we can determine the number of ways the coins make up the values at the index of Array of ways. We do this because if we can determine a coin is larger than that value at the index then clearly we can’t use that coin to determine the combinations of the coins because that coin is larger than that value. This can be better understood with an example. Using the above numbers as example.  Before we start iterating we have to give a predefined value to our ways array. We must set the first element at index 0 of the ways array to 1. This is because there is 1 way to make the number 0, using 0 coins. So if we started iterating through all the coins array and compare the elements to the Array of ways we will determine how many times a coin can be used to make the values at the index of the ways array. For example… First set ways[0] = 1. Lets compare the first coin, 1 cent.  Lets now compare the second coin, 5 cents.  Lets now compare the third coin, 10 cents.  With all of the above in mind, lets have a look at the following program below.  Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here.  We use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy Got It !  