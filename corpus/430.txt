 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  This is concerning strings in C++. I have not touched C/C++ for a very long time; infact I did programming in those languages only for the first year in my college, about 7 years ago.  In C to hold strings I had to create character arrays(whether static or dynamic, it is not of concern). So that would mean that I need to guess well in advance the size of the string that an array would contain. Well I applied the same approach in C++. I was aware that there was a std::string class but I never got around to use it.  My question is that since we never declare the size of an array/string in std::string class, does a buffer overflow occur when writing to it. I mean, in C, if the array’s size was 10 and I typed more than 10 characters on the console then that extra data would be writtein into some other object’s memory place, which is adjacent to the array. Can a similar thing happen in std::string when using the cin object.  Do I have to guess the size of the string before hand in C++ when using std::string?  Well! Thanks to you all. There is no one right answer on this page (a lot of different explanations provided), so I am not selecting any single one as such. I am satisfied with the first 5. Take Care!  6 Answers 6  Depending on the member(s) you are using to access the object, yes. So, for example, if you use where , yes, you would.  Assuming no bugs in the standard library implementation, no. A always manages its own memory.  Unless, of course, you subvert the accessor methods that provides, and do something like:  You have no protection here, and are invoking undefined behaviour.  Without the cast, at least the compiler will detect a type mismatch. Modifying pointer returned by is UB. This is a requirement stated explicity with : .  The std::string generally protects against buffer overflow, but there are still situations in which programming errors can lead to buffer overflows. While C++ generally throws an out_of_range exception when an operation references memory outside the bounds of the string, the subscript operator [] (which does not perform bounds checking) does not.  Another problem occurs when converting std::string objects to C-style strings. If you use string::c_str() to do the conversion, you get a properly null-terminated C-style string. However, if you use string::data(), which writes the string directly into an array (returning a pointer to the array), you get a buffer that is not null terminated.  Finally, many existing C++ programs and libraries have their own string classes. To use these libraries, you may have to use these string types or constantly convert back and forth. Such libraries are of varying quality when it comes to security. It is generally best to use the standard library (when possible) or to understand the semantics of the selected library. Generally speaking, libraries should be evaluated based on how easy or complex they are to use, the type of errors that can be made, how easy these errors are to make, and what the potential consequences may be. refer https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/295-BSI.html  In c the cause is explained as follow:  This program is guaranteed to cause unexpected behavior, because a string (str) of 27 bytes has been copied to a location (buffer) that has been allocated for only 16 bytes. The extra bytes run past the buffer and overwrites the space allocated for the FP, return address and so on. This, in turn, corrupts the process stack. The function used to copy the string is strcpy, which completes no checking of bounds. Using strncpy would have prevented this corruption of the stack. However, this classic example shows that a buffer overflow can overwrite a function's return address, which in turn can alter the program's execution path. Recall that a function's return address is the address of the next instruction in memory, which is executed immediately after the function returns.  here is a good tutorial that can give your answer satisfactory.  In C++, the class starts out with a minimum size (or you can specify a starting size). If that size is exceeded, allocates more dynamic memory.  Assuming the library providing is correctly written, you cannot cause a buffer overflow by adding characters to a object.  Of course, bugs in the library are not impossible.  More precisely (but I think your answer is what the poster was looking for), buffer overflow will manifest itself by means of a exception, rather than by corrupted memory. And you're going to have to produce a pretty big string for this to occur.  To the extent that C programs are legal C++ code (they almost all are), and C programs have buffer overflows, C++ programs can have buffer overflows.  Being richer than C, I'm sure C++ can have buffer overflows in ways that C cannot :-}  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  