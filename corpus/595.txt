 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'd like to sort that map by 's value. So, if I print the map, I'd like to get the result as follows:  How can I sort the map in this way? Is there any way that I can deal with the key and value with sorted values?  10 Answers 10  Dump out all the key-value pairs into a first, where the is constructed with a less-than functor that compares the pair's second value only. That way, your code still works even if your values aren't all distinct.  Or dump the key-value pairs into a , then sort that vector with the same less-than functor afterwards.  @AtoMerZ If that's an issue, you can make the set hold references. If they're already references or small types, then it doesn't matter.  IMHO, the idea won't work if the values aren't all distinct. If you do and , then the second pair won't be inserted if the functor compares only the pair's second value, because for that set both items are identical.  You can build a second map, with the first map's values as keys and the first map's keys as values.  This works only if all values are distinct. If you cannot assume this, then you need to build a multimap instead of a map.  3,99811 gold badge2424 silver badges4444 bronze badges  2  5  if all the values are unique, it is ok. How to deal with multiple keys with same value? So this solution is not good!  This is not even a solution. What if the values are all the same? Then you second map will only have 1 element!  I wonder how can I implement the STL map sorting by value.  You can’t, by definition. A map is a data structure that sorts its element by key.  @Charlie Epps : With another map? Each time you add a key/value to the first map, you add a value/key to the second...  I also implemented a C++11 solution based on @Chris' idea using a vector of pairs. For correct sorting, I provide a lambda expression as comparison functor:  The first solution is more compact, but both solutions should have roughly the same performance. Inserting into a is of O(log n), but this has to be done for n entries, resulting in O(n log n). Sorting the vector in the second solution also results in O(n log n).  I also gave a try to @Chris' idea on using a set of pairs. However, it won't work if the values aren't all distinct. Using a functor that compares only the pair's second element doesn't help. If you first insert into the set and then try to insert , then the second pair won't be inserted, because both pairs are seen as identical by that set. You can see that effect here on Ideone.  7,6431111 gold badges6969 silver badges7070 bronze badges  1  The second solution also has the advantage that it generalises to sorting on non-trivial data types for the map values  I've just done a similar question in my c++ book. The answer I came up with might not be very efficient though:  Create another map, provide a less() function based on the value not key, AND the function should return true if the value1 <= value2 (not strictly < ). In this case, elements with non-distinct values can be sorted as well.  I have found this in thispointer. The example sorts a std::map< std::string,int> by all the int values.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  