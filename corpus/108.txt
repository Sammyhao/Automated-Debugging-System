 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I was comparing the efficiency of Breadth-first search and Floyd–Warshall algorithm in solving shortest path problem in python, although the complexity of Floyd–Warshall algorithm is much larger then that of BFS, BFS seems to be taking more time  Is there some data structure I am using for BFS that makes it very slow and is there anyway to optimize it  Without analyzing those algorithms: there are a lot of potentially slow operations in this BFS-code, while Floyd is just a simple nested loop and very simple operations (depending a bit on the data-structure of dist). Examples: : might be linear-search, depending on parents, : same, filtering of some queue, n_queue*linear-searches in queue, one hash-table lookup (good asymptotics but some overhead) + one linear-search. Use a profiler to see what's slow  2 Answers 2  I suppose this question is not so relevant for the op, but still for future people:  Original question:  Is there some data structure I am using for BFS that makes it very slow and is there anyway to optimize it  The answer from my POV: yes. There are some performance issues in your example:  You are using list instead of proper collection like deque ( from collections module ). to store your items. In fact, when you are doing pop(0) from it, list should shift all items in list ( 1, n ) on one position - this is time consuming operation.  Also when you are looking to the existence of item in the list, it is O(N) complexity, if you'll use set() instead, it will take you only O(1), because set structure based on the hash ( like dict ) and it is constant time to check is item in set.  If you're interested in, from my perspective the best implementation for BFS is:  Assuming you start BFS by calling , your BFS routine actually takes more than linear time. It treats every vertex in graph as a source vertex, and restarts a BFS for each vertex. which makes time quadratic even if your body of the loop takes constant time (it doesn't).  Additionally, and can all be linear time worst case, making your worst case runtime approximately equal or even greater than Floyd Warshall.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  