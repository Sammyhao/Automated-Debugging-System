 C++ tricks for competitive programming (for C++ 11)  We have discussed some tricks in below post. In this post, some more tricks are discussed.  Although practice is the only way that ensures increased performance in programming contests but having some tricks up your sleeve ensures an upper edge and fast debugging.  1) Checking if the number is even or odd without using the % operator: Although this trick is not much better than using % operator but is sometimes efficient (with large numbers). Use & operator:  Example: num = 5 Binary: “101 & 1” will be 001, so true num = 4 Binary: “100 & 1” will be 000, so false.  2) Fast Multiplication or Division by 2 Multiplying by 2 means shifting all the bits to left and dividing by 2 means shifting to the right.  Example : 2 (Binary 10): shifting left 4 (Binary 100) and right 1 (Binary 1)  3) Swapping of 2 numbers using XOR: This method is fast and doesn’t require the use of 3rd variable.  4) Avoiding use of strlen():  5) Use of emplace_back() (Discussed here, here and here) Instead of push_back() in STL emplace_back can be used because it is much faster and instead of allocating memory somewhere else and then appending it directly allocates memory in the container.  6) Inbuilt GCD function: C++ has inbuilt GCD function and there is no need to explicitly code it. Syntax: __gcd(x, y);  7) Using Inline functions: We can create inline functions and use them without having to code them up during the contest. Examples: (a) function for sieve, (b) function for palindrome.  8) Maximum size of the array: We must be knowing that the maximum size of array declared inside the main function is of the order of 10^6 but if you declare array globally then you can declare its size upto 10^7.  9) Calculating the most significant digit: To calculate the most significant digit of any number log can be directly used to calculate it.  10) Calculating the number of digits directly: To calculate number of digits in a number, instead of looping you can efficiently use log :  11) Efficient trick to know if a number is a power of 2 sing the normal technique of division the complexity comes out to be O(logN), but it can be solved using O(v) where v are the number of digits of number in binary form.  14) The Iota Algorithm The algorithm iota() creates a range of sequentially increasing values, as if by assigning an initial value to *first, then incrementing that value using prefix ++. In the following listing, iota() assigns the consecutive values {10, 11, 12, 13, 14} to the array arr, and {‘a’, ‘b’, ‘c’} to the char array c[].  15) Initialization in Binary form: In C++ 11 assignments can also be made in binary form.  Output :  16) Use of “and” Though not a very productive one, this tip helps you to just use conditional operator and instead of typing &.  Output :  This article is contributed by Yash Kodesia. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.  Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.  Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here.  We use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy Got It !  