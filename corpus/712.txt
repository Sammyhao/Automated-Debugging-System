 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a custom List (not a Collection!!) that implements Iterable. I don't implement List because that would bring way too much methods that I don't want, and that I don't need.  Some more Information about my CustomList:  all members are final  every CustomList can have a "SubList" which is another CustomList  every CustomList has to have exactly one MyThing  Example: say A is an Object of MyThing and B is an Object of MyThing, there can be one CustomList with only A (let's call it AList) and a CustomList with Item B and AList as Sublist.  CustomList has a Constructor that can take an Array of MyThings  So this is my Class:  And I have a  The MyThing:  I would like to get a sorted copy as CustomList of one of my CustomLists (If I don't need my Comparator that won't be a Problem, but that's how I solved it so far)  What I did so far is:  Transform my CustomList into a List  Sort that List (with the Comparator)  Transfer it back into a CustomList  This works fine, but I was wondering if there is another (perhaps more elegant way) to reach my goal.  Could you explain why you implement an Iterable instead of extend some Collection?  Using Guava's (which extends ), you can do . But this does basically what you are doing already.  The elegant way is to make your class implement and not just . Why have you chosen not to do this?  I don't think the "duplicates" suggested so far are true duplicates. The first doesn't make any sense, and the second is about sorting the elements of an , not doing something with the parent itself.  2 Answers 2  The core Java libraries don't expose a sort algorithm that works with an .  Built-in sorts copy elements to a temporary array. ( optimizes this by passing its internal array to the sort function.) A small improvement I recommend to your current approach is to copy your elements back and forth between an rather than a . Then use instead of . This saves creating a object that isn't really used.  If you want to perform an in-place sort of your custom collection, you could implement a sort algorithm yourself. This isn't terribly hard, but more code means more bugs, more maintenance, and you won't benefit from improvements bundled with the JRE (like moving from "MergeSort") to "TimSort"). Only you can say whether the benefit is worth it.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  