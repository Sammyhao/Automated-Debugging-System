 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  For the really lazy people, I'm going to note that all the ones with DeQue are double-ended queues.  I'm confused. I just want a FIFO data structure that lets me enqueue and dequeue items as shown on Wikipedia and none of the specialized stuff. Which one do I pick? Isn't there a Java equivalent to C++'s STL queue?  @Pieter: Any of these classes will do the basic enqueue/dequeue operations. If you like, you can declare your queue as a Queue like , which will force you to stick to the queue operations declared in the interface (like add/remove).  Some of these are from the package concurrent, so if you're implementing a jobqueue or something similar, you should go for ConcurrentLinkedQueue or PriorityBlockingQueue (for an heap) for ex.  Yes, I realised that one when I went back to get a few links; obviously my memory is faulty.  It happens. I'd be impressed if you have the entire Java library memorized. If you had EE memorized I'd back away slowly.  Well, there's javax.activation, javax.annotation, javax.ejb, and...wait, where are you going? There's so much more! ;)  As well as using the API docs to find "all known implementing classes", there are often other non-public implementation that are nevertheless available through the public API (only without requiring reams of pointless documentation). If you click on "use" you will also find Collections.asLifoQueue ( is already a , but it is FIFO rather than a stack).  142k3030 gold badges210210 silver badges296296 bronze badges  2  Every so often, I rediscover the "Use" pages and think, "Hey, this is great!" And then I forget them again.  No, there is no class, because there are lots of different ways to implement a queue and you have to pick the one that suits your use case. The same goes for any of the other collections in the collections framework - for example, and both implement a . The general pattern, which is a good use of object inheritance, is:  The Interface, e.g. , defines the role you want an object to play;  Sub-interfaces, e.g. , further expands on or specialises the role - in this case a "deque" or double-ended queue allows you to add and remove elements from both ends of the queue, as opposed to only adding to the back and removing from the front;  Classes provide the implementation of how an object carries out the role. For example, an uses a resizable array to implement a double-ended queue, which has different strengths and weaknesses to which uses a linked list.  To elaborate on the idea of an interface as a role, note that even though implements , you can use it as a without having to worry about that because implementing both interfaces means it can play both roles. Similarly, can wear a , or hat.  For this reason, the normal (recommended) way to use something like the Collections framework is to program to the interface, that is, use an interface when using the class rather than the class name itself. For example, you would instantiate an object like this:  In this way you are  not tied to a particular class and can use a drop-in replacement if needed without having to modify much code, and  are documenting what you are doing with a class by naming the role it plays. The general principle this helps with is self-documenting code, which is essentially to let the code itself be self-explanatory without having to use comments, etc.  You can also use a LinkedList. But generally, for a Queue, ArrayDeque is preferred over LinkedList. Because ArrayDeque consumes lesser memory, is faster and doesn't allow nulls. Not allowing null is good, because if you do allow nulls, then when you do a peek() or poll() you could get a null even if the queue is not empty.  Although the answers sound kind of scornful, They are actually being pretty cool by teaching you how to fish. A Queue is simply a way to look at a collection, so many collections may implement it. As well, things that act like collections but with specific other logic (like thread queues) might use the same interface.  Knowing where to look at the javadocs is a big help. I'm sure you looked but just didn't think to look at the implementations. Live and learn.  Sometimes you may also have to chase down sub-class/extends lists. Like if you looked at Queue and saw AbstractQueue, you might want to see what classes implement that.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  