 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to find a BFS algorithm in C but I can't find one that actually works. I have a binary heap (tree implementation) and what I want to do is use the BFS algorithm in order to find the right place to insert a new element in my tree.  P.S I don't know the exact number of the elements that will be inserted (if that helps).  4 Answers 4  The procedure for inserting into an array-based binary heap is:  Add the new item to the end of the heap  Bubble it up  In an array implementation, adding to the end of the heap is trivial.  In a tree based implementation, you determine the path to the node and then traverse that path from the root down, sifting as you go. You have to know how many items are already in the heap, and that the tree is correctly balanced when you start.  Say, for example that there are 4 nodes in the heap:  The next node you add will go into position 4--the right child of node 1. So your job is to determine where position 4 is. More correctly, you have to determine which node is the parent of position 4.  If the root node is 0, then the parent of any node is node . So the parent of node 4 is node 1, and the parent of node 1 is node 0.  You can write a recursive function that, given a node number, will traverse the tree to find the path to the parent. On the way out of the recursion, you actually end up sifting the node down the tree rather than bubbling it up, but the complexity is the same: O(log n).  Note that this doesn't do a breadth-first search. BFS would be a horribly inefficient way to do things.  Additional info  There's no special handling required for "even" or "odd" cases. It's all implicit in the tree structure. Consider this method, which will give you the path from the root to the insertion point in the tree:  (My example is in C#, simply because that's what I'm using these days. You should be able to convert to C with little trouble.)  I've simplified it in that it just shows the integer node numbers rather than doing the actual heap insertion. You can easily modify the code so that rather than outputting the path it, it gives you the actual nodes in the path from root to the insertion point.  Depending on your implementation, you can then traverse that path, insert the node in the proper place, and then bubble it up. Or, you can traverse the path from root to leaf, sifting the new item down in the process.  125k1717 gold badges168168 silver badges324324 bronze badges  6  I used the last answer of this post stackoverflow.com/questions/500057/… to solve my problem. It worked for the "full binary heap" and "even" cases but for the "odd" case this algorithm doesnt seem to work. Node findParentOfLastNode(Node root ,Node lastNode){ if(root == null) return root; if( root.left == lastNode || root.right == lastNode ) return root; Node n1= findParentOfLastNode(root.left,lastNode); Node n2= findParentOfLastNode(root.left,lastNode); return n1 != null ? n1 : n2; } Any suggestions?  @matrix: Yes. My suggestion is not to do it that way. There is no reason to incur the O(n) cost of a BFS when you can go use an O(log n) algorithm to go directly to the node.  So how do i deal with the "odd" case. In the full complete case i add the new node to the left kid of the left kid of the left kid.. In the "even" case i use the "lastnode" pointer to find the parent of the node that i m going to insert. what about the last case. For example a tree that has 5 elements in which i want to insert the 6th element.  @matrix: See my updated response. I don't have the time to write a full heap implementation for you, so you'll have to do with my hints. Or not. If you're bound and determined to use breadth-first search, then this answer is not for you.  After many hours i finally made it work :P I wonder if there's any similar recursive algorithm for the Deletion too. ^^ (Actually, i am interested in the "DownReHeapify" algorithm)  I know how to insert an element into a binary heap implemented with arrays, but for the tree implementation (structs) i thought i need BFS.  If you use BFS to insert elements, will get O(n) when insert elements. I suggest you to simulate the operations in heap based on array using pointers, will get O(logn) when insert. The idea is using pointers and upside down heap ajust operation.  What about generic implementation taken from program appearing in book:  "Programming Challenges: The Programming Contest Training Manual" by Steven Skiena and Miguel Revilla, Springer-Verlag, New York 2003.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  