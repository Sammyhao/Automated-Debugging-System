 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I've been using C++ for a few years, and today I saw some code, but how can this be perfectly legal?  Compiled under GCC.  How can the size be determined at run-time without or ?  Just to double check, I've googled some and all similar codes to mine are claimed to give storage size error.  Even Deitel's C++ How To Program p. 261 states under Common Programming Error 4.5:  Only constants can be used to declare the size of automatic and static arrays.  2,54966 gold badges3535 silver badges4444 bronze badges  4  3  note that DMA means "direct memory access" - I think you are asking about dynamic allocation  Again, pick one: C or C++. This question is explicitly and only about C; there should not be a C++ tag.  8 Answers 8  C99 standard supports variable sized arrays on the stack. Probably your compiler has chosen to support this construct too.  Note that this is different from and . allocates the array on the stack, just like it does with by just adjusting the stack pointer. No heap allocation is done. It's pretty much like .  398k8787 gold badges832832 silver badges780780 bronze badges  4  13  I came across this same scenario in a file in our code base that was written months ago. I was baffled, as was the rest of the team, as to why it compiled. In our situation, the size of the array was calculated before declaring the array as well (which shouldn't be allowed, either?) Anyway, a challenge went out. Anyone who could answer why this is legal gets a pop tart. If you're ever in Seattle, let me know. I have a pop tart for you.  Can you provide some info/link on how stack internally works in this case? Does this introduce some overhead in run time?  @balki The overhead is minor, as it's basically increment/decrementing the stack pointer. The stack behavior can be essentially identical to the normal case if you save the original stack pointer at the beginning of the function.  This is known as VLAs (variable length arrays). It is standard in c99, but gcc allows it in c++ code as an extension. If you want it to reject the code, try experimenting with , and options.  It is valid only in C99. Next time you may try checking your code in a reliable compiler.  It is valid C99, it is not valid C++. This is one of not a few differences between the two languages.  Not according to section 8.3.4 of the draft standard.  – anon  Apr 10 '09 at 10:47  3  it won't ever be included in c++1x :D but let's hope dynarray<T> gets in. i would love it. so you could do dynarray<int> a(some_size); and have it allocate efficiently, possibly with compiler hax like _alloca and so on.  For anyone from the future: it will be included in C++14 (with smaller set of features such as , sizeof(), etc.).  You can give size to an array dynamically in if you are using Dev-Cpp compiler I have tried it and got no error but on visual c++ and visual studio compilers it is not possible. I think the reason is that dev-c++ assigns a positive number to the uninitialized int and when we give it a number it is replaced by the given one. but perhaps other compilers give null to uninitialized variables.  Most compilers don't assign anything to uninitialized local variables, they will usually appear to hold whatever was in the memory that they occupy until they are assigned by the program. It seems the Dev-C++ you referenced is an IDE on top of MinGW, which includes a port of GCC as the compiler. As noted in other answers, VLAs are not standard C++, but some compilers (including g++) support them anyway.  Dev-C++ is not a compiler. Neither is Visual Studio. Dev-C++ uses GCC/G++ as its compiler, while Visual Studio uses cl (Microsoft's compiler back-end). By themselves, Dev-C++ and Visual Studio are Integrated Development Environments (IDEs). This is an important distinction to make. Dev-C++ does not "assign" anything. The compiler does that.  I recently came across a scenario where a stack-allocated array is desired. (It's a wrapper around v8, needed an array of args on every method call).  An std::vector would do heap memory allocation, whose performance is not acceptable.  Here is my solution, use template to allocation array of cases:  (And of course, I can just do with a 32-sized array, but which is not so elegant.)  Variable Length Arrays (VLAs) are supported in the C++14 standard, which has recently been accepted, and is awaiting publication.  67811 gold badge55 silver badges2020 bronze badges  1  2  VLAs are still not part of the standard. There's a dynarray TS, but as of yet it isn't ratified.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  