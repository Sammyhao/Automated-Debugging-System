 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a big text file (5Mb) that I use in my Android application. I create the file as a list of pre-sorted Strings, and the file doesn't change once it is created. How can I perform a binary search on the contents of this file, without reading line-by-line to find the matching String?  I can't read all the file. I get crash and memory exception. Line by line is too slow  6 Answers 6  Since the content of the file does not change, you can break the file into multiple pieces. Say A-G, H-N, 0-T and U-Z. This allows you to check the first character and immediately be able to cut the possible set to a fourth of the original size. Now a linear search will not take as long or reading the whole file could be an option. This process could be extended if n/4 is still too large, but the idea is the same. Build the search breakdowns into the file structure instead of trying to do it all in memory.  16.5k66 gold badges4646 silver badges6363 bronze badges  3  I would second that. Moreover, since (as per your description) you would know the content of the file at the time of its creation, you can further divite the file based on length of the string it contains. So A-G(1-5 characters), A-G(5-* characters) and so on. So at the time of search, you would know which file to open. You will essentially skip N/4 elements at the time of reading the file.  I was try this solution,There is big difference between n/4 to log(n) this very ugly solution(sorry) Thanks anyway.  @Beno: The point is that if n/4 can fit in memory, then you can read in the smaller chunk and do a binary search -> 1 + log(n) = log(n). All it is doing is treating the first iteration of the binary search algorithm slightly different than the following iterations.  A 5MB file isn't that big - you should be able to read each line into a array, which you can then use to find the line you want. This is my recommended approach.  If you don't want to read the whole file in to your app, then it gets more complicated. If each line of the file is the same length, and the file is already sorted, then you can open the file in RandomAccessFile and perform a binary search yourself by using like this...  However, if the file doesn't have fixed-width lines, then you can't easily perform a binary search without loading it into memory first, as you can't quickly jump to a specific line in the file like you can with fixed-width lines.  8,5061313 gold badges4141 silver badges5656 bronze badges  2  2  I have 65000 lines, each line is word. I get crash when I read the file to String[] . each word has diffrent length.  "If the file doesn't have fixed-width lines, then you can't easily perform a binary search without loading it into memory first" Sure you can... you just have to scan for line starts and ends (see my answer)  Here's something I quickly put together. It uses two files, one with the words, the other with the offsets. The format of the offset file is this: the first 10 bits contains the word size, the last 22 bits contains the offset (the word position, for example, aaah would be 0, abasementable would be 4, etc.). It's encoded in big endian (java standard). Hope it helps somebody.  I created these files in C#, but here's the code for it (it uses a txt file with words separated by crlfs)  And this is the Java code for the binary file search:  In a uniform character length text file you could seek to the middle of the interval in question character wise, start reading characters until you hit your deliminator, then use the subsequent string as an approximation for the element wise middle. The problem with doing this in android, though, is you apparently can't get random access to a resource (although I suppose you could just reopen it every time). Furthermore this technique doesn't generalize to maps and sets of other types.  Another option would be to (using a RandomAccessFile) write an "array" of ints - one for each String - at the beginning of the file then go back and update them with the locations of their corresponding Strings. Again the search will require jumping around.  What I would do (and did do in my own app) is implement a hash set in a file. This one does separate chaining with trees.  A test program  You'll also need to pass a Context to it, if and when you modify it for android, so it can access the getResources() method.  You're also probably going to want to stop the android build tools from compressing the file, which can apparently only be done - if you're working with the GUI - by changing the file's extension to something such as jpg. This made the process about 100 to 300 times faster in my app.  Though it might sound like overkill, don't store data you need to do this with as a flat file. Make a database and query the data in the database. This should be both effective and fast.  9,34344 gold badges5353 silver badges5959 bronze badges  3  There can be good reasons to do this. I use an IP-to-country list this way. Perfect use case. No database to keep running, no RAM consumed. Just a simple CSV file that can be searched when needed.  Yeah, if the event is rare enough and the data will not have any requirement to scale. Then this would clearly work. Though you're still looking at a lot of disk reads, using random rather than sequential access and hoping something stores that file in memory for you because seriously it should be pretty fairly slow. There's a bunch of tricks to make that stuff better and they are mostly the same tricks you see in databases.  Basically we are relying on the OS to cache the file if it's accessed more than once which is actually fine with me... if the event is rare as you said. :)  Here is a function that I think works (using this in practice). Lines can have any length. You have to supply a lambda called "nav" to do the actual line check so you are flexible in the file's order (case-sensitive, case-insensitive, ordered by a certain field etc.).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  