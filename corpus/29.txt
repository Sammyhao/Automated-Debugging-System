 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to write a function to open a file, read a , store the content in an array, then track the character (because I want to get each line of the input).  when I set the very large, I can get the first line. when I set the reasonably small (say, 42) which is not yet the end of the first line , it prints out some weird symbol at the end, but I guess it is some bug in my own code.  however, when I set the very small, say = 10, and i use the to check for memory leak. it throws a monster of error:  If anyone can explain me in a general sense:  what is fsanitizer=address flag?  what is heap-buffer-overflow?  what is address and thread? what is the flag to see the thread in colors on screen?  @n.m. funny it is truly the same error 'in my code' i mentioned. i did allocate an extra byte. but i did not put a 0 to make sure i end that buffer. :D  3 Answers 3  Usually C compiler doesn't add boundaries check for memory access. Sometimes due to code error, there is read or write from outside the buffer, such an error is usually hard to detect. Using this flag the compiler add some boundaries check, to ensure you won't use a buffer to reach outside of its allocation.  what is heap-buffer-overflow?  use an array to reach after its allocation,  (underflow is to reach before its allocation)  what is address and thread?  Address is position in memory, thread is part of process running sequence of code.  and why it says 'read of size 1 at address.." ?  It means you read single byte form the given address.  I think your problem is that you allocate the for the buffer and read the same into it. The correct approach is to always declare at least one more byte than you read. like this:  7,45099 gold badges3636 silver badges5555 bronze badges  8  1  An array is usually not located on the heap; it is either on the stack or in the bss, depending on the scope it was declared. Heap space is usually allocated by  Well, it is not a heap buffer overflow, as you claim. technically, it is not an overflow at all, since you do not write past its end.  in this case there is READ outside the allocation. I guess while printing the buffer.  this error in C is evergreen :D I get a stable stream of karma point from this problem i had a few year ago ^^  In simple words it is segmentation fault with the variable created using new keyword as all that goes into heap area of memory.  Explanation - you are trying to access such an address for which you haven't declared your variable, to find all such errors revisit all your conditions and check if you are accessing something out of bounds or not.  This error also occurs in c++. I observed this in the case of accessing an element of index i from an array that is out of bounds(i.e i>n or i<0). This basically occurs when we try to access some memory that is not allowed for us to access.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  