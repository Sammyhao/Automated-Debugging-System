 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have searched the depths of the internet and I am yet to find a solution to my problem. I have implemented(I think) a BFS for the sliding tile game. However, It cannot solve a problem unless the state is a few steps away otherwise it just results in Out of Memory errors. So my question to you, where am I going wrong? AFAIK my code follows the BFS pseudo code.  EDIT/NOTE: I have stepped through with a debugger and have yet to find anything out of the ordinary to my eye but I am merely a novice programmer comparatively.  1 Answer 1  There are a number of inneficiencies in your code that are slowing it down. I'm actually surprised you had the patience to wait for it to reach an out-of-memory condition.  The main culprits are the searches:  Both of these execute in O(N), which sounds fine, but since you execute them on every node, that results in a O(N2).  You can fix this by using a for the . Also, you could add nodes to the as soon as you queue them (instead of when you dequeue them). This way, you would only have a single lookup to do.  N.B. You will have to specialize in order to use .  One more hint: these in your main loop really slow you down because they force a flush and sync with the OS by default, commenting these out will make your program run a lot faster.  There's actually quite a few more improvements that could be made in your code, but that's a topic for another day. Fixing the algorithmic complexity will bring it in the non-broken realm of things.  17.5k11 gold badge2222 silver badges4545 bronze badges  9  I appreciate your answer, the cout is just from me purely doing a bit of debugging and not their to be useful. I will change my current and see what happens. I didnt wait for it to Out of Memory but I knew after 15 Secs that would be the likely outcome. I originally tested with unordered sets but was unsure how to implement and just went to a vector.  @RyanMason 15 seconds is nothing for a BFS, It could conceivably run for an hour without hitting an actual out of memory and successfully finding the right solution whith your version of the code. You really should ammend your question and describe the behavior you are seeing instead of your assumptions.  after doing some research on unsorted_set, would it be beneficial to use a unsorted_map instead?  @RyanMason An creates a mapping between keys and values. If is the key, what would the value be?  Okay I see, so to implement the unsorted_map, the most common method I have seen is to create a struct 'hash' that overloads operator().Now do I need to do this. I already overload my comaprison operator but can I use the default hasher on the state or do I need to reconstruct my int array into a hashable variable.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  