 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  The Problem We have provided you a class TreeNode. The methods are declared in TreeNode.h, and there are implementations of most of them in TreeNode.cpp.  Your work: Implement the function TreeNode *makeFullRight(int n) that builds a full tree with n nodes. The way you will build the tree is that the left child of each two-child node will be a leaf. The nodes should be numbered (by populating its data_ field) from 1 to n , according to the following rule: if a node had number i , then any left child would have number i + 1 and any right child would have number i + 2 .  Put your code in TreeNode.cpp.  As an example, makeFullRight(7) will produce the tree  You should assume that your makeFullRight function will be given an odd number as input.  You can write this using any technique you want, but we recommend using recursion and writing a helper function.  Sample Run Your main.cpp will exercise your code.  Ive tired to do it using recursion but i couldnt get the answer and now i am lost on how to the makeFullRight function  "i couldnt get the answer" - You might need to run your code in a debugger or add some debug prints that lets your follow what your program does to find out where it starts misbehaving.  "You can write this using any technique you want, but we recommend using recursion and writing a helper function." I wrote it with a loop and the test passed. Maybe you will find it simpler. What did you try so far?  1 Answer 1  If you examine the tree, you will see that each subtree has in the root, a leaf with in the left node, and a right-full tree with in its root in the right node.  Assume that you have the suggested helper function – let's call it "fullHelper" – that keeps track of the "current value" and produces a tree with that in its root:  Then you can write  Now, "all" you need is to write the helper function. You need a base case and a recursive case:  If , create a single node with ,  Otherwise, create a tree with in the root, in the left leaf, and a right-full tree rooted at as its right subtree.  58.8k33 gold badges3535 silver badges7474 bronze badges  1  Okay I see how that works. I was trying to return a tree in my base case instead of a single node. Thank you!  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  