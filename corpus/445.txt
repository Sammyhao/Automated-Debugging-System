 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Well, I really don't need help with code itself, but understanding what exactly I am trying to do in order to write the code. In a nutshell, I am given 1000 projects each with a set of resources, and I have a (set ammount) of resources to utilize to calculate what are the best projects I can pick.  the pseudocode for the bestprofit function is as follows:  bestProfit:  When I do the recursive call to bestProfit, best1 is supposed to check if a subproblem has already been resolved. and best2, considered the feasibility check is only based on the very last project. in other words it looks like a balanced tree. What I am unable to understand is how do I insert the values on the map during the recursion? Basically the final if/else statement won't happen until the whole set of projects has been traversed. And only the final value gets inserted on my map. I just want some pointers on how should I approach this to write the recursion correctly.  Like I said before I am not looking for code but a way to understand the requirements of this pseudo code for my project in C++. it is this logic that is driving me crazy at this point because I can't put it together to work. Thank you all for looking at this and providing a better insight if possible.  2 Answers 2  I'd return a data structure that indicates both the profit and the solution that gets that profit. Store that exact data structure in . This will make your code more straightforward.  Basically, "Write correct recursive solution. Add memoization to make it fast."  36.8k33 gold badges4848 silver badges7878 bronze badges  3  Hey Btilly, I like your answer, and that is what I been trying to get together for 2 days now, and then decided to ask the question. Basically: Check valueMap to see whether this subinstance has already been solved - If so, then return the previously computed result (function terminates) best1 = bestProfit(projects, r, valueMap, n-1). how do I return the result to the mapvalue in that sense, it just does not get stored automagically, it justs keeps calling itself over and over until the end of the recursion. The question then should be how do I add memoization?  is just a datastructure, probably a of some sort. At the start of the function check whether is in . If it is, return what is in immediately. Else calculate your return value. Then at the end of the function insert it into , and return. The first time your function is called with that set of parameters, you'll do the hard work. The second time it just returns immediately. There's really nothing more to it.  Hey Btilly, thank you for the answer. This actually had my program a great start even though I am not getting yet the required solution, but I did not ask help on that but how to get it to work which is now. Thank you you got the point here.  It is a straight forward application of Knapsack problem with numerous heuristics applicable to making it a greedy solution if fractions are possible...  For your problem the recurrence is Let W-->some notion by which you define if your resources are adequate enough for a problem 'k' Let N --> set of problems indexed by a 0-index Let V --> 0 based index of potential profit for solving each problem OPT[i][j] = MAX( OPT[i-1][j], OPT[i-1][j-W[i]]+V[i]) where 'i' is the an index into the list of problems. j is an index into how much resources are available yet. Your solution is then OPT[size[N]][W] Explanation: Intuitively, the sub problem is choosing the optimal set of projects among 'i' with available resources 'j'...  Recursion is bad doesnt allow many compiler optimizations possible with normal function calls.  96522 gold badges99 silver badges2020 bronze badges  1  Thanks for the answer. I ended up making a mistake on the sample code from the teacher and that's what was causing my issue.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  