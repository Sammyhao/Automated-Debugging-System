 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  C++ 0x11 (sort of. You know, Microsoft, and all...), Visual Studio 2010 SP1, Windows 7 Enterprise.  I've got a function:  Within the body of std::map::find, there is an iterator comparison, and I'm getting the error message "map/set iterators incompatible", as defined in VC\include\xtree:321. The nature of this error is that iterators from two different containers are being compared to one another, but the error is coming from within a containers own find function!!! Retorically, where could another container's iterator be coming from.  Ok, symptoms:  This is a threaded application.  It only happens at runtime, during a randomized stress test of the actual application.  We're not seeing any sort of invalid or obvious garbage fields.  My questions to the greater community:  Supposing this is a timing error in a threaded environment, can a change to the internal state of the map, mid way through this process, modify what would be the value of template class _Tree_const_iterator::_Getcont()? I'm supposing the map is being cleared and repopulated in another thread before the find in this thread completes. Could that alone do it? Or how about a swap or move operation?  I'll track down the missing mutex lock or whatever, I just want to make sure I understand all the plausible means I can enter this state, given this context.  1,32722 gold badges1212 silver badges2424 bronze badges  4  4  Most probably you have caused undefined behavior due to a modification to the map while the is being executed...  I agree that this looks like a problem with updating the map in one thread while searching with find in a second thread.  It's more likely to be an invalid iterator than "another container's iterator", caused by the map changing while was reading from it. If the map is changed from one thread while another thread accesses it, then pretty much anything could go wrong.  I had a similar case the last hour with the only difference that everything ran in the main thread. The problem occured on gcc and VS2010. After running a complete clean&rebuilt the problem vanished with both compilers.  1 Answer 1  Supposing this is a timing error in a threaded environment  Then all bets are off. If your code is threaded and isn't thread safe, then you can get all kinds of errors. is not thread-safe (you can't access it while it's being modified), so you could get plenty of kinds of errors.  Make sure your code is thread safe before assuming something else is wrong.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  