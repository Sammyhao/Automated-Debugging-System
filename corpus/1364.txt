 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Should there be a difference in searching approach based on the size of the collection to be searched? If YES then how to decide.  EDIT1: Suppose I have to search the list a couple of times, and no new elements will be added in the list.  EDIT2: I could have gone for a , but I am actually having a and I can search the multiple times based on different attributes of CustomObject. So I can't have a overridden method in my CustomObject  10.3k1717 gold badges6666 silver badges9494 bronze badges  7  2  The first method will run in O(nlogn) time (due to sorting) while O(n) for a linear search.  How many times are you going to search in the list? How many times are you going to insert items? Unless you have a clear answer to these questions, any answer we give you is pretty much meaningless.  4 Answers 4  If you are searching for only one string the linear search is better because it is in  If you are searching for multiple strings first sorting and then binary searching maybe better. it will be which is . So if you are checking for ca. strings, this one is better.  If you only want to know if your Collection contains an element (ignoring order), you should consider using which has .  If you need order and a fast contains method, use  P.S. premature optimization is the root of all evil.  It is worth mentioning that "big O" notation expresses the behavior of the algorithm as varies, but it does not imply that one algorithm is "faster" than other for given value. A algorithm could be slower than a algorithm for a given (if is big enough, in the end the algorithm with the better function will win, but such value may be large enough to be meaningless). Not that this comments belongs only to your answer, but I had to post it somewhere.  @SJuan76 Big O assumes that tends to infinity, so it does not say anything about small .  That is my point... For a limited value ( in this case), determining which algorithm is "faster" is not so easy.  If you do the search for more than one time, let's say times:  Complexity for sort + binary search will be .  Complexity for linear search will be .  So if you do the search just one time you should go with linear search. If you do the search for more than one time, most probably you should sort first.  Also, maybe in this case you can consider using a hash table, which has amortized complexity of for an element search.  @TheLostMind In complexity theory O(n * log n + log n) is considered equal to O(n * log n), since only the term with the highest rank is considered important. Please check the other answers for this question also, and reconsider your negative vote.  Complexity for sort + binary search in case of k runs will be O(k * log n) only if k >> n and it definitely remains O(n * log n) if k = 1. The proper complexity I believe is O( (k + n)*log n) or at least a bit of explanation is required.  @bosonix - My bad. I thought you had entered the complexity of mergesort as "n". Please be more clear the next time around.  @AndreiBozantan why is it O(n * log n) ? is the quicksort (assuming that's the most common sorting used in languages) complexity negligeable to the binarysearch complexity ?  If you only search the list once (or seldom) linear search is cheaper. If you search the list more often the cost of sorting is repaid. Sorting costs O(n log n) average time complexity und searching then O(log n). If you search for almost "every element" this also costs O(n) average time complexity and you are "even" with sorting.  A binary seach is O(log(m)) and is faster than a linear search of O(n). However one must first sort the data: O(n log(n)), which takes longer.  So if the data is filled once, and then often sougth for, take a sorting and binary search. Even better: take a Set. And a HashSet would be even nicer.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  