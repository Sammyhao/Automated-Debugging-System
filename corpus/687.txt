 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a tree as input to the breadth first search and I want to know as the algorithm progresses at which level it is?  It takes tree as an input graph, what I want is, that at each iteration it should print out the current level which is being processed.  72422 gold badges77 silver badges1616 bronze badges  2  Are you making your own BFS implementation? If yes, its just a depthCounter that you have to use and maintain. Or are you using any off the shelf algorithm??  I have added the code, no off the shelf algorithm, just a regular breadth first search implementation.  10 Answers 10  Actually, we don't need an extra queue to store the info on the current depth, nor do we need to add to tell whether it's the end of current level. We just need to know how many nodes the current level contains, then we can deal with all the nodes in the same level, and increase the level by 1 after we are done processing all the nodes on the current level.  1,95122 gold badges1313 silver badges1111 bronze badges  3  13  This answer deserves so much more credit. solution doesn't work if queue already contains null values. Also great for people not wanting to force nullability in their data structures  adding null to the end of each level changes our data significantly. Data might be read-only. Even if the data is not read-only, this is not a good approach. It might harm our integrity of data.  You don't need to use extra queue or do any complicated calculation to achieve what you want to do. This idea is very simple.  This does not use any extra space other than queue used for BFS.  The idea I am going to use is to add at the end of each level. So the number of nulls you encountered +1 is the depth you are at. (of course after termination it is just ).  4,78255 gold badges3030 silver badges6363 bronze badges  2  4  I like this method, but instead of peeking for a double null termination of the queue, I changed the while loop to . There is always a null in the queue to indicate depth, so the queue is empty of real elements when there is only the null left.  adding null to the end of each level changes our data significantly. Data might be read-only. Even if the data is not read-only, this is not a good approach. It might harm our integrity of data.  Maintain a queue storing the depth of the corresponding node in BFS queue. Sample code for your information:  This method is simple and naive, for O(1) extra space you may need the answer post by @stolen_leaves.  For your implementation, keep track of the left most node and a variable for the depth. Whenever the left most node is popped from the queue, you know you hit a new level and you increment the depth.  So, your root is the at level 0. Then the left most child is the . As soon as you hit it, it becomes level 1. The left most child of this node is the next and so on.  With this Python code you can maintain the depth of each node from the root by increasing the depth only after you encounter a node of new depth in the queue.  If your tree is perfectly ballanced (i.e. each node has the same number of children) there's actually a simple, elegant solution here with O(1) time complexity and O(1) space complexity. The main usecase where I find this helpful is in traversing a binary tree, though it's trivially adaptable to other tree sizes.  The key thing to realize here is that each level of a binary tree contains exactly double the quantity of nodes compared to the previous level. This allows us to calculate the total number of nodes in any tree given the tree's depth. For instance, consider the following tree:  This tree has a depth of 3 and 7 total nodes. We don't need to count the number of nodes to figure this out though. We can compute this in O(1) time with the formaula: 2^d - 1 = N, where is the depth and is the total number of nodes. (In a ternary tree this is 3^d - 1 = N, and in a tree where each node has K children this is K^d - 1 = N). So in this case, 2^3 - 1 = 7.  To keep track of depth while conducting a breadth first search, we simply need to reverse this calculation. Whereas the above formula allows us to solve for given , we actually want to solve for given . For instance, say we're evaluating the 5th node. To figure out what depth the 5th node is on, we take the following equation: 2^d - 1 = 5, and then simply solve for , which is basic algebra:  If turns out to be anything other than a whole number, just round up (the last node in a row is always a whole number). With that all in mind, I propose the following algorithm to identify the depth of any given node in a binary tree during breadth first traversal:  Let the variable equal 0.  Each time a node is visited, increment by 1.  Each time is incremented, calculate the node's depth as  You can also use a hash table to map each node to its depth level, though this does increase the space complexity to O(n). Here's a PHP implementation of this algorithm:  In Java it would be something like this. The idea is to look at the parent to decide the depth.  13.8k2323 gold badges8383 silver badges139139 bronze badges  1  this will result in endless loop . you need to check if child already visited for(String c:children) { if(!depthMap.containsKey(c)){ depthMap.put(c,depthMap.get(parent)+1);//parent's depth + 1 queue.add(c); } }  Use a dictionary to keep track of the level (distance from start) of each node when exploring the graph.  Set a variable and initialize it to the size of the queue , Now decrement each time you do a pop. When gets to 0, increase the depth of your BFS and then set again.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  