 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  The line its indicates is Node* newnode=new Node; because I use "new" here, this newnode needed to be deallocated, but the destructor only deallocate content in Hashtable. If I don't use "newnode", I will have null-pointer access error because nullptr does not have access to Node (Node is a struct has key and value), I can only let the pointer points to a "newnode."However, adding extra "delete newnode" makes me getting more than 20 errors. I really need you help!  Don't allocate the node unless you already know the exact key isn't present in the collision chain. And don't call . You already have the proper collision chain. Just walk it, and if the exact key isn't found, add it, else swap in the new value to the existing node.  @user3000888 Can you please edit your question and put a comment on the line that is ?  3 Answers 3  creates a local newnode pointer which will go out of scope after the add function exits. This will leak memory allocated by new.  I know, but I need this line, how to dealloacate it? Simply write delete newnode gives more 380errors!  No, he's wrong. You store the newnode value either in HashTable[index] or in the ptr->next of the last node in the chain.  Actually, he's right - my bad. As WhozCraig said, you're calling "new" before you decide you NEED to add the entry.  What you need to do is do the conditional BEFORE the new.  ---- Edit ----  What ValGrind is telling you is that your code allocated a pointer at HashMap.cpp line 112, but it never stored the address -- this is what happens in your code when someone calls the add function with a key for which "contains(key)" does not return false. You don't store the pointer, and so the Node you allocated is left allocated but your code is not tracking it -> it's a leak.  22.2k22 gold badges3737 silver badges6969 bronze badges  4  I changed to allocate the pointer whenever I use it, but why I still get an error?  Still the error about Node* newnode=new Node; change its position several times, it does not work :(  When you use "new", the program allocates some memory and gives you the pointer. You are now the owner of that piece of memory. You are responsible for returning it to the system. ValGrind is telling you that one of the "Node" objects you allocated didn't get returned. You'll need to either post the entire code or you'll need to step through a simple test program in the debugger and watch for any instances where you might be leaking, e.g. in your remove node, rehash code, etc.  Simply declare the newnode and then after the if statement allocate the new Node. The way your code is right now the newnode can be allocated , the if statement goes wrong and the newnode stays in memory never used.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  