 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I've the following singly linked list implementation.  Based on the current implementation of the class and the copy constructor, can someone help with the assignment operator overload. Also I'm a little confused about the copy constructor and assignment overload. What I understand is that the copy constructor creates a new list which has the same values as the old list from a old list. This the next address for all nodes will be different but the values will be the same since it's a deep copy. Is my understanding correct and then onwards what does the assignment overload do?  31711 gold badge44 silver badges1717 bronze badges  3  Copy assignment has the same goal as copy construction. You just need to be aware you had data already in the container. A copy constructor should create a container that has the same data as the original container, but is an independent object.  In your copy constructor, you need to create every node with , not just the first one. (There should be a inside the loop.)  2 Answers 2  If you already have a copy constructor and destructor, also implement and then implement your copy assignment operator in terms of these three, e.g.:  Note that the argument is readily copied: unlike the copy constructor the copy assignment can take its argument by value.  With respect of the semantics:  The copy constructor creates a new object with the same value as the original, e.g.:  The copy assignment replaces the value of ane existing object the value of the assigned value, e.g.  Now, both of these operations make - as the name suggests - a copy of the original data structure. What exactly that means depends on how you want to implement it, but the following should - to stay close to the principle of least surprise - hold:  The easiest way to achieve this is by making - as you already suggested - deep copies. Thus you basically do the same as in your copy constructor. You make copies of each node, such that they have the same value as the original nodes, but are different entities.  If you're also targeting "modern C++", that is C++11 an onwards, then there's also a move constructor and a move assignment operator that you might want to implement.  As mentioned in the comments, your deep copy algorithm isn't correct: You need to make a copy of each node:  Also, if you can, prefer smart pointers, in this case, instead of raw pointers.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  