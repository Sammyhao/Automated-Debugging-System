 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I was able to implement Hashtable using array by simply using the following data structure.  i.e an array of linked list(hashing with chaining).  Now in various books,they say we can implement a hashtable with a BST if we want ordered data. How do I incorporate both key and value in a BST. Although I can store both just as I store a single item of data, but the key gives an integer that acts like an index to the array after it has been to a hash function. How do I use the key in BST? I don't need any index?  What I can think of is that I can compare two keys using the function and then do normal insertion,deletion accordingly.  EDITS:  Suppose I have BST from scratch  How do I use the key mapped to integer to implement the  4 Answers 4  Java specific answers have already been provided but I am guessing your question is more about the design rather than language specific implementation.  No, we do not need to calculate an index or use a hashing function. If we store the key,value pairs in the nodes of the bst, then its just a matter of traversing the tree by comparing the keys. This also gives you the added advantage of no collisions since the keys are unique.  You could use a hashing function and hash the key and then traverse the tree based on that value but this can lead to collisions if you are not careful with the hash function and then you would have to maintain some sort of chaining.  Whether to use the key or the hashed value of the key depends on the size of the key. If the key size is large, it makes sense to hash it to a smaller size for faster comparison.  There is already an implementation of BST in java - TreeMap. It's a self balancing red-black tree. I guess implementing it would not be a much problem. For example:  Since Hashtable should be implementation of interface, I suggest implementing . I would use a BST through composition rather than inheritance - so we can hide the API of the BST. The BST can be anything - in my code example I used Java's class.  I think the question is about how to implement this as an exercise, not what you'd do in production.  As per JDK, Dictionary class is obsolete. Rather we should implement Map interface while implementing a custom HashMap.  You don't need to implement the hash table with link list. It's only the case when the collision happens instead of using chaining which takes linear time to search O(n) , you can use a balanced bst so that the search time reduces to O(log n).  Here is a simple implementation of HashMap with BST as buckets. This basic implementation of Map shows how put() and get() works to get data from Map backed by BST buckets. This BST implementation is NOT balanced. Ideally for production applications, this BST should be balanced using Red-Black tree algorithm to improve seek time.  With buckets implemented using balanced BST compared to Linked Lists, we are able to improve Get(key) time from O(n) to O(log n).  What is the purpose of spreading the higher bits? Won't that essentially zero out any number less than about 100,000?  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  