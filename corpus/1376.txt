 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  67411 gold badge99 silver badges2323 bronze badges  3  1  This question appears to be off-topic because it is not about a computer program or programming language.  3 Answers 3  In both cases, the runtime depends on how long it takes to iterate across the outgoing edges of a given node. With an adjacency list, the runtime is directly proportional to the number of outgoing edges. Since each node is visited once, the cost is the number of nodes plus the number of edges, which is O(m + n). With am adjacency matrix, the time required to find all outgoing edges is O(n) because all n columns in the row for a node must be inspected. Summing up across all n nodes, this works out to O(n2).  339k9494 gold badges838838 silver badges10141014 bronze badges  2  thanks a lot, i got it... i was hell confused as on wikipedia also space complexity O(n+m) was described for adjacency list and O(n^2) adjacency matrix, but time complexity was given as O(n+m)...  The time complexity for both DFS and BFS can be computed as follows:  Iterating every vertex once and its corresponding incident edges, so the total time complexity will be ->  Time Complexity = v1 + (incident_edges on v1) + v2 + (incident_edges on v2) + ...... + vn + ( incident_edges on vn)  Now this can be regrouped as -> (v1+v2+v3+.....vn) + (incident_edges on v1 + incident_edges on v2 + ..... incident_edges on vn)  Thus total time complexity would turn out to be = (v1+v2+v3+.....vn) + (incident_edges on v1 + incident_edges on v2 + ..... incident_edges on vn)  (v1 + v2 + ... + vn) = V or n (Total number of vertices)  For adjacency list representation :  (incident_edges on v1 + incident_edges on v2 + ..... incident_edges on vn) = E(Total number of edges)  Thus for adjacency list representation time complexity will be O(V+E)  For adjacency matrix representation :  To visit the neighbors of the corresponding node(Row) we need to iterate all the columns for the particular row which amounts to V  So, (incident_edges on v1 + incident_edges on v2 + ..... incident_edges on vn) = V + V + .... Vth time V) = V*V  You must note that for exploring each vertex time required for exploring it is only equal to c*x where x is the indegree of the vertex.Since we are interested in finding the overall complexity, the overall time would be c1*x1+c2*x2...cnxn for n nodes.Taking max(ci)=d,we see that the overall time is <=d(sum of indegrees of all vertices)=d*2m=O(m).Here we have computed the time for not one vertex, but all the vertices taken together.But the enqueuing operation takes time O(n), so overalll O(n+m).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  