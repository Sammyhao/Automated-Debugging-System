 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to print all the permutations of a string using recursion as below. But I was wondering if we can use bfs or dfs also to do this, am I thinking right?  If yes, then can you please give me an idea? My idea is: if string = "abcd" start node: 'a' end node: 'd' intermediate nodes: 'b' and 'c'  We can then change the start nodes to 'b','c' and 'd'.  I am having difficulty in visualizing it to put it in a algorithm.  Based on the logic given by Serge Rogatch, below problem can be solved:  3 Answers 3  Your algorithm seems to already implement backtracking, which is one of the correct things to do for permuting. There is also non-recursive algorithm based on tail inversion (can't find the link, I think I don't remember its name precisely) or QuickPerm algorithm: http://www.quickperm.org/quickperm.html  DFS and BFS visit every vertex exactly once. So if you really want to use them, then as vertices you should view permutations (whole strings like "abcd", "abdc", etc.) rather than separate characters like 'a', 'b', etc. Starting with some initial vertex like "abcd" you should try to swap each pair of characters and see if that vertex has been already visited. You can store the set of visited vertices in an . So e.g. in "abcd" if you swap 'b' and 'c' you get "acbd" etc. This algorithm should produce each permutation because for Heap's algorithm it suffices to swap just one pair of vertices in each step: https://en.wikipedia.org/wiki/Heap%27s_algorithm  12k44 gold badges6666 silver badges128128 bronze badges  2  Thanks for the logic. I wonder why people downvoted this question though. I have added the relevant code for your logic in the question.  If you strictly want to emulate a graph traversal algorithm...Here's an intuitive(probably not the most graceful) approach:  Think of string as a graph, where each character is connected to every other character  Instead of trying to find a "path" from source to destination, frame the problem as follows: "find all paths of a specific length - from every source"  So start from the first character, use it as the "source"; then find all paths with length = length of the entire String... Then use the next character as the source...  AlTHOUGH this is C++ implementation, but you can easily transform it to a C version  47011 gold badge1010 silver badges2424 bronze badges  1  Please summarize the content of the link. Once it is gone your answer becomes useless.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  