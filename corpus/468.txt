 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  P.S. oh, I found that I didn't control boundaries when saving addresses into tr.nodes. But this is not the point...  If you think you might be scribbling over the end of your , and this is a runtime error, then you might be overwriting . Have you checked?  the way you implemented the inner for loop means that you start at tr.nodes[1] for dit.begin()->dwAddr; is that intentional?  @Moritz - no, that's a postincrement; increment and return the old value (or, conceptually, use the old value and then increment)  1 Answer 1  Some 's wouldn't go astray. And pre-increment your iterators, avoiding useless iterator object copies.  I agree with @Chowlett, and think you're stomping out of your bounds and over one of your iterators. Since you are instantiating your object during the loop, there is a good chance this is happening. You will usually get the error when your iterator has been invalidated.  Is there any reason you're member can't be a vector too?  17.7k66 gold badges3333 silver badges4444 bronze badges  4  is a storage class specifier, not to be used to implicitly infer the type in C++03 or less and its not tagged C++11.  – user195488  Aug 7 '12 at 13:28  While true, we don't know he can't use C++11. It's not like it's a completely new language. Until recently, I'd barely registered that my compiler supported a bunch of (and not all of!) C++11 features.  @Chowlett By now many people make the simple assumption that C++11 is enabled. It makes the examples easier to write and shows beginners The Way (tm). As long as the code is easy to port back, no harm is done. More intrusive features shouldn't be used extensively, of course.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  