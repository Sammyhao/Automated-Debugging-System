 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I've relatively new to using maps, and I'm currently getting the  When I hit retry it brings me to this section of code:  I assume this has to do with the returning the end of the map, as it didn't find it, but the concerning part here is that doing my manual debugging I found that the only in the map indeed contained the exact parts of the I had it search for.  My map is this:  Optimistically what I would like it to do is search for the and to ascertain that it is looking at a node that has already been searched so that I can set the accompanying to false.  What I'm wondering, is how do maps generally search for objects? Or better yet, how can I go about making the map search with a custom search?  52611 gold badge66 silver badges2020 bronze badges  1  Sometimes this can be an indication that you passed a map to a function by value instead of by reference, but that looks unlikely in this case.  3 Answers 3  42.7k88 gold badges7777 silver badges9797 bronze badges  2  This got rid of the error, but until I get rid of some more errors I won't know if it truly did the trick (make sure the paths are working correctly)  You need to make sure every iterator is valid when you try to find them STL container. btw, whats' the other errors?  If all you're doing is tracking the presence of some or other, you'd be better off using a .  As for a custom search, both and work with a collection of values, ordered by a comparator. That comparator can be specified as the second template type when the map or set is defined. If omitted, that comparator defaults to , which simply compares the objects with the less than operator, . As written, your map is using the value of the pointer to perform this comparison, which is probably not what you want.  I suggest you declare and define , and replace with a member of type . This will key off of actual values, rather than pointers (which will probably never collide under normal circumstances).  Remember that your should generate a strict ordering of PathNode objects. This is a requirement of the comparator for std::map and std::set. if you don't follow this rule, it will behave erratically, but it will compile and run, so make sure you pay attention to this detail.  It's a very good thing to have in the answers for others who may do the same thing I'm doing. A lot of people will just glance over the comments.  It's too long for a comment. It's hard to really say if this is properly useful without seeing more code, but there's rarely ever a need for that a doesn't handle more concisely.  You should check the result as billz said. The most likely reason that the find failed is that your map is keyed on meaning that it will only find nodes with an exact pointer match. Searching for a pathnode with the same member values as one in the map will not work.  If you need the map to be on , then you will need to also supply a as the third parameter of the map. The will need to be written to compare two parameters by their member values.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  