 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Is there an established algorithm for finding redundant edges in a graph?  For example, I'd like to find that a->d and a->e are redundant, and then get rid of them, like this:  =>  Edit: Strilanc was nice enough to read my mind for me. "Redundant" was too strong of a word, since in the example above, neither a->b or a->c is considered redundant, but a->d is.  Does redundant mean "an edge X->Y is redundant if there is a non edge path from X to Y" or are you simply looking for a spanning tree ?  @Zach: No, B->C is not redundant, because if it is removed there is no path in the resulting graph from B to C.  Sorry to have made your comments incorrect, but I've updated with a better example.  This is weird. The picture used to describe the problem is the one used in the linked solution (wikipeda). What is going on here?  5 Answers 5  You want to compute the smallest graph which maintains vertex reachability.  This is called the transitive reduction of a graph. The wikipedia article should get you started down the right road.  16.9k44 gold badges6464 silver badges127127 bronze badges  2  Thanks, that's exactly what I'm looking for. The Wikipedia article even mentions 'tred' for Graphviz, which is especially handy, since that's what I'm working with.  Since the Wikipedia article mentioned by @Craig gives only a hit for an implementation, I post my implementation with Java 8 streams:  Several ways to attack this, but first you're going to need to define the problem a little more precisely. First, the graph you have here is acyclic and directed: will this always be true?  Next, you need to define what you mean by a "redundant edge". In this case, you start with a graph which has two paths a->c: one via b and one direct one. From this I infer that by "redundant" you mean something like this. Let G=< V, E > be a graph, with V the set of vertices and E ⊆ V×V the set of edges. It kinda looks like you're defining all edges from vi to vj shorter than the longest edge as "redundant". So the easiest thing would be to use depth first search, enumerate the paths, and when you find a new one that's longer, save it as the best candidate.  I can't imagine what you want it for, though. Can you tell?  I think the easiest way to do that, actually imagine how it would look in the real work, imagine if you have joints, Like  (A->B)(B->C)(A->C), imagine if distance between near graphs is equals 1, so  (A->B) = 1, (B->C) = 1, (A->C) = 2.  So you can remove joint (A->C).  In other words, minimize.  This is just my idea how I would think about it at start. There are various articles and sources on the net, you can look at them and go deeper.  Yeah, but still You can use algos from various areas to solve this problem, by your needs.  I had a similar problem and ended up solving it this way:  My data structure is made of dictionary, from a node id to a list of nodes that depend on it (ie. its followers in the DAG). Note it works only for a DAG - that is directed, acyclic graph.  I haven't calculated the exact complexity of it, but it swallowed my graph of several thousands in a split second.  9,13822 gold badges2929 silver badges4141 bronze badges  1  just wanted to comment on previous answers - Reducing the redundant edges is NOT the same as Spanning Tree, not even the same as Minimum Spanning Tree. And if one path from A to B is longer than another path from A to B it doesn't mean anything about what edges (if any) are redundant. In his example above you can construct a spanning tree without edge a->b but it is not redundant.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  