 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  What is the difference between and ? What is the appropriate use for each? Why are they different in the first place?  2 Answers 2  is the class whose only purpose is to serve as the base class in the exception hierarchy. It has no other uses. In other words, conceptually it is an abstract class (even though it is not defined as abstract class in C++ meaning of the term).  is a more specialized class, descending from , intended to be thrown in case of various runtime errors. It has a dual purpose. It can be thrown by itself, or it can serve as a base class to various even more specialized types of runtime error exceptions, such as , etc. You can define your own exception classes descending from , as well as you can define your own exception classes descending from .  Just like , standard library contains , also descending from .  The point of having this hierarchy is to give user the opportunity to use the full power of C++ exception handling mechanism. Since 'catch' clause can catch polymorphic exceptions, the user can write 'catch' clauses that can catch exception types from a specific subtree of the exception hierarchy. For example, will catch all exceptions from subtree, letting all others to pass through (and fly further up the call stack).  P.S. Designing a useful exception class hierarchy (that would let you catch only the exception types you are interested in at each point of your code) is a non-trivial task. What you see in standard C++ library is one possible approach, offered to you by the authors of the language. As you see, they decided to split all exception types into "runtime errors" and "logic errors" and let you proceed from there with your own exception types. There are, of course, alternative ways to structure that hierarchy, which might be more appropriate in your design.  Update: Portability Linux vs Windows  As Loki Astari and unixman83 noted in their answer and comments below, the constructor of the class does not take any arguments according to C++ standard. Microsoft C++ has a constructor taking arguments in the class, but this is not standard. The class has a constructor taking arguments () on both platforms, Windows and Linux. To be portable, better use .  (And remember, just because a specification of your project says your code does not have to run on Linux, it does not mean it does never have to run on Linux.)  298k3939 gold badges502502 silver badges744744 bronze badges  4  1  thank you. great answer. though i wonder if there is ever a need to have different type of exception...just a thought though.  If there is a potability that the exception can be re-covered from, then a different type of exception can be useful as we can use the exception handling mechanism to direct the exception to handler that will try and correct the problem. If there is no chance of recovery than one of the standard exceptions is fine.  Just as an aside: there is no rule, anywhere, that forces you to derive from . Sure, all things throw derived classes of that, but there is absolutely no reason to only throw derived objects.  @rubenvb I did not know about that, but I think it will clearify the code for future maintenance if only objects of classes derived from exception are thrown. Example: I like to find out what custom exceptions are implemented in my code base and search for classes derived from exception.  should be considered (note the considered) the abstract base of the standard exception hierarchy. This is because there is no mechanism to pass in a specific message (to do this you must derive and specialize ). There is nothing to stop you from using std::exception and for simple applications it may be all you need.  on the other hand has valid constructors that accept a string as a message. When is called a const char pointer is returned that points at a C string that has the same string as was passed into the constructor.  242k8080 gold badges318318 silver badges538538 bronze badges  3  1  Thanks for the answer martin. However, i use std::exception() the same way as you described above. i.e. std::exception() constructor can also take a std::string() or const char*.  Not according to the standard. std::exception has one constructor that takes no arguments. Using a version that accepts a std::string or a C-String is non portable.  Because of Microsoft, I got used to throwing . Now I realize that I must throw if I want my code to work in Linux (GCC).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  