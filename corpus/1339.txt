 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  i did this question in two different way using heap and second is using map.  my solution using map.  but my map solution is giving Time Limit Exceeded. according to me map solution also has a time complexity of (n+klog(n)), same as heap solution. so why is map solution giving TLE?  I have an answer for this. Vote to repopen as it seems pretty obvious what the question is. Which is better a std::map or a heap data structure.  The problem here is both methods have a complexity of O(n.log(n)). The trouble is map uses allocations per item while a heap implementation usually uses a vector and thus less allocations. Thus the problem is the overhead of memory manegment. So the heap implementation should be significantly more efficient (assuming a few things: 1: You know the number of elements before hand 2: The cost of moving the elements does not outway the cost of memory mangement).  The heap selection algorithm has time complexity (n * log(k)), where n is the total number of items. k is the item you want to select (i.e. the kth item).  3 Answers 3  The time complexity for your solution using maps would be O(k + nlog(n)). Each insertion into takes log(n) time and you are performing 'n' insertions. Time complexity for insertion alone would take O(nlog(n)) time.  Inserting an element into a heap data structure is also . So inserting n elements is for a heap as well.  Insertion of elements into a heap can be done in linear time. See this answer for the derivation of time complexity for insertion into a heap.  Assuming he's referring to the algorithm in the link provided in the question insertion would take linear time.  Don't see that. When the documentation for the implementation clearly states it will take .  Without seeing your heap version I would guess the map's allocation is the cause of the trouble. Each node needs an allocation, which implies a lock and some additional management.  And you have to follow the pointers internally in the map data structure, which is usually not the case in heaps.  In big O notation this doesn't add anything to the time, but in practice each can slow down the program by a large factor.  A simple improvement to the algorithm is that there is a "trick": * If you only need to print "k" elements, then you only need to remember the "k" biggest elements. That way the insert operations never exceed O(log k) rather than O(log n). And k is presumably much less than n...  So instead of inserting everything into a map that gets bigger and bigger (and slower and slower - you mention a time-restriction). Change the code to remove the smallest element in the map once (map.size() >= k):  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  