 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am investigating a crash due to heap corruption. As this issue is non-trivial and involves analyzing the stack and dump results, I have decided to do a code review of files related to the crash.  To be frank, I don't have in-depth knowledge of when the heap could be corrupted.  I would appreciate if you could suggest scenarios which could lead to heap corruption.  6,05266 gold badges3636 silver badges5252 bronze badges  7  1  hmm, might be a bit general...suggest you provide more (well some) detailed info...  Your question lacks a lot of details. Can you specify the platform and the context please?  I've used Compuware's BoundsChecker to successfully track down some weird memory errors. It's not free, but I've found it incredibly useful, especially for tracking down some really obscure errors.  It's impossible to provide code samples for this. You might as well ask "what does code which doesn't compile look like". There's a literally infinite number of possibilities. The key to programming C++ (or any other language) is to stick within the things allowed by the language. You can't go the opposite way, and try to compile a list of "as long as I don't do these things, my code is valid C++"  Mostly if you have sections of code that seem to be suspicious for corrupting the heap, you could insert _heapchk (see msdn.microsoft.com/en-us/library/aa298379%28VS.60%29.aspx ) to check if the heap is still OK or already corrupted.  10.7k88 gold badges4545 silver badges5959 bronze badges  8  Using pointers pointing to garbage. I had a rather insidious one. const WCHAR * cstr = ICUString.c++str().c_str(); The syntax is wrong, but basically, I went from ICUString to std::wstring to const WCHAR *, but since the std::wstring is a anonymous object, it's deleted after the line's done, thus my pointer's pointing to garbage. Accessing it led to corruption and crash.  Don't forget calling delete on two different pointers to the same object on the heap  Add to that: Passing random/already deleted pointers to , mixing / with /, missing or incorrect copy ctors/assignment operators, polymorphically used base classes with non-virtual dtors... This list is very long. Basically it boils down to what I have summarized here: stackoverflow.com/questions/1346583/1346631#1346631  @Kelly: It's passing pointers to which is doing nothing. Passing the same pointer to twice is a fatal error leading to what's called undefined behavior. Usually this invokes Nasty Nasal Demons on you.  Welcome to hell. There is no easy solution so I will only provide some pointers.  Try to reproduce the bug in a debug environement. Debuggers can pad your heap allocations with bound checks and will tell you if you wrote in those bound checks. Also, it will consistently allocate memory using the same virtual addresses, making reproductibility easier.  In that case, you can try an analyser tool such as Purify. They will detect pretty much anything nasty that your code is doing but will also run VERY slowly. Such a tool will detect out of bound memory access, freed memory access, trying to free twice the same block, using the wrong allocator/deallocators, etc... Those are all kind of conditions that can stay latent for very long and only crash at the most inopportune moment.  26.1k77 gold badges5252 silver badges7474 bronze badges  2  sadly, This crash is not easy to produce,only happens once in almost million time  I understand. However, even if the bug manifests itself by a crash one in a millionth time, it might still be detectable pretty easily by an analyser tool.  There are products that will observe the memory allocations and deallocations, and produce a report on anomalies. Last I used one, they weren't cheap, but I don't know what the situation is right now. However, finding stuff for VC++ 6 might be a problem.  Remember that you're liable to be getting heap corruption a lot more often than you're going to crash, so be attentive to the problem reports, and fix all heap corruption.  I'd suggest using instead of raw pointers everywhere, but I'm not sure VC++ 6 is going to support that.  Why are you still on VC++ 6? Would it be practical to upgrade? The tools are better with the more recent versions, and they fully support smart pointers.  54.9k88 gold badges8989 silver badges153153 bronze badges  1  Thanks David, Your comments are valueble ,Migrating from VC++ 6 is a big decision , Its a legacy code so there a few change possible , Yes in future i would like to use smart pointer :) thanks  You can look at the sample chapter from the Advanced Windows Debugging book which provides various examples of heap corruption.  EDIT: If you are using stl containers which might move elements during changes (i.e. vector, deque), ensure that you are not keeping references into such elements across operations which might changes it.  Its a common mistake to free() or delete allocated memory more than one. It may help to insert something like *var = NULL after such calls, and to check for != NULL when calling free. Although in C++ its legal to call delete with a NULL variable, calling C - free() will fail.  Also a common problem is to confuse delete and delete [].  Variables allocated with new must be released with delete.  Array allocated with new [] must be released with delete[].  Also make sure not to mix C- style memory management (malloc, calloc, free) with C++ style memory management (new/delete). In legacy code often both are mixed, but things allocated with the one can not be freed with the other.  All of these errors will usually not be recognized by a compiler.  11.6k1010 gold badges4848 silver badges8686 bronze badges  6  thanks StefanWoe one basic Question , if is do new[] but use delete, rather than delete, how it will lead to heap corruption , Can rest of memory re-allocated ?  its my bad english : ) , I mean to say if i initialize char *ptr=new char[100] , and do a delete ptr, will it free first char only..if yes what will happen to rest of 99  What will happen in that case is explicitly undefined by the specification. Most likely result is that the destructor is called for first element in the array and entire block of the memory is released. However crash, leak or heap corruption might be also possible.  The behavior of calling "new[]" and then "delete" is not defined. It might free only the first element, crash the program, cook coffee whatever.  The answer I suggested provides a technique which may be able to get you back to the code that is actually causing the heap corruption. My answer describes the technique using but I'm sure you must be able to do something similar on windows.  Every time you do something which isn't defined in the language standard, it is undefined behavior, and one of the ways in which it might manifest itself is through heap corruption. There are about three million ways to do this in C++, so it's really impossible to say.  A few common cases are double-freeing dynamically allocated memory, or writing outside the bounds of an array. Or writing to an uninitialized pointer.  Recent versions of Microsoft's compiler add an /analyze compiler switch which performs a bunch of static analysis to catch such errors. On Linux, valgrind is an obvious choice.  Of course, you are using VC6 which has been unsupported for years, and which has a number of known bugs, resulting in invalid code being generated.  If possible, you should upgrade to a proper compiler.  An additional debugging tip is to look at the values that are being written to the wrong place using the raw memory view. Is it writing zeros... strings... some other recognizable number pattern? If you can see the corrupted memory at some point after the error occurs, that can provide a hint of the code that caused it.  Also always set pointers to null after deleting them even in destructors. Sometimes unexpected things can be triggered during a destructor chain in a base class than cause an access to a partially deleted sub-class.  During freeing heap memory, first child memory block need to be deleted and then parant memory block otherwise the child momory block would be leaked parmanently which causes the crash after running the tool millions of times.. ex:  The most difficult memory corruption bug I've run into involved (1) calling a function in a DLL that returned a and then (2) letting that fall out of scope (which is basically the whole point of ). Unfortunately it turned out that the DLL was linked to one version of the C++ runtime, and the program was linked to another; which meant that the library was calling one version of and I was calling a completely different version of .  That is not what's happening here, because that failed every time and according to one of your comments "the bug manifests itself by a crash one in a millionth time." I would guess that there's an statement that gets taken once in a million times and it causes a double bug.  I recently used evaluation versions of two products that may help you: IBM's Rational Purify and Intel Parallel Inspector. I'm sure there are others (Insure++ is mentioned a lot). On Linux you would use Valgrind.  19.1k33 gold badges4343 silver badges6969 bronze badges  1  1  Even your bug might, under some circumstances, only lead to a crash once in a million times the vector passes its memory to the wrong heap for deletion. It's the nature of undefined behavior that its outcome is, well, undefined.  have you thought isolating the source of the corruption using gflags? Once you have a dump (or breaking debugger -> WinDBG) you could see where the corruption is caused more precisely.  In our file we have to check the flags which we have set. If we have set the flag value as then there will be no serialization which means multiple thread will access the resources which may cause memory corruption.  "Setting the value eliminates mutual exclusion on the heap. Without serialization, two or more threads that use the same heap handle might attempt to allocate or free memory simultaneously, likely causing corruption in the heap."  so I think due to the memory corruption in the heap, the node got crashed.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  