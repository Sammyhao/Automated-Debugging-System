 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I want to ask you for a hint, as I am a beginner and couldn't find any suitable answer in the internet. I am getting this error: debug assertion failed - map/set iterator not dereferencable at the line that looks like this:  with the function pointNext() as I see everything is ok, and what concerns active, I have:  Some more info:  active is multiset< classA, classB::classC >::const_iterator  setS has: setS.Q, setS.W, setS.T and setS.data, whereby setS.data has inside 0 in square braces. When I have multiset iterator declaration in .cpp file, during debug I cannot enter to see what is inside active, when it is in .h file, I can.  Having in .cpp I cannot enter active, so can imagine it's like pointer(iterator) cannot dereference, because is wrong inside. What if it is empty, i.e. if setS.data is empty? or if there's some trash inside?  I know the thing was running under linux previously, is there some feature which I have to change for running on windows maybe? For example to change a number of template parameters to one only? (to properly ascribe setS.data to active, because I am not sure - do I do it properly?  Sorry for this rather chaotic post, I wanted to add my guesses for someone to neglect them if they are wrong. If something here is unclear or lack of some information, I will gladly add it. Can you please tell me what reasons could cause the dereferencablility error I get and where should I look for it? Because I am stuck and don't know how to proceed.  5 Answers 5  Quite simply, since points to the container's , you are not allowed to dereference it.  I know the thing was running under linux previously  If the code was exactly like this and was "running", all this means that the error has never manifested itself in a manner that you've noticed.  455k9797 gold badges905905 silver badges981981 bronze badges  2  sure, now I understand. Can you please explain me if I have: (last one as public member of some class which is in namespace vlr) --> what exactly is the first template parameter for multiset, and the second? I get the feeling I don't understand exactly what is being ascribed, maybe after some explanation I could better find mistake. thanks!  @eco_student: The second parameter to a set is the type used to compare objects of the first parameter. Remember the set is an ordered container so here is a comparator type that can compare objects of type . See: sgi.com/tech/stl/multiset.html  This returns an iterator to one passed the end of the container. Thus the item that it is pointing at is not valid. You can not call any methods on the object that the iterator is referring too.  You cannot de-rederence the iterator returned by a standard library's function, as this is "one past the last element". Typically you would iterate over the valid range, i.e. stopping before you reach :  214k2929 gold badges373373 silver badges458458 bronze badges  3  ah sorry for this, as I said I am a beginner. So for now I ended end() into begin() and tried this iterator in an expression: , and I get the same error! As I said in setS.data was 0, but in active some strange numbers were ascribed. Does it mean that my problem is, there is trash in active?  @user1578163 maybe you can show the problem with some code? It is difficult to understand what the problem is otherwise.  I get this error in the second line now. so I'm wondering if the cause is empty setS.data (and numbers like -6.2774385622041925e+066 in active out of nowhere), and if I should start going into complicated data further, or problem is somewhere else. what do you think?  end() points to the element, after the last element. so end() isn't dereferencable.  You need to add a check to see if you're at the end, and if you are, don't dereference it.  tries must dereference "active" to call operator->(...) on it, but active is equal to setS.data.end();  end() returns an iterator to the element after the end of the container. Therefore, you can't dereference it.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  