 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a function with a prototype like the following:  This function is called in my main function in another program that loads and uses that dll.  When returning from this function I get heap corruption error:  Windows has triggered a breakpoint in program.exe.  This may be due to a corruption of the heap, which indicates a bug in program.exe or any of the DLLs it has loaded.  This may also be due to the user pressing F12 while program.exe has focus.  The output window may have more diagnostic information.  Playing around with my code I noticed a few strange observations: 1. When length of the string passed in is less than 11 characters I get no errors, as soon as I add more characters the error appears. 2. When changing the type of parameter from to the error disappears. The idea of passing reference came from here. 3. I've commented out the body of the function. The operations in there have nothing to do with the exception produced. 4. Changing parameter type from to also solves the problem. What could be causing this error? How do I solve it?  7,1281515 gold badges5858 silver badges100100 bronze badges  4  I remember reading that memory allocation across the DLL boundary can be tricky - probably best to use the fix you disovered, i.e. pass a reference.  Is the dll and your program compiled with the same version of std c++ libraries? Is both your program & dll release versions or are they both debug versions - i.e. one of them is not a different type than the other?  @user93353 The dll is actually another project in my solution (VS 2008). Right not I'm using both debug versions.  3 Answers 3  Most likely, you're seeing crashes due to the fact that, in Windows, DLLs have their own private heap.  When you compiled your function, the compiler generated some code for 's destructor, to clean up its arguments. This code frees the allocated memory on the DLL heap. However, the application EXE also generates its own code for 's constructor, which allocates the code on the program heap. When you allocate on one heap and free on the other, undefined behavior occurs, and you crash.  As for why small strings don't trigger the bug - many implementations inline small strings into the struct itself, to avoid heap overhead. When your string is small enough to fit, no memory allocation need take place, and thus it happens to appear to work... as long as you use the same STL version for both EXE and DLL, and the threshold for inlining never changes.  To avoid this issue, don't pass objects by value to DLLs (unless they are POD objects), and don't free an object in a different DLL or EXE than it was created in. Avoid passing STL or C++ library objects around as well, as their implementation may differ between different versions of the C++ compiler. Pass POD objects or C primitive types such as instead.  211k2929 gold badges255255 silver badges320320 bronze badges  3  Thanks alot, that explains everything. However, are there any references to back you up? Can't dll and application agree that parameter destruction should be done by application rather than dll? This should solve the problem.  The statement that DLLs have their own heap in Windows is plainly wrong! There are only different heaps when different version of the C++ runtime are used, which happens when the C++ runtime is linked statically (should never be done with DLLs) or different versions of the C++ runtime are used (should also be avoided).  When exporting DLL functions, it's best if they accept only integral data types, i.e. int or pointers (not sure about float and double).  When you need to pass a string, pass it as a , when you need the DLL function to return a string, pass to the DLL a pointer to a pre-allocated buffer, where the DLL would write the string.  Never use memory allocated by the DLL outside of the DLL's own functions, and never pass by value structures that have their own constructor/destructor.  Probably you have linked with static version of C runtime, it is never a good idea to create a DLL that linked with static version of C runtime. This may cause many problems, for example in your program your EXE allocate memory from private heap of static C runtime that it is linked with it, then in your DLL you want to delete that heap and create a new heap(since you want to add some data to the input string and it need to grow its buffer), so it will cause an error. Simplest approach to this is to link all parts of your program(EXE and DLL) with DLL version of C runtime, so they all share same heap from MSVCRTXX.dll  6,77711 gold badge1919 silver badges3838 bronze badges  3  That's true. I am linking CRT statically. However I'd rather not change that setting (I'd have to do too much for that).  So you have no way except avoid any object that have memory management(like and ) or you should write a custom allocator that do memory allocation from a common heap for example use and  Sorry, I cannot understand why it should be hard to change to dynamic CRT linking. You will lose far more time by continuing to use the static version...  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  