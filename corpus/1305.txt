 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a file of data with intersections (ID Safety Name) and Streets (Intersection1 Intersection2 distance) as shown:  The intersections are the vertices and the streets are the edges. Here are my headers: Vertex header:  Edge header:  I am making a graph out of lists. I already have that all set up and I've made the graph (or map) of the streets/intersections. I know I need to use Depth-First search because of the requirements below but not sure how to implement. If someone could give me an example of Depth-first search, it would be great. Now my assignment needs me to:  Jogging Path Requirements  The safejogger program should search the provided graph to find jogging paths that meet the following requirements: The path must start and end at the same intersection (i.e. vertex) indicated by the user-specified startingIntersection. The path should not revisit any intersections. In other words, no vertex should appear twice within the path. The path should have a total distance within 1 mile of the user-specified distance goal.  Jogging Path Safety  The safejogger program should computer two statistics for jogging paths, including: Average Path Safety: The average Safety Index of all intersections within the jogging path. Minimum Path Safety: The minimum Safety Index of all intersections within the jogging path.  If the graph is circular it's not s straight forward DFS. Are you trying to compute all jogging routes within a certain distance that are the least dangerous?  @gvd yes that's correct. I just need an example of depth first search, because I think if you apply conditions to end it like if the distance is too far, then stop traversing. Then after finding the closest distances I print them out in order of danger.  It seemed for me that depth DFS would be better but not really sure which would be easier.  1 Answer 1  If you want to implement DFS on a graph, you need a way to mark vertices which have already been visited. You can change your vertex struct to include a flag, or have a separate bit vector which regroup all the flags together.  For the DFS algorithm, it is pretty simple:  You mark the vertex you start off,  you follow each edge leaving it,  if the end vertex isn't already marked, you recursively run the DFS algorithm.  That's the base line. You can turn that algorithm into a loop (instead of recursion) by using a stack.  In your assignment, you will have to do something at each step of the DFS, so you need to figure out how to do that extra stuff. Hint: make a class which does the DFS work on the graph, and derive that class to implement the extra stuff.  The second part of your problem isn't about DFS, but about processing the result of your search, a jogging path, which is a list of vertices.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  