 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I initialized the hash table by filling it with empty lists.  Now if I want to add an int to my table based on:  and I use  It should work right? I can't get it to work.  The code above does not add the element to any of the lists within the vector.  Also, when I want to use an iterator to traverse the vector and the lists within the vector, how do I get one element at a time from a list so I can find a particular value that may or may not already be in the list?  This is what I have for finding a value within the hash table:  I'm stumped. I don't understand why it won't add the value to any of the lists.  I feel I should mention this is all in a header file and part of a class that I created. (I don't know if that matters)  Edit: The warning statement does not print. To answer questions, the mt_hash() function checks to see if the hash table is empty and I have checked it several times to make sure it outputs correctly. I fixed the hTable_1 vs hTable difference, they are the same thing. I just forgot to change it when I put it into the question.  10.6k33 gold badges1515 silver badges1717 bronze badges  2  There's a lot of global state that you aren't showing us. This means there are many possible issues. Is implemented correctly? Why do you say in and in ? BTW this should be very easy to figure out with a debugger.  I am using ubuntu and geany. I have code::blocks but the debugger isn't working properly. I havent tried gdb yet. You are right, I need to just give in and use gdb in the terminal.  2 Answers 2  As Pradhan points out, there is a quite a bit missing. What is the implementation of ? Are and the same object?  Below, I've taken your code above, and placed them in a struct with the implied functionality included. Note three changes: replaces in ; uses a local variable to store the hash key; and is implemented by keeping a simple element count.  This produces expected output:  I suspect the original problem lies in and referring to different hash objects, or a problem in misreporting that the table is empty when in fact it is not.  The answer to the this problem is to create the class object of type HASH_TABLE in the main cpp file and then pass it by reference into the function (getCmd) that calls all of the commands and i/o.  I was calling the "getCmd" function in main() and that function (EVERY time it is called) creates a NEW instance of the HASH_TABLE class, effectively "replacing" the previous object with a new, empty object. (though I suspect it did not actually replace the previous object. I think the previous object was still taking up memory but it was not being used)  I didn't post the code for the problem area because I didn't know where the problem was.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  