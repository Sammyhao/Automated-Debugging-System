 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have made an Adjacency list using and a linked list. Inside the struct for node, I have data, next and visited. When I try setting visited to true in the DFS function, The algorithm does not work correctly. It only works when I create a new array storing the boolean values and using that array for the dfs algorithm. I need help getting the member visited of the vertex struct to work. I am not sure why it does not work.  31111 gold badge33 silver badges1414 bronze badges  8  1  So in is the target vertex? Then there's new vertex for each edge, i.e. consider adding .. there exists two vertices "3", one in and other in . So when you visit one of those "3", it set's only it's local visited value, the other has no idea. Why pointers? Why ? Any particular reason, or this is the best you come up and you wouldn't mind complete rewrite of it?  I see! yes i see the problem. I am using pointers because I wanted to use my own linked list. Just getting practice using pointers and such. I'm transitioning from Java to C++.  With your current graph you actually don't need any vertex, as vertex has no data at all, you need only edges data (from->to, or v1<->v2, if you want only two-way edges). And having single local at the start of DFS (whatever that abbreviation is) is more logical, than having "visited" part of graph data, it's meaningless field without some ongoing algorithm (unless it's "visited" as visited in input data, like visited city by person). So you need that vector only during DFS, then you can discard it. The local variable is exactly that.  hmm... so.. your focus is on: 1) pointers usage, and memory management 2) own linked list creation 3) modern C++ way to write the DFS algorithm? (both 1 and 2 are not needed in 3 (naked pointers and by-hand memory management can be avoided in such case and there are already several containers in STL available, including some list variation), but it's good to learn them... but focus on them one by one at time?) ... BTW, you are using without , which means memory leak. If you are coming from Java, learn first to use available containers + local scope variables, to avoid new/delete.  ahh, yes I see your point. "DFS" for depth-first-search by the way. Thank you for your comments. very helpful to realize my mistake. Now, from your first comment where you have an example like addEdge(0, 3); addEdge(1,3), you said 3 is now 2 new Vertex. I want only one existing vertex not two different instances. how would you recommend fixing this problem?  1 Answer 1  Clean up your data structures first, you are bending them in favour of your algorithm too early, which back fires with a bit of mess. Make sure you have some solid "model" first, without any algorithm in mind, then check what an algorithm needs, and add it either as local temporary inside algorithm, or some cached/extended data added to model. But keep the core model under it.  What I mean, let me show you super inefficient, but simple implementation of your DFS in hopefully something what can be considered "modern C++" (but I'm not expert either):  (now I realised, my "addEdge" doesn't prevent from duplicate edge addition, like yours, consider it bug or feature)  If you check it, you will see the performance is bad, because it's searching all edges every time. How to help it? To have already prepared neighbours data for each vertex.  Then in you can set the adjacent vertex for each added edge:  Now it's lot more efficient (as far as depth-first can be efficient, Breadth-first search would be lot more easier to write without recursion using lot of stack space).  But if the DFS and printGraph was your only goal, then this can be refactored by removing the completely, and keeping only and inside them . You can try it on your own, you will see it will take only few changes.  But the field stays as temporary owned by the , IMO that's the best-fit how to use it.  This is already so long, and took so long, that I'm not in mood to show you something with pointers, new and delete. Showing you how to avoid them is probably still of more benefit, at least until you can produce similar or better code on your own.  Learning the naked pointer/new/delete stuff is important too, but ... check some tutorial?  At least one hint "when to ": In modern C++ you can think in the scope. Like everything belongs somewhere (in some scope), and then it's released, upon exiting the scope. By thinking this way, you just implement constructor+destructor in your classes, and you are done with clean-up.  Like the in my example being local variable of , thus in it's scope. When is being exited, the destructor of is called (which I didn't write, as the default destructors are created by compiler to call the and destructor, and the destructor gets called by destructor, which implicitly calls destructor. So everything is released, no memory leak.  If I would use some in trough it's life cycle (either in constructor, or in some function), either I would put the pointer in some Graph member variable, and write explicit destructor checking that for non-nullptr value, and delete it, or delete it sooner in some function (and set the storage to nullptr to avoid double delete on the same pointer).  So if you make sure your design of classes makes sense, and everything belongs in some reasonable scope, you then use paired by constructor/destructor, and you know the clean-up happens upon exiting the scope, which did own (was responsible) for that piece.  There are other techniques, how to pass pointers (or any resource actually) around from the original owner to other classes ... generally I would try really hard to avoid that, but if you really insist on such application structure, you can use things around . But this design is a bit harder to keep clean, and to track down responsibility/ownership of particular memory or resource. Watch for example this video for some ideas how to deal with it in somewhat elegant way.  And some final note about and pointers and linked lists. You may be used from Java to things like linked lists and hash maps, and it makes sense under VM, as you have little control over memory management and instances are usually "crufted" heavily with object meta data.  In C++ it's different, there's usually near-zero overhead, so is one continuous block of memory of length four million bytes, with additional few bytes of vector meta data aside of that.  This means, that my first O(n*n) example going trough all edges almost every time, can be for graphs with 100+k edges performance-wise quite close to your O(n) with pointers, as each your may end in different part of memory, breaking locality of processed data. That has huge performance penalties, when you try to access memory outside of cached memory page. While going trough 100k integers in continuous way is something the CPU can do half asleep, maximizing caches throughput (unfortunately the deep-first is messing it up too).  That's why usually you shouldn't be bothered much with container type during writing first version. If fits, use it. Then after you have working, tested code, you can profile it, and try out some smarter memory structures, eventually even replacing with some kind of linked list. But you can't rely on algorithm theory only or "logic".  When x86 performance is involved, having hard data from profiling real production code over real production data is crucial, the modern HW can surprise human logic in many ways, and challenge theories in unexpected ways. For best performance you need both reasonably complex (simple) algorithm, and neatly arranged data with predictable regular access pattern. Having only one of the two may be not enough.  15.6k22 gold badges2525 silver badges5353 bronze badges  1  Beautiful. Thank you very much for all your help. I really appreciate it. I'm glad there are computer scientist out there willing to help out! I will definitely take a look at the resources you have provided. C and C++ are beautiful languages yet complicated haha.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  