 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I need to sort an by value rather than by key. Is there an easy way to do it?  I got one solution from the follwing thread: std::map sort by data? Is there a better solution?  1,67833 gold badges1717 silver badges1919 bronze badges  3  3  Why do you need the map sorted that way? Are you trying to improve lookup time, or do you want to traverse it a certain way?  14 Answers 14  Even though correct answers have already been posted, I thought I'd add a demo of how you can do this cleanly:  Generic Associative Source (requires C++11)  If you're using an alternate to for the source associative container (such as ), you could code a separate overload, but in the end the action is still the same, so a generalized associative container using variadic templates can be used for either mapping construct:  This will work for both and as the source of the flip.  258k3030 gold badges543543 silver badges660660 bronze badges  5  1  thanks for the sample code. it helped me to generalize the solution. now i can filp any map easily.  +1 for the clean solution. However, it would be better if the destination map was a multimap, in order to avoid collisions with same "value" keys.  If multiple values have the same value, this solution does not work, as the reversed map can't have two pairs with the same key. For unique value in the original map, this solution works!  addendum added to include support for generic associative container rather than just . Nice answer, btw, Oliver.  I needed something similar, but the flipped map wouldn't work for me. I just copied out my map (freq below) into a vector of pairs, then sorted the pairs however I wanted.  This is a wonderful answer. The sort function can be made even more modular by passing in a Function object with the appropriate operator() overload for the desired sort logic. Nice use of the lambda logic though.  I'm using this code, it compiles fine in gcc 4.9.x, but does not compile on 4.8.x - however, specifying in front of both arguments of the lambda fixes it. Could this be a gcc 4.8.x bug, or did they make gcc 4.9.x more permissive than the standard requires?  If you want to present the values in a map in sorted order, then copy the values from the map to vector and sort the vector.  19k77 gold badges5858 silver badges7272 bronze badges  3  1  +1: This (or variants thereof, such as creating an "inverse" map) is the right answer.  if i do this. then i loose the relation between the key and values. say, i have map<long, double> id2Score. it contains all the id (where id is not 0..n, it may be like 1, 5, 13 etc) and score. then if i create a vector with score and sort then i will loose the information which id is associated with which score.  @ user619237: not really. You can sort the vector. Get the max or min or whatever value that you require. Then interate through the original map and look for a match to that value in the values of the map("it->second" .)  I like the the answer from Oli (flipping a map), but seems it has a problem: the container map does not allow two elements with the same key.  A solution is to make dst the type multimap. Another one is to dump src into a vector and sort the vector. The former requires minor modifications to Oli's answer, and the latter can be implemented using STL copy concisely  Here is an example program that shows all the key-value pairs being preserved after performing the flip.  Portable solution - works also with older vs's. Also smaller fingerprint in code.  You can't sort a this way, because a the entries in the map are sorted by the key. If you want to sort by value, you need to create a new with swapped key and value.  Remember that the double keys need to be unique in or use .  A sorted by it's value is in essence a . By far the easiest way is to copy all entries in the map to a set (taken and adapted from here)  One caveat: if the map contains different keys with the same value, they will not be inserted into the set and be lost.  Another solution would be the usage of std::make_move_iterator to build a new vector (C++11 )  Flipped structure might no longer be a map but rather a multimap, thus in the flip_map example above not all elements from B will necessarily appear in the resulting data structure.  U can consider using boost::bimap that might gave you a feeling that map is sorted by key and by values simultaneously (this is not what really happens, though)  In the following sample code, I wrote an simple way to output top words in an word_map map where key is string (word) and value is unsigned int (word occurrence).  The idea is simple, find the current top word and delete it from the map. It's not optimized, but it works well when the map is not large and we only need to output the top N words, instead of sorting the whole map.  In this context, we should convert map to multimap. I think convert map to set is not good because we will lose many information in case of there is many duplicate values in the original map. Here is my solution, I defined the less than comparator that sort by value (cmp function). We can customize the cmp function as our demand.  An alternative way to sorting a without any additional copying or transformation is to redefine the with different type:  This doesn't seem to work for me. I see the following output: I expected that the solution would, instead, produce the following output:  Just put the values into the vector and sort the vector on the value of each map key.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  