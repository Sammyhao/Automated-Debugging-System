 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  2 Answers 2  An explanation of why your code gives the results you see.  The first call to has 6 queues. will be the first three (), and will be the last three ().  Then you make a recursive call with . In that call, will be 3. will have one queue (), and will also only have one queue (). (I'm assuming the 2nd parameter to is a count.) This will stop at the second if because . The result will be that first queue.  Now we're back at the first recursive call (having lost the 2nd and 3rd queues), and we again main a recursive call with (which has 3 queues in it). This will proceed like the last call did, returning the first queue (which in this case is empty) and losing the other two.  Then you merge those two queues ( and ), resulting in your answer: .  This reveals two problems: Not properly dividing a Vector with an odd number of queues in it, and terminating the recursion too early (when the left half of the split only has one queue in it, even though the right half may not be empty).  It splits into two pieces, then either recurses or calls on it.  You can then test with debugging code that simply prints the pieces on the left/right in some way, and you can see how the recursion plays out.  Once you have that, you plug back in your program and it should just work.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  