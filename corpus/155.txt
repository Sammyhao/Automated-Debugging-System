 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm quite new to boost::threads, I read the documentation and but i'm having some trouble applying it in practice, perhaps you can help? First of all, I have taken the time to write a self contained code listing that demonstrates 2 types of behavior that I cannot yet understand...  The program allows the user to issue 3 different commands,  task [name]  info  quit  The purpose is that task will launch some work on a new thread, but then return back to the command prompt while the work is carried out. The user can give the info command to find out which tasks have completed and which have not.  Im using a dual core Win7 machine and Visual Studio 2008 Express.  Problem 1>  Issuing the command, task p1 p2 p3, starts 3 tasks running. This can be checked by issuing info. After a few seconds the work is complete, however for some reason the completed flag is not always set true on 1 or 2 of the tasks.  Problem 2>  Quiting the program then produces the following message:  Windows has triggered a breakpoint in example.exe. This may be due to a corruption of the heap, which indicates a bug in example.exe or any of the DLLs it has loaded. This may also be due to the user pressing F12 while example.exe has focus. The output window may have more diagnostic information.  Hopefully you can reproduce this behavior and help.  1 Answer 1  The problem here is that on pushing back a new task, your vector might have to reallocate some space and such invalidate the references to your old vector elements, such the following calls to will reference to the wrong elements. As you delete the old elements your heap will somehow get corrupted.  An easy fix would be to reserve some space for the vector in the constructor of your class, however you should probably change the design of your task/taskmanager model instead. Another way would be to use a , as that one won't reallocate memory.  I did not realize the std::vector reallocated old entries in that way, I was convinced the problem was with my boost::thread library usage.  I replaced the std::vector with std::deque and this seems to solve the unwanted behavior. @bamboon Out of interest, you suggest changing the design of the task/taskmanager model I am using, are you suggesting that there is something wrong with it currently?  @AlexS I am not seeing anything wrong anymore. However I recommend you to check out the new threading features, they already offer a lot of things which you are using like tasks, futures etc. those can simplify your program quite a lot.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  