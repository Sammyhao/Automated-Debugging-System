 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  What's the best way to create a balanced binary search tree from a sorted singly linked list?  Two traversal of the linked list is all we need. First traversal to get the length of the list (which is then passed in as the parameter n into the function), then create nodes by the list's order.  You can't do better than linear time, since you have to at least read all the elements of the list, so you might as well copy the list into an array (linear time) and then construct the tree efficiently in the usual way, i.e. if you had the list [9,12,18,23,24,51,84], then you'd start by making 23 the root, with children 12 and 51, then 9 and 18 become children of 12, and 24 and 84 become children of 51. Overall, should be O(n) if you do it right.  The actual algorithm, for what it's worth, is "take the middle element of the list as the root, and recursively build BSTs for the sub-lists to the left and right of the middle element and attach them below the root".  19.5k44 gold badges4848 silver badges7979 bronze badges  5  You should be able to build the tree as you traverse the linked list, without having to copy it into an array first...  The difference between our two algorithms is quite interesting (to me at least). You build the tree top down, I do it bottom up.  Well I find it interesting too :) Just taking a look -- I'd wandered off to do some work...  We both use a stack, too. Yours is implicit in the call stack and mine is an explicit one  I think it did it this way too. The only thing different is that instead of converting the whole linked list into int, I create a array of tree nodes. And then use recursion to link the tree nodes together, so we don't waste memory.  Best isn't only about asynmptopic run time. The sorted linked list has all the information needed to create the binary tree directly, and I think this is probably what they are looking for  Note that the first and third entries become children of the second, then the fourth node has chidren of the second and sixth (which has children the fifth and seventh) and so on...  in psuedo code  (with a bit of adjustment for when there's less than three elements left or an unbalanced tree at any point)  EDIT:  At any point, there is a left node of height N on the stack. Next step is to read one element, then read and construct another node of height N on the stack. To construct a node of height N, make and push a node of height N -1 on the stack, then read an element, make another node of height N-1 on the stack -- which is a recursive call.  Actually, this means the algorithm (even as modified) won't produce a balanced tree. If there are 2N+1 nodes, it will produce a tree with 2N-1 values on the left, and 1 on the right.  So I think @sgolodetz's answer is better, unless I can think of a way of rebalancing the tree as it's built.  40k1919 gold badges9999 silver badges131131 bronze badges  8  I'm not clear from the pseudo-code precisely what your algorithm is doing -- when you say "mark as level 1", are you marking just the middle element of the three as level 1, or are you marking all of them? Could you clarify?  I'm marking the node made from the three as level 1. It wasn't clear I was making a node with them, so I edited my answer.  @TimothChen, ah, foo, you've spotted a flaw. you need another value to use as the value of that node. It doesn't break the whole idea but I need to correct what's there. I think you just push another value onto the stack between the two nodes. Then pop the node, value, and node and make a higher level node of that. Too late for tonight to be certain its right (it's 10pm here)  @Paul: Same question as Timothy :) So you've got two nodes containing [9,12,18] and [23,24,51], and you combine them to make...?  The best way is to use the STL, and advantage yourself of the fact that the sorted associative container ADT, of which set is an implementation, demands insertion of sorted ranges have amortized linear time. Any passable set of core data structures for any language should offer a similar guarantee. For a real answer, see the quite clever solutions others have provided.  What's that? I should offer something useful?  Hum...  How about this?  The smallest possible meaningful tree in a balanced binary tree is 3 nodes. A parent, and two children. The very first instance of such a tree is the first three elements. Child-parent-Child. Let's now imagine this as a single node. Okay, well, we no longer have a tree. But we know that the shape we want is Child-parent-Child. Done for a moment with our imaginings, we want to keep a pointer to the parent in that initial triumvirate. But it's singly linked! We'll want to have four pointers, which I'll call A, B, C, and D. So, we move A to 1, set B equal to A and advance it one. Set C equal to B, and advance it two. The node under B already points to its right-child-to-be. We build our initial tree. We leave B at the parent of Tree one. C is sitting at the node that will have our two minimal trees as children. Set A equal to C, and advance it one. Set D equal to A, and advance it one. We can now build our next minimal tree. D points to the root of that tree, B points to the root of the other, and C points to the... the new root from which we will hang our two minimal trees.  How about some pictures?  With our image of a minimal tree as a node...  And then  Except we have a problem. The node two after D is our next root.  It would be a lot easier on us if we could simply maintain a pointer to it instead of to it and C. Turns out, since we know it will point to C, we can go ahead and start constructing the node in the binary tree that will hold it, and as part of this we can enter C into it as a left-node. How can we do this elegantly?  Set the pointer of the Node under C to the node Under B. It's cheating in every sense of the word, but by using this trick, we free up B. Alternatively, you can be sane, and actually start building out the node structure. After all, you really can't reuse the nodes from the SLL, they're probably POD structs.  So now...  And... Wait a sec. We can use this same trick to free up C, if we just let ourselves think of it as a single node instead of a tree. Because after all, it really is just a single node.  We can further generalize our tricks.  We are missing a critical step!  Becomes :  Obviously, the algorithm can be cleaned up considerably, but I thought it would be interesting to demonstrate how one can optimize as you go by iteratively designing your algorithm. I think this kind of process is what a good employer should be looking for more than anything.  The trick, basically, is that each time we reach the next midpoint, which we know is a parent-to-be, we know that its left subtree is already finished. The other trick is that we are done with a node once it has two children and something pointing to it, even if all of the sub-trees aren't finished. Using this, we can get what I am pretty sure is a linear time solution, as each element is touched only 4 times at most. The problem is that this relies on being given a list that will form a truly balanced binary search tree. There are, in other words, some hidden constraints that may make this solution either much harder to apply, or impossible. For example, if you have an odd number of elements, or if there are a lot of non-unique values, this starts to produce a fairly silly tree.  Considerations:  Render the element unique.  Insert a dummy element at the end if the number of nodes is odd.  Sing longingly for a more naive implementation.  Use a deque to keep the roots of completed subtrees and the midpoints in, instead of mucking around with my second trick.  1,47233 gold badges1616 silver badges2424 bronze badges  2  I think I missed something, I was in a hurry and didn't do a formal proof. Anyone see an error? I think it'd almost be easier to hack up an RB-tree implementation.  I understand displaying your thoughts clearly to the employer. However when I was in the interview I only have 25 minutes from listening to the question on the phone to typing the working solution code on the screen. So I think this much words won't be able to finish it on time.  Instead of the sorted linked list i was asked on a sorted array (doesn't matter though logically, but yes run-time varies) to create a BST of minimal height, following is the code i could get out:  This is the pseudo recursive algorithm that I will suggest.  Root = null; The inital call will be createtree(Root, list, null);  We are doing the recursive building of the tree, but without using the intermediate array. To get to the middle element every time we are advancing two pointers, one by one element, other by two elements. By the time the second pointer is at the end, the first pointer will be at the middle.  The running time will be o(nlogn). The extra space will be o(logn). Not an efficient solution for a real situation where you can have R-B tree which guarantees nlogn insertion. But good enough for interview.  Similar to @Stuart Golodetz and @Jake Kurzer the important thing is that the list is already sorted.  In @Stuart's answer, the array he presented is the backing data structure for the BST. The find operation for example would just need to perform index array calculations to traverse the tree. Growing the array and removing elements would be the trickier part, so I'd prefer a vector or other constant time lookup data structure.  @Jake's answer also uses this fact but unfortunately requires you to traverse the list to find each time to do a get(index) operation. But requires no additional memory usage.  Unless it was specifically mentioned by the interviewer that they wanted an object structure representation of the tree, I would use @Stuart's answer.  In a question like this you'd be given extra points for discussing the tradeoffs and all the options that you have.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  