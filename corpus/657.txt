 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I wrote this code of BFS in c++ using wikipedia's pseudocode. The function takes two parameters s,t. Where s is the source node and t is the target, if the target is fount, the the search return the target itself, or else it return -1. Here is my code:  I read this in wikipedia :  Breadth-first search can be used to solve many problems in graph theory, for example: Finding the shortest path between two nodes u and v (with path length measured by number > > of edges)  How do i change my function BFS to return the shortest path from s to t and return -1 if no path exists?  1,13733 gold badges1212 silver badges3131 bronze badges  4  create a variable for storing distance from starting node. everytime when you travel to a new node, update this distance variable.  as your implementation above, if putting a distance variable in, it is only the distance to current node when travelling.  @PaulDinh i did it just like you said, but when update the distance variable every time i travel to a new node, the answer is much greater than the actual answer.  3 Answers 3  Breadth-first search, by definition, visits all nodes at distance from the starting point before visiting any nodes at distance . So when you traverse the graph in breadth-first order, the first time you encounter the target node, you've gotten there by the shortest possible route.  Nathan S.' answer is correct, though I hope this answer provides some more intuition about why this works. Paul Dinh's comment is also correct; you can modify Nathan's answer to track distance instead of the actual path pretty trivially.  8,00322 gold badges2828 silver badges4242 bronze badges  4  can you please tell at exactly which point in the code should i increment the counter?  That is a tricky piece, yes! When you pop a node off the deque, you'll get the distance to that node as well. Each neighbor you then push onto the deque has its parent's distance plus 1.  So should i maintain a seperate variable for each vertex, to store the distance from its parent?  Yes, the straightforward way of implementing this needs storage proportional to the number of nodes you visit. But, some questions you should consider: 1) Are you already allocating structures that you can add this data to? 2) Do you want to remember these distances for all nodes, or free the memory after you've found your target? (That depends on your application.) 3) How could you change the algorithm to measure shortest distance using only one variable for the current depth?  When you generate a new node, keep track of the id of the parent that generated the node. Then, when you reach the goal, you just trace the parents backwards until you reach the start state. You can, for instance, mark the start as its own parent, which means that it is the start state. Or, just use a pre-defined value (-1) to say there is no parent.  So, in your code, instead of marking a state as visited, have a parent id. Parent ids can be set to -1 initially, and then updated when they are changed. The parent id can just the location in the graph structure of the parent.  For a good implementation and explanation of the BFS algorithm checkout this ( CXXGraph ) library source code.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  