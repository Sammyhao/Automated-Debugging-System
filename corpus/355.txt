 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am attempting to debug an intermittent issue I am observing via a failing integration test, but seem to be stuck between a rock and a hard place.  Something, somewhere, is creating a that is subsequently failing and resulting in an unobserved task exception. In the resultant handler, I can see the task ID and the exception that caused it to fail. I have painstakingly analyzed my code and even followed my own advice and named all my tasks but have still not found the offending task. It doesn't seem like my code is creating it at all.  So I tried setting breakpoints on the constructors themselves. I can do this with function breakpoints (with locations such as "System.Threading.Tasks.Task.Task(System.Action)"). This works and the debugger breaks and shows me the assembly for the class. However, what I really need to do is correlate the ID of the to the ID of the that ends up failing.  So to that end, I try to output the property in a trace point. But I get a message saying the method is optimized so the expression cannot be evaluated.  So I tried debugging with source. I set up all my symbols and what-have-you, but I tried absolutely everything I could, but it isn't working. After much googling I found that it isn't supported on the latest .NET 4.  Does anyone have any ideas on how I can proceed to diagnose this issue?  169k3434 gold badges384384 silver badges385385 bronze badges  5  Can you set a condition on the function breakpoints that checks your task names instead of IDs? Also maybe breaking on instead of the constructors would help to narrow down the set of possible candidates.  @shambulator: the task in question does not have a name because I haven't been able to track down where it is created in order to name it. That's the crux of the problem.  But if I understand the other comments correctly, you know which code it's running? What's preventing you from finding the sites which refer to that code (in order to construct tasks from it)?  @shambulator: that's exactly what I've done and, yes, you would think that would result in a solution and fix. But it hasn't. Hence, my dilemma. Like I said, it seems that the task isn't even being created by my code, which sounds crazy, but is the only rational explanation I have so far.  Instead of a tracepoint, what about outputting the task ID using or similar, along with anything else relevant, like the current stack? Is there a chance that a bug in your task-naming code is preventing some tasks from having the state reliably associated with them? If you're sure you've got debug output in place every time a task is created with that action, and you're still not seeing its ID come up, then there's something really weird at work.  4 Answers 4  OK, I have tracked down this problem. The specifics of the bug are perhaps less interesting than the method I used to find it, but I will cover both in separate sections below.  The Problem  Further to the implementation in my blog post, I recently added the ability to run the "then continuation", as I call it, even if the antecedent task faults:  This will result in the initial exception being ignored and "Executed" being output on the console. However, the problem is my does not observe the original exception. To that end, I changed this line:  to this:  And now I don't get the problem.  Now, you may wonder why this was at all difficult to track down. The thing is, I have a lot of task compositional methods that facilitate advanced scenarios. Here's an actual snippet to give you some idea of the resultant power:  Note the custom , , and methods. That's a good taste of what I'm talking about.  The drawback of this, of course, is tracking down problems when they occur. I can't help but feel the TPL does a poor job in this regard. To my mind, each should include information about who created it. At the very least, there should be hooks in the TPL (eg. event) so that developers can supplement tasks with their own debug information. The situation may well have improved with .NET 4.5 - I am using .NET 4.0 though.  The Method  The key to tracking down the problem was in laboriously wrapping each that I created with a that wraps any exception with a supplementary message. For example, here is a extension method that I have beforehand:  And here it is after making this change:  In this case I already have a , so it was straightforward. In other cases, I had to explicitly create a and forward any fault/cancel/result from the underlying onto the .  Aside: you may wonder at the use of the extension method. It's incredibly useful where you want to implement a single method that handles both generic and non-generic tasks. You can implement the generic version and then have your non-generic overload call in order to create a generic task, which can then be passed onto your generic overload.  Once I had gone through all the possible culprits and supplemented them as per above, I re-ran my test until it failed and noticed that it was, indeed that was creating the task that was not being observed. Therefore, I modified it to:  This would give me a full stack trace when the failure occurred. I re-ran my test until it failed, and - hooray! - got the information I needed to track down the issue:  So I could see it was one of my overloads calling . I could then trace through that exact code and the problem became evident very quickly.  This got me curious, though. Why hadn't my original approach of supplementing each task with a name produced any results? I tried reverting my fix, directly naming the task produced by , and re-running until I got a failure. Sure enough, I saw the task name in my debugger. So clearly I had somehow missed naming this task originally.  If the number of tasks is manageable, you can use the "Make Object ID" feature in Visual Studio to track each Task:  In your breakpoint in the task constructor, put the task into the Watch window.  Right mouse click on the task in the watch window and choose "Make Object ID". Notice that this puts a 1# at the end of the value. Do this for each task.  Do your workflow. In the task that throws the exception check what number it has.  16.3k77 gold badges4949 silver badges9898 bronze badges  3  Good suggestion: +1. Unfortunately, the extra time taken to perform these steps is causing the test to pass. I tried automating it with a macro, but couldn't get that to work either.  Break in the event and examine the private fields of the . You can find the one or two levels up in the call stack because the event is being raised by the class which contains a private field .  The object will contain the action that ran as part of its execution.  164k3434 gold badges230230 silver badges352352 bronze badges  3  Hi. I think you misunderstood the problem. I have access to the already. What I'm trying to do is figure out who created the . BTW, the Task is simply the sender of the UnobservedTaskException event - no need to go digging through the object hierarchy to find it.  Ok so what prevents you from finding out who created the task? Is the action field empty or inconclusive?  The action represents the body of the task. It has nothing to do with who created the task. I know where in my code the action resides, but am not able to pin down why the exception it raises isn't being handled (as far as I can tell, it is always handled with a continuation). Hence, I need to pin down who is creating the failing task so I can ensure that they are handling failures.  If possible, you could change your code that creates Tasks to use the Task Constructor that takes an object:  Then, at each location where you create the task you could pass it something unique (identifying integer, the call stack, etc.)  Then, in the UnobservedTaskException you could examine this date (stored in ).  This would help you narrow down whether it is your Task or some other Task.  16.3k77 gold badges4949 silver badges9898 bronze badges  4  Thanks, but associating state with the task is exactly what my naming approach achieves, except it's even more flexible. So given that I named all the tasks I could possibly find and still the faulting task didn't have a name...associating state in the manner you describe won't yield any different results.  Almost--but with your solution there is a race condition: The task could fail before the naming code executes (because the naming code executes after the task is already started). Also, note that your naming code is not thread safe--in its current form, it could only be used safely if your extension code is always run from the same (typically main) thread. Of course, you could easily fix this latter problem by using a ConcurrentDictionary.  actually, my code already uses . I changed that during this whole debacle, just in case it was related to the problem. Just haven't updated my blog. Also, I don't there's a race condition. Even if the task fails straight away, the UnobservedTaskFailure isn't raised until the task is finalized, which can't have happened if something is still referencing it, such as the method in which it is created (and subsequently named).  Good point (about the race condition). As long as you're not relying on the name being there until after your extension code has run, then yes it will be fine. Presumably its only for debug purposes (i.e. you wouldn't look for the name within the Task execution itself). Glad to hear you tracked down the problem.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  