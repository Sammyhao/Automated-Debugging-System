 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I was wondering about a quick to write implementation of a graph in c++. I need the data structure to be easy to manipulate and use graph algorithms(such as BFS,DFS, Kruskal, Dijkstra...). I need this implementation for an algorithms Olympiad, so the easier to write the data structure the better.  Can you suggest such DS(main structs or classes and what will be in them). I know that an Adjacency list and Adjacency matrix are the main possibilities, but I mean a more detailed code sample.  For example I thought about this DS last time I had to implement a graph for DFS:  and then used a array of size n containing in its i'th place the Edge List(struct Edge) representing the edges starting in the i'th node.  but when trying to DFS on this graph I had to write a 50 line code with about 10 while loops.  @The GIG: because the structure of the implementation would probably be quite different, since C and C++ have different abstractions and idioms.  So you need something efficient? In what respect and for what use case? The adjacency matrix is very efficient if e.g. you are processing complete graphs...  8 Answers 8  Below is a implementation of Graph Data Structure in C++ as Adjacency List.  I have used STL vector for representation of vertices and STL pair for denoting edge and destination vertex.  It really depends on what algorithms you need to implement, there is no silver bullet (and that's shouldn't be a surprise... the general rule about programming is that there's no general rule ;-) ).  I often end up representing directed multigraphs using node/edge structures with pointers... more specifically:  In other words each node has a doubly-linked list of incoming links and a doubly-linked list of outgoing links. Each link knows and nodes and is at the same time in two different doubly-linked lists: the list of all links coming out from the same node and the list of all links arriving at the same node.  The pointers and are used when following the chain of all the links coming out from the same node; the pointers and are instead used when managing the chain of all the links pointing to the same node.  It's a lot of pointer twiddling (so unless you love pointers just forget about this) but query and update operations are efficient; for example adding a node or a link is O(1), removing a link is O(1) and removing a node x is O(deg(x)).  Of course depending on the problem, payload size, graph size, graph density this approach can be way overkilling or too much demanding for memory (in addition to payload you've 4 pointers per node and 6 pointers per link).  A similar structure full implementation can be found here.  107k1515 gold badges150150 silver badges256256 bronze badges  3  Can you explain prev_same_from, next_same_fron, prev_same_to, and next_same_to? I don't understand what they do from your description.  @BradyDean: I've added some more detail and a picture describing the structure. Filled dots are NULL pointers, dots are pointers with red color for the doubly linked list of all incoming links and blue color for the doubly linked list of all outgoing links.  Wow thank you. I drew my own picture too and realized each link essentially knows what directions it can travel in  This question is ancient but for some reason I can't seem to get it out of my mind.  While all of the solutions do provide an implementation of graphs, they are also all very verbose. They are simply not elegant.  Instead of inventing your own graph class all you really need is a way to tell that one point is connected to another -- for that, and work perfectly fine. Simply, define a graph as a map between nodes and lists of edges. If you don't need extra data on the edge, a list of end nodes will do just fine.  Thus a succinct graph in C++, could be implemented like so:  Or, if you need additional data,  Now your graph structure will plug nicely into the rest of the language and you don't have to remember any new clunky interface -- the old clunky interface will do just fine.  No benchmarks, but I have a feeling this will also outperform the other suggestions here.  NB: the s are not indices -- they are identifiers.  How about a vector instead of the ? Simply use the index as NodeID. It will yield O(1) lookup.  Because the s are not indices, but indentifiers. If you are certain that the graph contains a contigous set of identifiers, a vector would do fine (and the performance benefits would probably be much better than the O(log(n)) -> O(1) change suggests). Also, note that can be negative, so if you want to use a , you would have to deal with that -- using any unsigned type would suffice.  Of these two the adjacency matrix is the simplest, as long as you don't mind having a (possibly huge) array, where is the number of vertices. Depending on the base type of the array, you can even store edge weights for use in e.g. shortest path discovery algorithms.  There can be an even simpler representation assuming that one has to only test graph algorithms not use them(graph) else where. This can be as a map from vertices to their adjacency lists as shown below :-  Here is a basic implementation of a graph. Note: I use vertex which is chained to next vertex. And each vertex has a list pointing to adjacent nodes.  With the above code, you can expand to do DFS/BFS etc.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  