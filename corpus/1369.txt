 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Recently I was reading about Article on Interviewing an Software Engineering Position by Joel and he mentioned about asking candidate about Recursion and Pointer's after some simple puzzles.  I wonder why Pointers and Recursion are considered to be complicated Issues ?  Update: What can be done to improve on Pointers and Recursion Skills, if I may say so ?  Pointers are complicated. Recursion isn't. It's just one of those things you either get intuitively, or bang your head into a desk for hours trying to learn and still don't entirely understand.  8 Answers 8  Someone once said to me, and I agree - pointers are a simple concept but difficult to code, recursion is a difficult concept but easy to code.  Pointers can be tricky to code, because it might not be obvious where the problem is, or that there even is a problem - issues caused by pointers might not show up in the first or second or even one hundredth run, but then suddenly bam, you've got an issue. Debugging them can be very difficult as well.  Recursion is simple to code - just have the function call itself, and do something to keep track of where you are. The difficulty is in making sure you have a good enough understanding of all the possible paths your function could take, and making sure that it can always get itself out of a loop.  1,89111 gold badge1212 silver badges1111 bronze badges  1  1  Excellent summary! Also I should note that pointers lead to 'hard' crashes (core dumps), whereas a value error usually lead to a wrong result... and for some reasons people tend to prefer softer errors (which is against the fail fast mindset).  They require keeping details about several layers of data. Several layers are more complicated than one layer.  A pointer is more compicated than a value variable. It is a variable by itself but it is used to hold an address of another variable. You need to have a grasp on the difference between the pointer value and the value of that other variable.  Recursion is more complicated than plain code with loops since you need to have a grasp on why and how the current call has been made, what other calls will be made, what will be the effect when the current call returns and how all this solves the problem at hand. That's complication. Add indirect recusrion to this (when calls , calls and calls again) and gets really interesting.  162k9090 gold badges490490 silver badges928928 bronze badges  5  1  -1 Recursion only becomes complicated because you think in the way you describe. If you think more declaratively (how can I build my result from the result of a smaller problem) then writing a recursive function is often easier than writing loops.  starblue, that is part of the experience. At first, everybody thinks of recursion or <fill in technique> as a complex thing, but once one gets used to it, it becomes weird to see other struggle with it.  Huh. The whole point of recursion is that it doesn't matter what is going on in the other parts of the call stack.  It doesn't matter to the current call, but it does matter to the whole problem being solved.  @starblue: thinking declaratively is a good way to reason about recursion and often leads to easy understanding where it can be applied. However, not all recursive algorithms are derived declaratively, so you can invent really evil recursive algorithms. For example, I remember seeing a recursive function that reversed a singly-linked list in place, with no temporary storage and only one pass over the data. In that case you're using the call stack as a data store, and even declarative reasoning about the problem is very hard.  Recursion is simple enough to be used in LOGO - a programming language similar to LISP designed to be easily used by young children. It's a fairly intuitive concept for many basic uses.  Pointers on the other hand, seem complicated to many programmers -- especially those that have never touched assembler. Especially confusing is the fact that C (and C++) basically treat arrays and pointers nearly interchangeably even though they are often represented by different data types.  For example, an array of pointers to 1D-arrays is dereferenced exactly the same in source code as a two-dimensional array even though they have completely different memory layouts and generate considerably different machine code when the dereferences occur.  I’ve come to realize that understanding pointers in C is not a skill, it’s an aptitude. In first year computer science classes, there are always about 200 kids at the beginning of the semester, all of whom wrote complex adventure games in BASIC for their PCs when they were 4 years old. They are having a good ol’ time learning C or Pascal in college, until one day they professor introduces pointers, and suddenly, they don’t get it. They just don’t understand anything any more. 90% of the class goes off and becomes Political Science majors, then they tell their friends that there weren’t enough good looking members of the appropriate sex in their CompSci classes, that’s why they switched. For some reason most people seem to be born without the part of the brain that understands pointers. Pointers require a complex form of doubly-indirected thinking that some people just can’t do, and it’s pretty crucial to good programming. A lot of the “script jocks” who started programming by copying JavaScript snippets into their web pages and went on to learn Perl never learned about pointers, and they can never quite produce code of the quality you need.  That’s the source of all these famous interview questions you hear about, like “reversing a linked list” or “detect loops in a tree structure.”  Understanding of pointers requires a conceptual understanding of the memory architecture of your computer system: each address in numbered memory is a slot where you can put data, and some of the slots contain numbers of other slots. That's non-trivial. More importantly, it's not required for simple programs. Having that conceptual understanding and being able to solve problems with it shows in my opinion a desire to figure out what's really going on in a computer.  Further, to be fluent with pointers you need practice. Think of C puzzlers like: 'from the declaration below, describe the type of a in words'  What's required to answer that question quickly and with ease, or any other that deals with many levels of indirection? You need to have spent time to think deeply about what pointers are at the programming language level.  It's a similar story with recursion. To simply walk through a recursive function you've got to understand the call stack and how arguments are passed and returned. To master recursive functions you've got to be able to decompose a problem into smaller parts and solve each one piece by piece.  Fluency with recursion and pointers requires concepts that are the foundations for writing hard code. I believe the dedication required to master those concepts is a crucial ingredient in a good programmer. What's more, it's not too hard to show holes in someone's knowledge of concepts with a 10 minute programming test on a topic that requires them. Sound like great interview questions to me.  I would say because a lot of students don't grasp programming fundamentals strongly enough before trying out pointers and recursion so they get confused too early.  Also, students like to influence other students into thinking a concept is harder than it actually is.  I was fortunate enough to learn pascal and C as my first programming language, so pointers and recursion was natural and didn't feel complicated.  They are simple concepts, but they're easy to screw up.  That makes pointers and recursion a very suitable topic for programming puzzles and interview questions.  They're really not THAT complicated. The reason that they're used in interview tests is because good programmers can quickly explian them, and bad programmers can quickly trip over them. Therefore, they can predict whether candidate programmers have troubles with programming in general.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  