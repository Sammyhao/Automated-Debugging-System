 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Could you reformat you code so it is readable and specify the language you are talking about in the tags? It would help you get an answer much quicker.  1 Answer 1  I'm going to take a wild guess and say that the signature looks like this:  This creates a new multimap (a copy) each time you call it.  When comparing iterators, both of the iterators must come from the same container; since you're getting a new copy each time you call , you violate this constraint, and this is the source of your error. You also have another problem - the temporary multimap copies are destroyed after the statement they're created in, so your iterators are invalidated instantly.  You have two choices; one is to capture a copy locally and use that copy consistently:  Another is to have return a reference to a persistent multimap, ensuring the same one is used each time:  Or a const reference:  This has the advantage of avoiding the (potentially large) overhead of copying the .  Note that using a const reference requires using s to step through the multimap. I would recommend defining both const and non-const accessors (C++ will pick the right one based on if the pointer or reference is const), unless you want to disallow direct modification of the underlying entirely, in which case you can define only the variant.  211k2929 gold badges255255 silver badges320320 bronze badges  1  This is the solution my problem. Returned a std::multimap by a member as a non reference  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  