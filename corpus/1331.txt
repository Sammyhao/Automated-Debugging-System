 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  We have a java application that processes different types of financial transactions. These transactions have different flows and for system flexibility(esp user) we introduced an xml that we use to define the transaction flow for each. The steps are executed asynchronously The xml looks like this  Synopsis Each step contains a step script, expected result of the step script, error correction scripts incase the step script fails and also intercepting scripts called hooks which perform some work before executing the step script or error script.  A enum called State  }  A state node that contains all the attributes :  A state tree that stores all steps being executed (Statenode) of a transaction in flight within the system  final class StateTree implements Serializable {  }  How it currently works When a new transaction is requested there's a module known as the transaction processing engine that uses the xml and this structure to process the transaction. So what happens is we create a new state tree for every transaction that comes into the system and persist it to a database then for every step, error or hook being executed we create a new state node and save it into the state tree. I hope this is clear enough.  Actual Execution To determine which state to execute and at what step I have a recursive method called resolve execution . I hope it is intuitive to the reader:  Question I have a working solution already but I feel it's not the best. Now that we are doing performance tests I have detected that the processing is slow and I believe it can be better. What data structure would you recommend to map this xml and/or a design pattern ? I hope this is doesn't feel like an open ended question. Thank you  For StateNode definitely Builder pattern would be much better instead of so many parametrized constructors  2 Answers 2  If I understand correctly you have data driven flow , by which I mean you have some data (in this case in form of xml's and scripts) that dictates what actions will be taken (so it's not known at compile time, but you use a pseudo language to describe this flow).  My usual approach is to make a queue of commands and populate it all at once , then execute it , rather then executing command , load next script, execute command. This however involves to make your own pseudo-language compiler so to speak :).  If your xmls are somewhat trivial you can get away with it easily.  For your xml example , the queue of command would result in  1 - 2 - 3  Because you have no branching (it seems to me that you just go through them regardless)  You will have to preload some scripts (for extra optimization) :  Now you can decide at a global level what scripts will be cached and which won't.  4,61311 gold badge2020 silver badges2828 bronze badges  3  There's branching involved when you execute a hook, because it's similar to step but has more attributes and other functionality. Would you still suggest the same now that there's branching ?  Yes , you can do the same even with branching, it just that your command queue gets more complicated (you will basically either have jumps or store the command queue in a tree). The command queue is useful to use cached instructions so you don't reload commonly used scripts and also to know up front what scrpits you need to load (so it's 1 load time, then execute vs multiple little loads ). It depends however how deep your hierarchy goes, it might end up counter productive if your tree uses ALLOT of branches (you end up keeping all scripts in memory).  You can implement a class containing all the attributes and store all your steps in a LinkedHashSet:  And then make a LinkedHashSet of Steps and they will be linked one to an other in the order you inserted them:  Take a look at these examples for further information:  29.6k77 gold badges5151 silver badges7070 bronze badges  1  thank you but I already have this place, the linkedhashset though is a good idea , performs better than the linkedlist.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  