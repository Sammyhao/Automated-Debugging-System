 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm learning polymorphism in C++ and I can't downcast a pointer to a pointer. I have a class Base and a class Derived that extends Base. And I want to do a pool of Derived objects using a function . I tried doing but the compiler says that it can't convert from Derived** to Base**. So I tried the next:  And it compiles. But then when I want to access all Derived objects the main.cc throws a . It executes hello(cout) but then it throws before ending the first iteration of the loop.  If you want a "pool of derived", that means an array of derived, so a single pointer, thus you should return a not a . Using raw pointers like that is considered bad practice because you might forget to free the resources with . Also is creating a temp and copying it over to . Use instead.  @Offtkp: "Derived derived = Derived(); is creating a temp Derived and copying it over to derived." That's not true.  1 Answer 1  There are multiple fundamental problems with the shown code.  This creates an array of objects. This kind of an array in C++ is represented by a pointer to the first value in array. In this case this would be a , which is what you get from .  It is valid in C++ to downcast a pointer to a derived class into a pointer to a base class.  But that's it. That's all you get.  That doesn't mean that a pointer to the first derived object in an array can be downcasted to a pointer to a base class, and then the pointer to the base class be used to access every derived object in the actual array. Pointers don't work this way in C++. Attempting to access any other object besides the first object, that the pointer points to, is undefined behavior. This is the first fundamental problem with the shown code.  is an object that's declared as a local object in this function. When this function returns, gets destroyed, like any other variable declared in this function. It will be destroyed. It will be no more. It will cease to exist. It will pine for the fjords. It will become an ex-object.  The shown code attempts to take an address of this object and return it from this function. After the function returns this pointer becomes a pointer to a destroyed object, and any attempt to access it will be undefined behavior.  Doing this correctly requires a completely different approach. Instead of using to create an array of derived objects, this should be done by using to create an array of pointers to the base object. Then, each pointer gets initialized, individually, by ing an individual derived object, something like:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  