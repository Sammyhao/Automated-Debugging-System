 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am having a problem with a heap corruption issue in a program. In the program I am reading a block of data and performing FFT and IFFT on it. I am doing it for 2 images, master and slave. The EXACT same code works fine for the master but shows a heap corruption for the slave file when I try to delete the slave buffer.  The error does not occur if I do not call the fft and ifft functions for the slave image. (Everything works fine for the master though)  To debug the error I installed Application verifier but I was not able to decode the log file. Its here: http://sharetext.org/Y2ji (XML file copy pasted)  The error visual studio give is: Heap corruption Detected: after normal block (#194456) at 0x062C0040  What is baffleing me is that the code is pretty simple and it works 100% for only the master files. Why is it crashing for the slave?  Can some one guide me to a solution or maybe a tutorial on how to use the Application verifier as well?  Well, del_float is not quite correct. It is deleting the array alright, but it is not setting the pointer back to NULL, like it seems. That's because it is operating on a copy of the pointer. But the pointer is not used after, so I don't think that's the ultimate cause.  3 Answers 3  The mem_float() function is not correct. It looks like it is setting the pointer to NULL after the delete, but it is only working on a copy of the pointer, so the caller's copy is still pointing to deleted memory block.  You can just do  You have a couple of lines that look like this:  I think this is accessing memory before the beginning of the array.  Beyond this, the indexing inside is insanely complicated - you will have to step through it with the debugger to check the edge cases.  I will look into its behavior. This function however works perfectly well the first call, for the master file though. And thank you so much for your continued help.  I am look to see what changes I can do to that function. I do not see the problem though: The function initializes cf for 2*n values [say 32]. "i" will go till 30, so the index 31 will be valid. The constraint on n is that it must be a power of 2, so the code will be valid IMO. edit: Sorry ! did not see your update  Sorry! I typed that as you posted the edit! Il look into the new issue. F11'ing :)  Changing that too four1(cf,nn,isign) gives a new heap error. But I think this solution is correct, and at-least points me in the right direction. I may not be able to debug the fft code just yet. Can I work around it in some way?  Firstly it's important to understand what the heap corruption error is telling you. When you run a Debug build in Visual Studio it uses the Debug version of the run-time library which has a debug heap. Whenever you allocate some memory with there are some extra guard bytes either side of it. When you it the debug heap checks that those guard bytes are intact, and if not then it issues this warning.  Assuming that allocates memory on the heap then the two calls to it will most likely allocate memory one after the other:  You perform the operation on but then you get the heap corruption error when deleting . This suggests that is overwriting memory before the start of so that it's corrupting the guard bytes of .  So I would look through your code for for places where you might have negative array indexes as this could cause the memory in to be stomped on.  Also check some of the SO answers with useful tips on how to make the most of the debug heap, in particular this one about how to enable more intensive memory checks.  28.1k55 gold badges6161 silver badges9090 bronze badges  2  Thanks for the informative post. I am trying to debug this via the links you have provided and suggestions from others on this page  "Heap corruption Detected: after normal block (#194456) at 0x062C0040" says that you allocated a block, got the block #194456 with address 0x062C0040 and you wrote more memory bytes than you allocated. So you have a classical buffer overflow. You should consider replacing pointers with STL containers. In your case I'ld prefer using over a raw float array allocated with . The STL containers can help you detect writing beyond boundaries immediately at the wrong access, not only after deleting the memory block.  15.6k1212 gold badges4242 silver badges6565 bronze badges  2  I personally would have liked to, since im not very comfortable with pointers / raw arrays, but all the old code uses that structure, inclusive of functions that i need to call like fft etc. Maybe I can try allocating a bigger block - or my allocation size is wrong, because code runs flawlessly for master.  If i replace slave_bfr = Pcoarse.init_1Dcmplx(SIZEs_cols) with slave_bfr = Pcoarse.init_1Dcmplx(SIZEs_cols+1) it does not give me any errors. But I have a 30mb chunk left after the delete statement.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  