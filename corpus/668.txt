 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am having trouble implementing a non-binary tree, where the root node can have an arbitrary amount of child nodes. Basically, I would like some ideas on how where to go with this, since I do have some code written, yet I'm stuck at this point on what to do next. BTW I cannot use any of the Collections classes at all. I can only use System.  1,25766 gold badges2020 silver badges3535 bronze badges  8  Its supposed to be practice to prepare for a another project. Can I use a linked list of nodes?  The I can only use constraint needs an explanation. Also, what operations are needed? Insert, Remove at arbitrary positions?  Remove is not needed, the only thing it should be able to do is to Insert at arbitrary positions.  Hint: A binary tree has two references to other tree nodes called Left and Right. An arbitrary tree has two references to other tree nodes called FirstChild and NextSibling. Aribitrary trees are binary trees; you just assign different meanings to the nodes.  6 Answers 6  So far Jerska's solution is the best but it is needlessly complicated.  Since I assume this is a homework exercise let me give you the direction you should head in. The data structure you want is:  Let's now redraw your diagram -- vertical lines are "first child", horizontal lines are "next sibling"  Make sense?  Now, can you write code that produces this tree using this data structure? Start from the rightmost leaves and work your way towards the root:  Notice that an arbitrary tree is just a binary tree "rotated 45 degrees", where the root never has a "right" child. Binary trees and arbitrary trees are the same thing; you just assign different meanings to the two children.  624k172172 gold badges12031203 silver badges20472047 bronze badges  12  It looks like I will consider this approach. Since there seems to be countless ways to represent an arbitrary tree, I believe that a more straightforward look at it makes sense. Thanks for the help! Just one question, to write out all the nodes in the tree, should I add all the Nodes in a linked list or is it not necessary?  @KarimOumghar: That's unnecessary; you can easily write a recursive traversal of this tree, the same way you can write a recursive traversal of a binary tree.  I've been looking for a similar solution, and this is really neat, I'll definitely use it. I have one concern though: in your implementation, you add nodes from the bottom-up, and I don't think your method allows adding a new node, because the TreeNodes have a private set, so you can't modify an existing node from outside of the class to accommodate a new child or sibling. How would you suggest adding a new node using this implementation?  @leoking you can make the tree mutable or you can rewrite the spine to produce a new tree on insert. That works better with a normal binary tree than with one of these arbitrary trees, but it is pretty straightforward.  By making the tree mutable, would that just mean changing the access for the fields? Also, what do you mean by the spine in this context?  Since you can't use a collection, why don't you create your own list ?  And use it like this :  You'll now have :  Then you will need to implement different functions (getters, removers, etc.). But that's your job.  If you can't use any Collections, store link in all child elements to parent. You can model your graph by using next data structure:  You can now have as many childs for each node, as you like:  @Jerska do you need it? Is that an explicit requirement? Why haven't you mentioned Breadth-First search?  I'm not the author of the post, I was wondering if that would be possible. And however, I actually have the same wonder with a Breadth-First Search.  @Jerska You simply can't. You still have to store links to all child elements and handling this kind of tree is very cubersome. But still, I find requirement "and hey, I can't use any of that collection stuff" very unreasonable.  You can represent a multiway tree using a node type that has just a next pointer and a child pointer.  The node's pointer is used to point to the next sibling child, implemented as a simple linked list.  The node's pointer is used to point to the first child of the node.  Here's some sample code which demonstrates how to put this together. It does not contain any error handling and it isn't intended to be a complete solution, but you should be able to compile it and - if necessary - run it under the debugger to fully understand how it works.  I also added an example enumerable to show how you could iterate over the tree nodes. You will probably want to play around with this to produce results in different orders. IF using an enumerable is too complex for what you need, you will need to write your own simple recusive method to visit all the nodes.  Note that the node type is generic in this example, and I'm only using it to hold string data. You could just substitute with the type you want if you don't want a generic type.  (I know this is similar to Eric's answer above, and if I'd read that answer before writing this one I probably wouldn't have bothered - but I'd already written this and I didn't want to just throw it away.)  A node will need some sort of list of the child nodes, consider using a concurrency-proof implementation, most likely will fit the bill  You might or might not want a backpointer to the parent - conisder one for speedy (read: not too lame) traversal  I recommend you create a to make life easier when consuming the tree  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  