 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have noticed on multiple questions, C++ experts asking that std::string/std::map/etc. should not be created with the 'new' keyword (newbie to C++, if it wasn't obvious).  So, if my understanding is correct this would not create it on the heap but on the stack. This would mean that the moment the function goes out of scope, the object would disappear, but I believe that is not the case and my understanding is wrong.  Is this because the underlying template instantiates it on the heap and manages it using an auto_ptr, so that it doesn't cause a memory leak? Does this apply for all stl classes?  Also, a follow up question is what should be the approach to create objects that are inserted in maps? Should they be allocated on the heap (if they are valuable out of the scope of the function)?  EDIT:  I do understand the difference between heap and stack and the reasons for using each (I probably was not clear about this).  The reason I ask for this is it seems unnatural, to just instantiate an object on the stack for an object I'd like to keep around. But, I guess this is just how the syntax looks like.  This means, I feel like I'm having something on the stack when I write,  instead of,  I'm also wondering about the impact of this on the memory. Since now the memory is cleaned up by this implementation itself, is it analogous to garbage collection in Java? Is there an implied performance impact when using an stl object?  2,30633 gold badges2525 silver badges4040 bronze badges  5  Things you put in are copied in. I don't know what you're getting at with , though. I doubt any implementation uses that in any containers' implementations. The nice thing about creating something on the stack is that you don't have to manage its memory, since it's freed when the object goes out of scope. It's a lot more exception safe as well.  "the moment the function goes out of scope, the object would disappear" When this is your concern, you shouldn't create on the heap in the first place.  Perhaps a specific code example with expected problems or flow would help us to see exactly what part one of us might be on different terms with.  You only need to use when you need the object to persist after your method has returned. It's not specific to string or map or anything, it's a general rule.  If you have the chance, take a look at Effective C++ by Scott Meyers. There's a chapter there on using smart pointers to prevent memory leaks. It talks specifically about the 'RAII' idiom that one of the posters below has mentioned. A simple example would be using to initialise something and midway through processing it, something throws an exception causing program control to never reach the precious statement that would have de-allocated the memory correctly. There's your memory leak :) With smart pointers there's no need to worry about that.  2 Answers 2  This isn't particular to or . It's simply a general rule about almost all objects in C++.  To automate resource management, you usually want to tie each resource to some scope that encompasses the time that resource will be needed. Assuming you do that consistently, each resource gets cleaned up automatically when execution leaves the scope in which it was defined.  This is most commonly referred to as "RAII" (Resource Acquisition is Initialization), though some use the more descriptive term SBRM (Scope bound resource management). Regardless of the terminology you use, with appropriate (and consistent) use, it can work extremely well.  The reason for the "RAII" term is that this means most resources are acquired during object construction, and released during object destruction. This tends to lead to a fairly specific style of coding, where (among other things) objects are quite granular, as each manages the lifetime of one specific resource.  When you say automating resource mgmt. isn't this a performance hit? I ask this because I feel it must be like garbage collection in Java.  @dev_nut: It's just the normal destruction of variables as you leave a scope. The time is usually pretty inconsequential unless you're cleaning up a lot of resources. It's not like GC where a fair amount of time is spent just figuring out what variables are still in use though.  @dev_nut: No -- items in the map are destroyed when/if you remove them. The map itself is destroyed when it goes out of scope (if it's a local variable, such as in some function) or when you explicitly destroy it (if you allocated it dynamically). As far as existing a long time goes, that's normally just a matter of finding the right function. In the extreme case, it lives the entire life of the program, so it might be defined at the beginning of .  One of the common reasons for putting something on the heap is that the size isn't known at compile time, and you need the flexibility of allocating some unknown number of objects. The internal implementations of and and the other containers will automatically allocate from the heap as necessary, relieving you of that burden. Putting the object itself on the heap becomes redundant.  The only reason to put a container on the heap is when you need its lifetime to be longer than the block that creates it.  280k4040 gold badges367367 silver badges597597 bronze badges  2  1  +1. Especially for "The only reason to put a container on the heap is when you need its lifetime to be longer than the block that creates it." - another one of these "never/always" rules bites the dust. And quite rightly so.  And even if the lifetime is longer than the block that creates it, with NRVO, you often don't need to put containers on the heap, since return by value will avoid all overhead (constructing directly into space provided by caller, usually on their own stack frame).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  