 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  1,70122 gold badges2323 silver badges3131 bronze badges  3  4  @ZouZou I googled for this and found this question on the first place. Google isn't enough, content is also needed :-)  Can u pls attach the code for the iterator. The above code will certainly give u a concurrent modification Exception. You are iterating through the keyset as well as modifying the map at the same time. This is a recipe for disaster.  5 Answers 5  for-each loop also internally create a iterator of the of . While iterating over map you have modified the structure of the map by putting the value again to the map () which cause this .  The iterators returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.  How to solve this -  you must change the change the structure of this map while iterating, you can insert this values later, like keep a temporary map and add this to the main map once iteration is finished his job.  Iterate over a copy and you can add/remove just fine:  It's not even any more lines of code, because the copy ims made in-line via the copy constructor. was chosen to preserve iteration order (if that matters).  A sample code snippet for removing an element from the map is given below.  If your code involves a lot of addition and removal , you might just want to use ConcurrentHashMap.ConcurrentHashMap  is not boolean and on top of this when the iterator has no more elements, it.next() won't be null, but instead will throw . So, use  You will have to create a copy of your map using copy constructor. Now iterate on 1 and modify second map. I am assuming that you will not need to iterate newly added value as it wont make much sense.  You can achieve your task by creating a copy is because the keys will remain same in both.  EDIT:  I dont think its a good idea to iterate the newly added element to a Hashmap. If you check the api's provided by Iterator then you will find only remove method, there is no add method in it. There is a reason behind this and you can check javadoc for this. Now coming to the point, on how to iterate newly added element.  Create a copy of your . So you will iterate one and modify the the other .  As the requirement is to both add and remove elements in , i would like to use for this [this is different from normal ].  I will get the of Map1 and convert it to a list using .  Now i will get from created in step 3, and add, remove elements in as well as in Map2 [Remeber you need to add , remove both in and Map2].  7,66066 gold badges4141 silver badges7272 bronze badges  2  no I need to iterate over this new values the new added values will be greater than the current one so I need to iterate over them too  An easy solution is to use another temporary map where you put the values you want and finally switch pointers with the original one (i.e Map = newMap )  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  