 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  While working on a Java project, I came across code that looked like this:  The intention here is clearly to do something for each key in the map, according to the keys' natural order, and this does seem to be what happens in practice. However, I'm not sure if this behavior is guaranteed. The Javadoc for Stream#forEach says:  The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses.  I know that if the code were using instead of that it wouldn't be guaranteed to work, but since it is using a sequential stream (which the Javadoc doesn't say anything about), I'm not sure. Is this guaranteed to always work, or would that code need to be using instead of for it to be?  EDIT: I believe that this question is not a duplicate of forEach vs forEachOrdered in Java 8 Stream, because that question is asking "what's an example of a difference between forEach and forEachOrdered in general", and the accepted answer is basically "parallel streams". This question is specifically about sequential streams.  39.1k44 gold badges3939 silver badges8484 bronze badges  2  streams API is the functional programming interface of Java. In functional programming the basic idea is that elements do not have any relationship to each other. Even order does not matter. Order may only matter for display but not for any processing of individual elements as you do with .  In fact it would be a nice optimization if using - and thus an unordered pipeline - optimized away the sorting.  3 Answers 3  It's not guaranteed that the terminal operation will process elements in the encounter order hence the "is explicitly nondeterministic". Although under the current implementation it should process the elements of a sequential stream in the encounter order of the stream.  is primarily for cases where you're using a parallel stream and want to respect the encounter order of the stream if the stream has a defined encounter order.  Using or on a sequential stream will have the same effect so it's a matter of preference.  As mentioned above, under the current implementation we know that the terminal operation should process the elements of a sequential stream in the encounter order of the stream but since it's not stated in the java doc it's better to sit on the fence and use if you really care about the iteration order.  51.6k88 gold badges7373 silver badges113113 bronze badges  2  4  It currently provides that behaviour, and I would expect that it always will, but as it's not guaranteed in the contract I wouldn't rely on it. I agree with this answer. If you care about the iteration order, use the method which says you care about the iteration order. There's literally no reason not to, besides saving yourself 7 characters.  @Michael that's actually a good point and will add some content to my answer for If you care about the iteration order, use the method which says you care about the iteration order.  Under the current implementation it is - but the documentation is pretty clear not to specify this as a rule. This obviously can change, but at the moment it does not, even when doing:  Even if you are breaking the order on purpose, for sequential streams, data is not shuffled on purpose internally - at least not at the moment.  You have to be careful though, not to rely on it as things can change between versions, here is one example  Is this guaranteed to always work, or would that code need to be using .forEachOrdered() instead of .forEach() for it to be?  No. It is not guaranteed to always work. As the javadoc says, the method may not be deterministic. This means that the implementors have the license to change a case that is currently deterministic to behave differently.  If you want guaranteed determinism, use the method where the javadoc explicitly guarantees it. It is highly unlikely that that the explicit guarantee of order preservation in would ever deliberately be broken in a future release.  So ... I would point out that mistake to the maintainers of that application. We cannot predict that it will break in the future, but it certainly could. Latent bugs are bugs.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  