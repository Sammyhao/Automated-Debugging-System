 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Edges can be classified according to three categories (back edge, tree/forward edge, cross edge) using a recursive DFS that labels nodes as unvisited, discovered or finished (or white, grey, black).  Can we also classify edges using the iterative version of the algorithm (cf. Depth-First Search )?  This version only uses two categories, unvisited, and discovered. We could mark the node as finished after all neighboring nodes have been pushed to the stack but it wouldn't give the expected result.  EDIT (Clarification): The question is, can we modify the iterative version of DFS given above in order to classify edges as tree/forward edge, cross edge and back edge, just like it's commonly done with the recursive version by taking advantage of the node label/color?  To my understanding, the definition of the categories is as follows, taken from here: forward edges point from a node of the tree to one of its descendants, back edges point from a node to one of its ancestors, and cross edges do neither  3 Answers 3  Suppose you work in the recursive version. Then it could be modified as follows:  Using the idea of bracketing, it is well known that:  An edge is a tree edge if it leads to a vertex that is undiscovered.  An edge is a backwards edge if it leads to a vertex that is discovered and not finished  An edge is a cross or forward edge otherwise.  So now the only problem is to make it iterative. The only difference is that we now need to manipulate things the recursion did for us before. Say each vertex has set to 0, and set to . The iterative version could look as follows:  69.6k1010 gold badges126126 silver badges163163 bronze badges  2  I'm not sure I understand. How can you mark the vertex before it's popped? But even if you marked it as finished just after popping, it wouldn't be correct as you need first to process the sub-tree starting from that vertex before making it as finished. You can do that in the recursive version, but I don't see how to do it in the iterative version.  @nemo That's a good point. It's not too hard to fix it, but I'm not in front of a computer right now. Will revise later.  My solution to this is to simulate the recursion using a stack and a "current child" pointer.  When we peek at a node from the standard DFS stack, we will check whether the current child pointer is pointing at the end of the adjacency list for this node. If it is, we are done with this node. If not, we will push this child node (if eligible) onto the DFS stack without updating the current child pointer. This will allow us to perform post processing on this child later.  As an example, consider 10199 - Tourist Guide from UVa Judge. It basically asks us to find articulation points, which crucially depend on edge classification.  This will get the and times for the DFS. The edges can be classified according to the rules posted here using these times. You can do this on the fly as well, although the rules are a bit different. For instance, during the search if we encounter edge (u,v), and is set but is not yet set then (u,v) is a backward edge.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  