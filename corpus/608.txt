 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am trying to implement a Fibonacci Heap and I'm required to keep track of its nodes for subsequent operations. For the uninitiated, Fibonacci heap can be thought of as an m-degree tree or a collection of trees with a pointer to the maximum node in the structure. The tree structure takes a word and its frequency as an input and is required to give most frequently occurring words as the output. For example, Input:  My understanding of a hash table is very rudimentary. I input the word as the key and it gives out a hash value as output. How do I force this output to be a pointer to the corresponding node in the tree which stores its frequency? Also, given an input to find 'n' frequently occurring words, can I repeatedly remove the top node 'n' times and reinsert it back into the structure? Or am I better off keeping a sorted hash table?  1 Answer 1  As someone who's coded one of these up before, there are a few different ways that you can do what you're trying to do.  Have the insert function return a pointer to the node inside the structure, then use some auxiliary hash table to store those pointers. To do an insertion, you would insert the key and its priority, get handed back a pointer to the node in the Fibonacci heap, then add the key and the pointer to an external hash table (in Java, something like ; in C++, something like ; I'd advise against rolling your own).  Use an intrusive data structure by having each key to store in the Fibonacci heap actually be the complete node structure. The implementation of the Fibonacci heap would then overwrite the relevant fields of the input to wire it into the heap structure, and provided that you stored the nodes in some reasonable fashion you could just look them up as needed.  I personally think that option (1) is cleaner than option (2) for most applications, but there are reasons to prefer (2) over (1).  On a meta note, Fibonacci heaps are notoriously hard to code up and in practice dramatically slower than binary heaps even though they're asymptotically faster in a number of use cases. I'd advise against actually using one unless you had a compelling reason to do so.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  