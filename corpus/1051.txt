 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I've wanted to create a radix sort implementation using queues.  I couldn't figure out which part of my code has problems or which resources should I read. My code may be totally wrong but this is my implementation without any help (I haven't taken a data structures & algorithms course yet).  I created a function but it didn't work. While doing research, I saw some code samples but they seemed to be more complex for me.  Firstly I wanted to find the least significant digit of all integers Then sort them in queue element whose subscript matches, then after sort copy all queues to end of 11th queue element. Do this sort in 11th queue element again until reach most significant digit.  I could find least significant digit. And sort according to this digit. But, I couldn't analyse other digits. For instance; I could sort 1, 2 , 4, 5, 3 but when time comes to sort 2 or more digits, it fails...  I hope, I was clear and explained my problem briefly.  Edit 1 ( Made some progress )  I followed suggestions from William Morris. I had to ask same question on CodeReview and he gave me some instructions to make my code clearer.  I divided my function into functions and also stopped using recursion.  Firstly, I created a add_to_q function which adds value to related queue and it helped to get rid of code duplication. By the way James Khoury's way is simplest one but it again uses recursion.  Secondly I created other helper functions. One is add_to_eleventh which simply adds all queue elements to the eleventh queue's rear. In my opinion, it is doing what question wants.  Thirdly, my last helper function is back_to_ints. Its purpose is take the elements in 11th queue and divide them by ten and return them in a integer array.  Finally my new sorting function which is now sorts the integers in same digit. Such that, numbers[7] = {112,133,122,334,345,447,346};  I solved the question partially. If you want to sort the numbers in same digit, it works. Otherwise, it fails. For instance, your inputs are 112,133,122,334,345,447,346 then the result will be 112 122 133 334 345 346 447. But, if the user wants to sort something like that(111,13,12,334,345,447,1) it gives 111 1 12 13 334 345 447. So, how can I overcome this problem.  26511 gold badge77 silver badges1717 bronze badges  10  Why do you want to use a queue for radix sorting? Also, is/should it be a priority queue or a normal queue?  @anatolyg It is a book question and it wants to solve this question with a queue. I have no idea for your second question. Maybe normal queue...  @mustafaSarialp I've edited your question to attempt to make it clearer. Please let me know if there is any loss of meaning.  @DougCurrie: For future reference. No this does not belong on code review. The code review site is for working code to make it better. Stackoverflow is for getting answers to question when the code does not work.  4 Answers 4  I've modified your queue a bit. To better understand the code, I use front and rear as global variables.  So the operation of adding to queue becomes  And add an operation of deleting from a queue(return the data as well)  So now we can implement the radix sort. It may be easier to move your data into queue with the actual numbers rather than a single digit. Note that the 11th queue is not needed if you can modify your test array *arr, and your radix_sort function could be like this:  And finally you can test by calling radix_sort(your_array, your_array_size), the full code is  Yeh, the page provide an example just below the definition. All digits are always sorted. So for example, 170 and 75 are sorted by 100s place and becomes 75 < 170 since 075 < 170.  thats for Most Significant Digit sort. The OP was asking for a Least Significant Digit Sort.  Some good information here already. At a higher level it will be difficult to debug your code because it's more complex than it needs to be. Below is a different code that uses C to express the algorithm in a more idiomatic style.  The overall point is that when it comes to code, less is usually more: Simplicity is your friend. Features shown here:  Circular singly linked lists for queues. A queue is a pointer to the tail node of the list. With this, append and concatenate are fast constant-time operations.  Logical, reusable functional decomposition.  Only about 80 SLOC including a simple test. The sort function is 18 SLOC.  43.7k44 gold badges5353 silver badges9090 bronze badges  2  +1 While I like this code I feel obligated to comment that less lines of code is not always better.  Of course you're right. It's really about simplicity as Einstein said: as simple as possible but no simpler. In programming, simple data structures, simple algorithms, simple idioms are easiest to maintain and often fastest. Simpler generally but not always means shorter, which is why I said "usually."  Disclaimer: I haven't implemented a radix sort before or tested the code below. I'll leave that to you as an exercise.  When you find yourself copy-pasting something more than once stop and think: there must be a pattern.  Your switch statement is a lot of copy-pasting. In you have a line:  I'm guessing it should be:  If you had re-factored this code you may have been able to see this easier?  What about replacing the whole switch statement with:  The problem that I have seen in the first code sample is that  curNum = curNodep->element.key  curNum have always the full number and the switch statement always do curNum % 10, and this only test de last digit.  In your recursion solution (recursion is not a problem) you have to pass a parameter to know which is the digit that it have to deal.  I know this technique as immersion.  If you see the samples that you put at the end of the answer you can see that the last digit is orderer, you can change the input samples to see better this. Add big numbers with a small last number, example '901', an see the result.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  