 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I need to know how to "reset" LinkedList iterator to its first element.  For example:  Over and over again and after many moves of the iterator I need to "reset" the position of iterator. `  I want to ask how I can "reset" my iterator to first element  I know that I can get list iterator of the first element in this way:  Is this the best solution? or maybe I missed something in Oracle docs?  well you've missed something, if you need to do more than next and maybe previous, iterator is not the best choice. Why do you need to reset?  I trying to understand the idea of dynamic list in java. A few weeks ago I have a problem with session variable on jsp oage. From EL and taglibs I can use a method of iterator but I cant redefine it (I still have poor knowledge about jsp but I still improving it :)) What do You mind when You wrote "iterator is not the best choice" ? Could You explain it to me? :)  7 Answers 7  You can call method again to get an instance of iterator pointing at beginning of list:  696k5959 gold badges498498 silver badges570570 bronze badges  1  3  awesome. it's not immediately obvious that this call doesn't just return the same reference to the iterator that you're already using. But I guess looking into the source would've solved that answer as well. Here's a link for anyone curious as this is a habit I'm trying to be better about: grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/…  Best would be not using at all, usually it is slower in all disciplines, and less handy. (When mainly inserting/deleting to the front, especially for big arrays LinkedList is faster)  Use , and iterate with  Reset is trivial, just loop again. If you insist on using an iterator, then you have to use a new iterator:  (I saw only once in my life an advantage of LinkedList: i could loop through whith a while loop and remove the first element)  Even removing items from the middle is faster in case of LinkedList. That is if you are iterating through and removing items with iterator.remove(). ArrayList would necessitate shifting of the remaining items.  @Sohaib, yes mainly it depends on the size of the list. Up to a specific number of elements System.arraycopy, which internal uses C - memcopy , which is used to shift the array is faster. Advanced implementation switch the underlying implementation depoending on element size.  This is an alternative solution, but one could argue it doesn't add enough value to make it worth it:  Calling hasNext() will reset the iterator cursor to the beginning if it's a the end.  That sounds like a quirk you discovered rather than something guaranteed by the interface.  If the order doesn't matter, we can re-iterate backward with the same iterator using the and methods:  Initially the iterator sits at the beginning, we do forward iteration:  Then the iterator sits at the end, we can do backward iteration:  13.2k44 gold badges5353 silver badges6161 bronze badges  1  Hmm @ryenus...I like your idea to iterate backwards from the last element using hasPrevious() and previous() after the 'forward' iteration has occurred. That seems like a perfect solution if you need to use the same iterator instance (not sure why you'd actually need need to use the same instance over and over though). I am curious if looping back to the start of the iteration is less expensive than creating a new iterator instance, but I guess that would also be somewhat dependent on the size of the list.  What you may actually want to use is an that can return a fresh multiple times by calling .  You must define what the method does just once beforehand:  Code  What you can do is, set the iterator to the first position mannualy with a while loop.  when you get out of the loop you will have your iterator at the position 0  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  