 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I've seen quite a few posts (viz. post1, post2, post3) on this topic but none of the posts provides an algorithm to back up respective queries. Consequently I'm not sure to accept the answers to those posts.  Here I present a BFS based shortest-path (single source) algorithm that works for non-negative weighted graph. Can anyone help me understand why BFS (in light of below BFS based algorithm) are not used for such problems (involving weighted graph)!  The Algorithm:  Runtime: As far as I see it is O(|V| + |E|) including the initialization cost  If this algorithm resembles any existing one, pls let me know  4 Answers 4  Since the pseudocode is Dijksta's algorithm with FIFO queue instead of priority queue that is always sorted based on the distances. The crucial invariant that each visited (black) vertex has computed shortest distance possible so far will not be necessarily true. And that is the reason why priority queue is a must for computation of distance in (positively) weighted graphs.  You can use your algorithm for unweighted graphs or make it unweighed by replacing each edge with weight with vertexes connected by edges with weight 1.  Counterexample:  State of the computation after first :  State of the computation after first iteration:  Important for this graph to be a counterexample is that and not , hence is queued first by  State of the computation after second iteration:  Since vertex is dequeued first by (unlike when distance priority queue is used), this iteration will not update any distance, will become black and the invariant will be violated.  State of the computation after the final iteration:  Pls elaborate on 'that is the reason why BFS are not used for..' - didn't get what reason you're talking about!!  If you use queue instead of priority queue, the algorithm will be faster and will have lower complexity. However, for some weighed graphs will not compute shortest distance. The priority queue enables Dijkstra's algorithm to select the next vertex so as to ensure shortest distance is computed for every visited (black) vertex. If FIFO queue is used instead, it will not be able to deal with arbitrary edge weights. You can find the counterexample on even small weighted graph with a circle.  I've tested with cycles and self-loop's. I'm unable to understand what 'arbitrary' edge-weight means. Would you pls provide a counterexample!  Awesome!! I realized the shortcoming. Before marking a node black, we must ensure it is reached by one of the shortest paths; and this cannot be done unless we take some greedy steps (which is priority queue in Dijkstra’s). In your counterexample, we’re marking ‘F’ black without reaching to it by any shortest path. Very nicely put. Thanks a lot!!  @TomášKratochvíla It's not true. you can compute shortest distance with normal queue. and it's SPFA. only downside is SPFA has worse complexity.  I used to have same confusion. Check out SPFA algorithm. When the author published this algorithm back in 1994, he claimed it has a better performance than Dijkstra with O(E) complexity, which is wrong.  You can treat this algorithm as an variation/improve of Bellman-Ford. Worst case complexity is still O(VE), since one node may be add/remove from the queue multiple times. But for random sparse graph, it definitely outperforms original Bellman-Ford since it skip lots of unnecessary relaxing steps.  Although this name "SPFA" seems not well accepted in academia, upon published it became very popular among ACM students due to its simplicity and ease to implement. Performance wise Dijkstra is preferred.  It looks like you implemented Dijkstra's classical algorithm, without a heap. You are going through the matrix through each edge and then seeing if you can improve the distance.  71711 gold badge66 silver badges1515 bronze badges  2  Yes, I indeed dropped a min-heap and found that run time is better than Dijkstra's (though I did it independently without learning Dijkstra’s algo.). Further on run-time, Wiki says, with adjacency list representation of G, it is Theta((|E| + |V|) log |V|) as opposed to wee better O(|E| + |V| ) for mine. I also don’t get why BFS algo. are virtually unheard of for weighted graphs.  Normally people say it's BFS when there is no edge weight.  BFS: graph with constant edge weight.  Dijkstra: graph with edge weights (can handle some negative edges if it doens't have negative cycle)  Bellman-ford and SPFA: graph with negative cycle.  Your code is Dijkastra or SPFA variant and not a simple BFS (although it IS based on BFS based alrorithm)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  