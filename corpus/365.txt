 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Extracted from here we got a minimal iterative dfs routine, i call it minimal because you can hardly simplify the code further:  Here's my question, how could you transform this routine into a topological sort method where the routine also becomes "minimal"? I've watched this video and the idea is quite clever so I was wondering if it'd be possible to apply the same trick into the above code so the final result of topological_sort also becomes "minimal".  Not asking for a version of topological sorting which is not a tiny modification of the above routine, i've already seen few of them. The question is not "how do i implement topological sorting in python" but instead, finding the smallest possible set of tweaks of the above code to become a .  ADDITIONAL COMMENTS  In the original article the author says :  A while ago, I read a graph implementation by Guido van Rossen that was deceptively simple. Now, I insist on a pure python minimal system with the least complexity. The idea is to be able to explore the algorithm. Later, you can refine and optimize the code but you will probably want to do this in a compiled language.  The goal of this question is not optimizing but instead coming up with a minimal version of topological_sort derived from it (just for the sake of learning more about graph theory algorithms). In fact, i guess a more general question could be something like given the set of minimal algorithms, {, , , }, what would be their topological_sort derivations? Although that would make the question more long/complex, so figuring out the topological_sort out of iterative_dfs is good enough.  9,53777 gold badges4242 silver badges9696 bronze badges  10  @TomKarzes Understand now your meaning, that makes total sense, good idea! Do you think it'd be too "expensive" to preprocess the graph converting the deps list to a set before traversal so you don't need to keep both structures in the graph. Let's say the type of graphs the app would be handling could be the cartesian product of something like {graph_many_nodes}x{all_nodes_have_many_deps, few_nodes_many_deps} so it's worth optimizing. Anyway, the question is more about minimal code (simpler as possible), so whether the solution it's fast or not would be irrelevant in this case.  @user3012759 You mean keep it as a local variable instead of being a parameter? Take a look to the original article i've put in the thread, if you think about it, the reason why the author has chosen having as a parameter is so the interface in both iterative and recursive versions can be the same, if you have it as a local var you'll fail this point.  @BPL - in this case it does work as intended but only because another technicality. the line with assigns new list to local var path and returns that, but if someone in the future went in and changed that to say which does 'the same thing' you will suddenly get that keeps the values between calls - generally you don't want to put mutables as default args in python  @ShihabShahriar I understand why you're asking... To be honest I've struggled quite a lot deciding which answer to accept, both of them were really suitable to me. The reason why I've accepted Blckknght were mainly because the number of upvotes, it was the first one to be published, it can be more useful to the general public because it provides really good insights. On the other hand, if we strictly stick to the question i've formulated I think your answer is more suitable one... so... I dunno, maybe I was wrong picking up one Both answers are really nice but I needed to choose one....  5 Answers 5  It's not easy to turn an iterative implementation of DFS into Topological sort, since the change that needs to be done is more natural with a recursive implementation. But you can still do it, it just requires that you implement your own stack.  First off, here's a slightly improved version of your code (it's much more efficient and not much more complicated):  Here's how I'd modify that code to do a topological sort:  The part I commented with "new stuff here" is the part that figures out the order as you move up the stack. It checks if the new node that's been found is a child of the previous node (which is on the top of the stack). If not, it pops the top of the stack and adds the value to . While we're doing the DFS, will be in reverse topological order, starting from the last values. We reverse it at the end of the function, and concatenate it with the remaining values on the stack (which conveniently are already in the correct order).  Because this code needs to check a bunch of times, it will be much more efficient if the values in the dictionary are sets, rather than lists. A graph usually doesn't care about the order its edges are saved in, so making such a change shouldn't cause problems with most other algorithms, though code that produces or updates the graph might need fixing. If you ever intend to extend your graph code to support weighted graphs, you'll probably end up changing the lists to dictionaries mapping from node to weight anyway, and that would work just as well for this code (dictionary lookups are just like set lookups). Alternatively, we could build the sets we need ourselves, if can't be modified directly.  For reference, here's a recursive version of DFS, and a modification of it to do a topological sort. The modification needed is very small indeed:  That's it! One line gets removed and a similar one gets added at a different location. If you care about performance, you should probably do in the second helper function too, and do in the top level function. But using is a more minimal change.  Its also worth noting that if you want a topological order of the whole graph, you shouldn't need to specify a starting node. Indeed, there may not be a single node that lets you traverse the entire graph, so you may need to do several traversals to get to everything. An easy way to make that happen in the iterative topological sort is to initialize to (a list of all the graph's keys) instead of a list with only a single starting node. For the recursive version, replace the call to with a loop that calls the helper function on every node in the graph if it's not yet in .  @Saurabh Yes, that's true. The variable in the original question's code is also a stack, albeit a much less efficient one since it pushes and pops from the start, rather than the end where lists have efficient operations. That's what makes the DFS a DFS. A regular (LIFO) queue would give a breadth-first traversal instead. That FIFO queue is not what is notable about the code we're discussing though. The stack named in the topological sorting code replaces the call stack of the recursive version.  Don't pop the next item from stack, keep it to emulate stack unwinding.  Instead of pushing all children to stack, just push one.  Both of these help us to traverse the graph exactly like recursive dfs. As the other answer here noted, this is important for this particular problem. The rest should be easy.  here is our stack. In the main loop, we 'access' our current node from the stack. 'access', not 'pop', because we need to be able to come back to this node again. We find out all unvisited children of our current node. and push only the first one to stack (), not all of them together. Again, this is precisely what we do with recursive dfs.  If no eligible child is found (), we have visited the entire subtree under it. So it's ready to be pushed into . And this is when we really pop it.  (Goes without saying, it's not great performance-wise. Instead of generating all unvisited children in variable, we should just generate the first one, generator style, maybe using filter. We should also reverse that and call a on at the end. But these things are omitted for OP's insistence on simplicity.)  @StevenPenny, I disagree. "topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering." wiki link  in given example, my solution outputs: , which I think is the desired ordering, and is the ordering of the accepted solution too.  I'm pretty new to this, but shouldn't topological sort based on DFS work no matter where in the graph you start? The current solutions (as of this writing) only traverse the entire graph for particular starting points in the example graph. (Although I haven't completely thought it through, it seems the problem occurs when hitting a vertex that has no neighbors to visit. If the algorithm hits such a node before traversing all the other vertices in the graph, then the results are truncated.)  Although it is not as simple as the OP would probably like, the following is an iterative topological sort using DFS that works regardless of the order of vertices explored.  I was also trying to simplify this so I came up with this:  Function (Depth First Search) is used to create the stack of finishing times for every vertex in the graph. Finishing time here means that the element pushed into the stack first, is the first vertex where all of its neighbours are fully explored (no other unvisited neighbours are available to explore from that vertex) and the last element pushed into the stack is the last vertex where all of its neighbours are fully explored.  The stack is now simply the topological sort.  Using a Python set for provides constant membership checking and using as a stack provides constant-time left insertion as well.  The high-level idea was inspired by CLRS [1].  [1] Cormen, Thomas H., et al. Introduction to algorithms. MIT Press, 2009.  We need to implement the graph, which you have done using "parent to children":  but you also provide a parameter. In the context of a topological sort, if you provide , then all is well:  but what if you provide ? All the implementations on this page currently return this:  which is not correct, as would need to be done before . To solve this, we can instead map "child to parents" [1][2]. Then instead of choosing a we can choose an :  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  