 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Created a program to test multi-threaded and single-threaded Heap implementation in C++. The program builds and processes it's heaps based upon a global data structure consisting of a STL vector 2^8 STL vectors of 2^20 unsigned integers comprised of somewhat random numbers.  The primary data structure initializes correctly and my program is currently split into two testing phases, one of which calls the function to perform the algorithm in a sequential manner, dumping the results into a global array which is same size as there are sub-vectors in the above data structure(2^8) and where each element in this array designates the result for the sub-vector at that same index in the main vector of vectors.  The second phase does the exact same, but in parallel, using multiple pThreads to process groups of sub-vectors in parallel from the main vector. The second phases dumps it's results in a separate array from the first which the two result arrays are used for comparison and correction-checking purposes.  So the main data structure, the vectors of vectors is only read from by both phases of the program. Each phases writes to a different global array but at indexes that designate different elements in that array.  The algorithm builds a heap out of each sub-vector and does a series of update-key operations on the elements in that sub-vector in a sequential manner until it has exhausted all elements in the sub-vector. The first phase performs this by processing each sub-vector in a sequential manner, the second does this by processing groups of sub-vectors in parallel.  The problem is, when I execute the program on the Windows machine under Cygwin64, the program executes correctly. No errors, correct results, everything works completely fine. Even testing with smaller datasets shown that the algorithm was being executed correctly.  The Problem  Below is the Cygwin64 execution of the program.  Everything works fine, even if I reduce the number of POSIX threads by input, or change the size of the data structure, it works fine. If I reduce the size of the data structure enough that I can check the results(for example, 256 sub-vectors of 256 elements), I can see that the results that the algorithm is returning is correct. So the algorithm should be performing correctly.  If I execute the same program on any Linux machine:  It doesn't even make it pass the point, where I am just sequentially performing the algorithm. But if I reduce the number of sub-vectors to 1.  If increase the number of sub-vectors to any size greater than 1, the segmentation fault returns. So I used gdb to try and see if I could determine where the segmentation fault is occurring.  So the program is failing on the malloc call in the function Heap_Build. This is function which essentially performs the algorithm by building the heap, performing the sequence of update-key operations on the heap from the sub-vectors. The first phase of the program calls this function in sequential manner, the second phase, allows each pThread to call the function to process their groups of sub-vectors.  There doesn't seem to be anything suspicious in this code, k is the size of the heap, k+usage_offset is the size of the array representing the heap. The return value is simply the root of the heap. The malloc'd array structure of unsigned integers which acts as the heap is free'd after use.  I'm really not sure why the above code would execute properly on Cygwin64, giving the correct results and everything, and not on any Linux machine.  Ordinary programmers almost never find bugs in basic OS functions. It is almost certainly a wayward pointer in your code that corrupts the state of the program. The bug is elsewhere, even if it finally crashes inside . Show us some of your code instead, especially a minimal but complete sample that demonstrates the problem.  1 Answer 1  Crash in malloc is a sign of memory corruption. Use valgrind and co (mcheck, electric fence, tcmalloc, etc), often it helps.  And if you want people to fix your program for the sport of it, then post the complete source code (or even better, a minimal test case which still shows the problem) somewhere (github, for example).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  