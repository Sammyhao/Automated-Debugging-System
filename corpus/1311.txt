 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  takes in arguments ; is an array, and hence a pointer to its first element. But if we make a declaration like  and pass as first argument to , then the program doesn't work, but it should, because , a string, is a pointer to its first character.  Also, if we write  and pass it as second argument it doesn't work; this was my first problem.  Now also the output is 8, but it should be 4, as has been tokenized. Why does this happen?  You should really learn how to format you code and text in a question (See the editing help on the "ask question" page, and use less "..." in you text). Also, it's not very clear what exactly you are asking.  5 Answers 5  strtok takes in arguments (char*, const char*)....name is an array and hence a pointer to its first element...  is an array, and it's not a pointer to its first element. An array decays in a pointer to its first argument in several contexts, but in principle it's a completely different thing. You notice this e.g. when you apply the operator on a pointer and on an array: on an array you get the array size (i.e. the cumulative size of its elements), on a pointer you get the size of a pointer (which is fixed).  but if we made a declaration like string name="avinash" and passed name as argument then the prog doesnt work but it should because name of string is a pointer to its first character...  If you make a declaration like  you're are saying a completely different thing; here is not a C-string (i.e. a ), but the C++ type, which is a class that manages a dynamic string; those two things are completely different.  If you want to obtain a constant C-string () from a you have to use it's method. Still, you can't use the pointer obtained in this way with , since returns a pointer to a C-string, i.e. it cannot be modified. Notice that is not intended to work with C++ strings, since it's part of the legacy C library.  also if we write const string n = "n"; and pass it as second argument it doesnt work...this was my first problem...  This doesn't work for the exact same motivation, but in this case you can simply use the method, since the second argument of is a .  now also the sizeof(name) output is 8 but it should be 4 as avinash has been tokenised..  returns the "static" size of its operand (i.e. how much memory is allocated for it), it knows nothing about the content of . To get the length of a C-string you have to use the function; for C++ just use its method.  58.8k6262 gold badges232232 silver badges398398 bronze badges  1  If is a C-string, the syntax used by the OP () is already ok. If, instead, is an , you are potentially violating the preconditions of , since nothing guarantees you that it's internal buffer is NULL-terminated (and actually it could even contain a NULL before the end of the string, since s can contain any character).  First of all, is C and not C++ and is not made to work with C++ strings. Plus, it cant work if you dont use the return result of the function.  You should consider to use , and other stuff from the STL library instead of C functions.  is C++, for the same reason that most of the C library is C++. Still, was already broken in C, and shouldn't have been used there, much less in C++. And C++ has a lot of more powerful tools to achieve the same ends: both the member functions of and the algorithms in the standard library.  C functions are usable in C++. For me, it does not mean that they are C++. I think a lot of people will agree that C++ is not exactly an extension of C. This is an old debate ^^  As you said, takes arguments of type and . A is not a so passing it as the first argument will not compile. For the second argument, you can convert a string to a using the member function.  What problem are you trying to solve? If you're just trying to learn how works, it would be much better to stick to raw character arrays. That function is inherited from C and thus wasn't designed with C++ strings in mind.  I don't believe the actual size of the name array is ever changed when you call strtok. The call remembers the last location it was called if you pass it a null pointer, and it continues to tokenize the string. The return value of the strtok call is the token that has been found in the string provided. Your code is calling sizeof(name) which is never actually adjusted by the strtok function.  Try this maybe? I am not in front of a compiler so its likely I made a mistake, but it should get you on the right track to solve this problem.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  