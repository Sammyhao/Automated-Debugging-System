 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have this Python application that gets stuck from time to time and I can't find out where.  Is there any way to signal Python interpreter to show you the exact code that's running?  29 Answers 29  I have module I use for situations like this - where a process will be running for a long time but gets stuck sometimes for unknown and irreproducible reasons. Its a bit hacky, and only works on unix (requires signals):  To use, just call the listen() function at some point when your program starts up (You could even stick it in site.py to have all python programs use it), and let it run. At any point, send the process a SIGUSR1 signal, using kill, or in python:  This will cause the program to break to a python console at the point it is currently at, showing you the stack trace, and letting you manipulate the variables. Use control-d (EOF) to continue running (though note that you will probably interrupt any I/O etc at the point you signal, so it isn't fully non-intrusive.  I've another script that does the same thing, except it communicates with the running process through a pipe (to allow for debugging backgrounded processes etc). Its a bit large to post here, but I've added it as a python cookbook recipe.  111k2828 gold badges105105 silver badges109109 bronze badges  14  1  Thanks! This is just what I was looking for. Maybe you could also post that script with pipe support on some Python snippets site?  Great tip! This also works to send the signal, to all processes containing the word "mypythonapp": pkill -SIGUSR1 -f mypythonapp  If the application is stuck, the Python interpreter loop may not be able to run to process the signal. Use the module (and its backport found on PyPI) for a C level signal handler that'll print the Python stack without requiring the interpreter loop to be responsive.  The suggestion to install a signal handler is a good one, and I use it a lot. For example, bzr by default installs a SIGQUIT handler that invokes to immediately drop you into a pdb prompt. (See the bzrlib.breakin module's source for the exact details.) With pdb you can not only get the current stack trace (with the command) but also inspect variables, etc.  However, sometimes I need to debug a process that I didn't have the foresight to install the signal handler in. On linux, you can attach gdb to the process and get a python stack trace with some gdb macros. Put http://svn.python.org/projects/python/trunk/Misc/gdbinit in , then:  Attach gdb:  Get the python stack trace:  It's not totally reliable unfortunately, but it works most of the time.  Finally, attaching can often give you a good idea what a process is doing.  2,95011 gold badge1717 silver badges88 bronze badges  5  2  Brilliant! The pystack command locks up sometimes, but before it does it gives me a complete stack trace of the process, in python code lines, without having needed to do any preparation.  Minor update: this gdb technique (and updated code) is documented at wiki.python.org/moin/DebuggingWithGdb There's been some development on this front, documented at that URL, and apparently gdb 7 has some Python support.  As far as I can tell, this only really works if you have debug symbols compiled into your python binary - eg: you ran your program with python2-dbg (on Ubuntu, this is in a separate package ). Without those symbols, you don't seem to get much useful info.  I am almost always dealing with multiple threads and main thread is generally not doing much, so what is most interesting is to dump all the stacks (which is more like the Java's dump). Here is an implementation based on this blog:  Getting a stack trace of an unprepared python program, running in a stock python without debugging symbols can be done with pyrasite. Worked like a charm for me in on Ubuntu Trusty:  (Hat tip to @Albert, whose answer contained a pointer to this, among other tools.)  gives you a list of predefined python scripts you can use, and is one of them. If you are using your own (for instance to write stack trace to a file) it might be wise to use a different name.  Important tip: run (or equivalent) before running pyrasite, otherwise it will silently fail. Works like a charm otherwise!  (disclaimer: my package) I have a fork pyrasite-ng which fixes various reported bugs.  You can also nicely format the stack trace, see the docs.  Edit: To simulate Java's behavior, as suggested by @Douglas Leeder, add this:  to the startup code in your application. Then you can print the stack by sending to the running Python process.  77.3k2020 gold badges8989 silver badges9696 bronze badges  2  2  This would only print the backtrace of main thread. I am yet to find a solution for seeing traces for all threads. In fact, python seems to lack an API to retrieve stack from Thread object, though threading.enumerate() gives access to all Thread objects.  This works great on cygwin. It only prints three lines of the stack trace though, but that's enough to get a clue  +1 to @gulgi for his easy to use answer. Some of the other answers looked very complicated for my simple task of getting call-stack trace from a script's function.  at the beginning of your program. Then send SIGUSR1 to your process (ex: ) to display the Python traceback of all threads to the standard output. Read the documentation for more options (ex: log into a file) and other ways to display the traceback.  What really helped me here is spiv's tip (which I would vote up and comment on if I had the reputation points) for getting a stack trace out of an unprepared Python process. Except it didn't work until I modified the gdbinit script. So:  edit it, changing to [edit: no longer needed; the linked file already has this change as of 2010-01-14]  2,56422 gold badges2222 silver badges2323 bronze badges  3  The gdbinit at the mentioned URL already seems to have the patch you suggest. In my case, when I typed pystack my CPU just hung. Not sure why.  Nope, it doesn't — I was unclear, sorry, because that line appears in three places. The patch I linked to shows which one I had changed when I saw this work.  Like @spiv's answer, this requires the program to run under python compiled with debugging symbols. Otherwise you'll just get  That will make the interpreter to run in debug mode and to give you a trace of what the interpreter is doing.  If you want to interactively debug the code you should run it like this:  python -m pdb yourscript.py  That tells the python interpreter to run your script with the module "pdb" which is the python debugger, if you run it like that the interpreter will be executed in interactive mode, much like GDB  9,18966 gold badges3737 silver badges5757 bronze badges  1  This does not answer the question. The question was about an already running process.  I would add this as a comment to haridsv's response, but I lack the reputation to do so:  Some of us are still stuck on a version of Python older than 2.6 (required for Thread.ident), so I got the code working in Python 2.5 (though without the thread name being displayed) as such:  Take a look at the module, new in Python 3.3. A backport for use in Python 2 is available on PyPI.  105k100100 gold badges341341 silver badges505505 bronze badges  1  2  A more recent answer by @haypo covers this in more detail. I'm not sure how this is usually handled on SO, but it feels wrong to have two essentially duplicate answers...  On Solaris, you can use pstack(1) No changes to the python code are necessary. eg.  It seems to only give the backtrace under linux, not the Python traceback with filename and line numbers.  It can be done with excellent py-spy. It's a sampling profiler for Python programs, so its job is to attach to a Python processes and sample their call stacks. Hence, is all you need to do to dump call stacks of all threads in the process. Typically it needs escalated privileges (to read the target process' memory).  Here's an example of how it looks like for a threaded Python application.  19.2k33 gold badges8484 silver badges9292 bronze badges  1  This works, but from @kmaork's answer produces a Python traceback, which is a lot more useful for figuring out where the problem is.  If you're on a Linux system, use the awesomeness of with Python debug extensions (can be in or package). It also helps with multithreaded applications, GUI applications and C modules.  Run your program with:  This instructs to prepare and un it.  Now when you program hangs, switch into console, press Ctr+C and execute:  I was looking for a while for a solution to debug my threads and I found it here thanks to haridsv. I use slightly simplified version employing the traceback.print_stack():  I hacked together some tool which attaches into a running Python process and injects some code to get a Python shell.  60.1k5858 gold badges219219 silver badges357357 bronze badges  1  2  Note: it's not obvious how to build this. Thanks for the links you've put in README though: worked perfectly!  It's worth looking at Pydb, "an expanded version of the Python debugger loosely based on the gdb command set". It includes signal managers which can take care of starting the debugger when a specified signal is sent.  A 2006 Summer of Code project looked at adding remote-debugging features to pydb in a module called mpdb.  pyringe is a debugger that can interact with running python processes, print stack traces, variables, etc. without any a priori setup.  While I've often used the signal handler solution in the past, it can still often be difficult to reproduce the issue in certain environments.  Apparently it's incompatible with certain gdb builds (e.g. the one I had installed on ubuntu): github.com/google/pyringe/issues/16 , requiring rebuilding manually. Another debugger, , worked like a charm for me.  If you want to peek at a running Python application to see the "live" call stack in a top-like fashon you can use austin-tui (https://github.com/p403n1x87/austin-tui). You can install it from PyPI with e.g.  Note that it requires the austin binary to work (https://github.com/p403n1x87/austin), but then you can attach to a running Python process with  You can use PuDB, a Python debugger with a curses interface to do this. Just add  to your code and use Ctrl-C when you want to break. You can continue with and break again multiple times if you miss it and want to try again.  78.5k2424 gold badges159159 silver badges224224 bronze badges  1  When you use the above command in django, don't forget to run a server properly to prevent glitches: "manage.py runserver --noreload --nothreading"  This would print a stack trace into the program's stdout.  Alternatively, if you don't want to print anything to stdout, or you don't have access to it (a daemon for example), you could use the madbg package, which is a python debugger that allows you to attach to a running python program and debug it in your current terminal. It is similar to and , but newer, doesn't require gdb, and uses for the debugger (which means colors and autocomplete).  To see the stack trace of a running program, you could run:  5,25422 gold badges2020 silver badges3838 bronze badges  2  FTW! (It doesn't work without sudo, despite both processes being owned by the same user.)  I don't know of anything similar to java's response to SIGQUIT, so you might have to build it in to your application. Maybe you could make a server in another thread that can get a stacktrace on response to a message of some kind?  There is no way to hook into a running python process and get reasonable results. What I do if processes lock up is hooking strace in and trying to figure out what exactly is happening.  Unfortunately often strace is the observer that "fixes" race conditions so that the output is useless there too.  30.8k1212 gold badges6464 silver badges6969 bronze badges  4  1  Yeah, this is true. It is a shame though thad pdb does not support attaching to a running process...  This is not true. See the answer by "spiv" above, which shows how to connect gdb and get a Python stack trace.  It's not the same -- those gdb macros aren't reliable and don't provide the full power/familiar interface of pdb. I often wish someone wrote a small app that would use ptrace to inject some Python bytecode into a running Python process and have it execute 'import pdb; pdb.set_trace()', maybe also after temporarily redirecting sys.stdin/stdout.  import inspect help(inspect.stack) Help on function stack in module inspect:  stack(context=1) Return a list of records for the stack above the caller's frame.  In Python 3, pdb will automatically install a signal handler the first time you use c(ont(inue)) in the debugger. Pressing Control-C afterwards will drop you right back in there. In Python 2, here's a one-liner which should work even in relatively old versions (tested in 2.7 but I checked Python source back to 2.4 and it looked okay):  pdb is worth learning if you spend any amount of time debugging Python. The interface is a bit obtuse but should be familiar to anyone who has used similar tools, such as gdb.  In case you need to do this with uWSGI, it has Python Tracebacker built-in and it's just matter of enabling it in the configuration (number is attached to the name for each worker):  Once you have done this, you can print backtrace simply by connecting to the socket:  At the point where the code is run, you can insert this small snippet to see a nicely formatted printed stack trace. It assumes that you have a folder called at your project's root directory.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  