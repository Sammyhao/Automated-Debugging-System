 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Just wondering if I can get some tips on printing a pretty binary tree in the form of:  Right now what it prints is:  I know that my example is upside down from what I'm currently printing, which it doesn't matter if I print from the root down as it currently prints. Any tips are very appreciated towards my full question:  How do I modify my prints to make the tree look like a tree?  16 Answers 16  In order to pretty-print a tree recursively, you need to pass two arguments to your printing function:  The tree node to be printed, and  The indentation level  For example, you can do this:  The initial call should be  If you would like to print the tree with the root at the top, move to the top of the .  Your example shows you calling a function but the function you've declared is ? What is the initial value of indent?  It's never going to be pretty enough, unless one does some backtracking to re-calibrate the display output. But one can emit pretty enough binary trees efficiently using heuristics: Given the height of a tree, one can guess what the expected width and setw of nodes at different depths. There are a few pieces needed to do this, so let's start with the higher level functions first to provide context.  The pretty print function:  The above code is easy. The main logic is in the printRow function. Let's delve into that.  getLine() does what you'd expect: it stores all nodes with a given equal depth into vec. Here's the code for that:  Now back to printRow(). For each line, we set the stream width based on how deep we are in the binary tree. This formatting will be nice because, typically, the deeper you go, the more width is needed. I say typically because in degenerate trees, this wouldn't look as pretty. As long as the tree is roughly balanced and smallish (< 20 items), it should turn out fine. A placeholder is needed to align the '/' and '\' characters properly. So when a row is obtained via getLine(), we insert the placeholder if there isn't any node present at the specified depth. The placeholder can be set to anything like for example. Obviously, this isn't robust because the placeholder could be a valid node value. If a coder's got spunk and is only dealing with decimals, one could modify the code to emit decimal-converted strings via getLine() and use a placeholder like "_". (Unfortunately, I'm not such a coder :P)  The result for the following items inserted in order: 8, 12, 4, 2, 5, 15 is  getHeight() is left to the reader as an exercise. :) One could even get prettier results by retroactively updating the setw of shallow nodes based on the number of items in deeper nodes. That too is left to the reader as an exercise.  If your only need is to visualize your tree, a better method would be to output it into a dot format and draw it with grapviz.  You can look at dot guide for more information abt syntax etc  Here's a little example for printing out an array based heap in tree form. It would need a little adjusting to the algorithm for bigger numbers. I just made a grid on paper and figured out what space index each node would be to look nice, then noticed there was a pattern to how many spaces each node needed based on its parent's number of spaces and the level of recursion as well as how tall the tree is. This solution goes a bit beyond just printing in level order and satisfies the "beauty" requirement.  It's probably worth mentioning that is available with or a similar standard version flag. It is not available with or .  Foreword  Late late answer and its in Java, but I'd like to add mine to the record because I found out how to do this relatively easily and the way I did it is more important. The trick is to recognize that what you really want is for none of your sub-trees to be printed directly under your root/subroot nodes (in the same column). Why you might ask? Because it Guarentees that there are no spacing problems, no overlap, no possibility of the left subtree and right subtree ever colliding, even with superlong numbers. It auto adjusts to the size of your node data. The basic idea is to have the left subtree be printed totally to the left of your root and your right subtree is printed totally to the right of your root.  An anaology of how I though about this problem  A good way to think about it is with Umbrellas, Imagine first that you are outside with a large umbrella, you represent the root and your Umbrella and everything under it is the whole tree. think of your left subtree as a short man (shorter than you anyway) with a smaller umbrella who is on your left under your large umbrella. Your right subtree is represented by a similar man with a similarly smaller umbrella on your right side. Imagine that if the umbrellas of the short men ever touch, they get angry and hit each other (bad overlap). You are the root and the men beside you are your subtrees. You must be exactly in the middle of their umbrellas (subtrees) to break up the two men and ensure they never bump umbrellas. The trick is to then imagine this recursively, where each of the two men each have their own two smaller people under their umbrella (children nodes) with ever smaller umbrellas (sub-subtrees and so-on) that they need to keep apart under their umbrella (subtree), They act as sub-roots. Fundamentally, thats what needs to happen to 'solve' the general problem when printing binary trees, subtree overlap. To do this, you simply need to think about how you would 'print' or 'represent' the men in my anaolgy.  My implementation, its limitations and its potential  Firstly the only reason my code implementation takes in more parameters than should be needed (currentNode to be printed and node level) is because I can't easily move a line up in console when printing, so I have to map my lines first and print them in reverse. To do this I made a lineLevelMap that mapped each line of the tree to it's output (this might be useful for the future as a way to easily gather every line of the tree and also print it out at the same time).  If I could get ANSI escape codes working in the java console (windows ugh) I could simply print one line upwards and I would cut my parameter count by two because I wouldn't need to map lines or know the depth of the tree beforehand. Regardless here is my code that recurses in an in-order traversal of the tree:  To actually print this Tree to console in java, just use the LineMap that we generated. This way we can print the lines right side up  How it all really works  The InorderPrint sub function does all the 'work' and can recursively print out any Node and it's subtrees properly. Even better, it spaces them evenly and you can easily modify it to space out all nodes equally (just make the Nodedata equal or make the algorithim think it is). The reason it works so well is because it uses the Node's data length to determine where the next indent should be. This assures that the left subtree is always printed BEFORE the root and the right subtree, thus if you ensure this recursively, no left node is printed under it's root nor its roots root and so-on with the same thing true for any right node. Instead the root and all subroots are directly in the middle of their subtrees and no space is wasted.  An example output with an input of 3 + 2 looks like in console is:  And an example of 3 + 4 * 5 + 6 is:  And finally an example of ( 3 + 4 ) * ( 5 + 6 ) note the parenthesis is:  Ok but why Inorder?  The reason an Inorder traversal works so well is because it Always prints the leftmost stuff first, then the root, then the rightmost stuff. Exactly how we want our subtrees to be: everything to the left of the root is printed to the left of the root, everything to the right is printed to the right. Inorder traversal naturally allows for this relationship, and since we print lines and make indents based on nodeData, we don't need to worry about the length of our data. The node could be 20 characters long and it wouldn't affect the algorithm (although you might start to run out of actual screen space). The algorithm doesn't create any spacing between nodes but that can be easily implemented, the important thing is that they don't overlap.  Just to prove it for you (don't take my word for this stuff) here is an example with some quite long characters  As you can see, it simply adjusts based on the size of the data, No overlap! As long as your screen is big enough. If anyone ever figures out an easy way to print one line up in the java console (I'm all ears) This will become much much simpler, easy enough for almost anyone with basic knowledge of trees to understand and use, and the best part is there is no risk of bad overlapping errors.  Do an in-order traversal, descending to children before moving to siblings. At each level, that is when you descent to a child, increase the indent. After each node you output, print a newline.  From your root, count the number of your left children. From the total number of left children, proceed with printing the root with the indention of the number of left children. Move to the next level of the tree with the decremented number of indention for the left child, followed by an initial two indentions for the right child. Decrement the indention of the left child based on its level and its parent with a double indention for its right sibling.  For an Array I find this much more concise. Merely pass in the array. Could be improved to handle very large numbers(long digit lengths). Copy and paste for c++ :)  Here is my code. It prints very well,maybe its not perfectly symmetrical. little description:  1st function - prints level by level (root lv -> leaves lv)  2nd function - distance from the beginning of new line  3rd function - prints nodes and calculates distance between two prints;  please do not paste images as output, prefere always to paste (and format) your code / traceback / logs in SO  This code is written in C. It will basically print the tree "floor by floor".  Example of the output:  The function rb_tree_putchar_fd() can be replaced by a basic function that prints on screen, like  SIZE_LEAF_DEBUG should be replaced by an int, and should be an even number. Use 6 for conveniance.  The function display() has one role: always print SIZE_LEAF_DEBUG characters on screen. I used '[' + 4 characters + ']' in my example. The four characters can be the string representation of an int for example.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  