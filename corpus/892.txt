 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I was looking at the code below from stanford library:  What I don't understand is in the last recursive step for e.g if list is 1-2-3-4 Now for the last recursive step first will be 1 and rest will be 2. So if you set *head_ref = rest .. that makes the head of the list 2 ?? Can someone please explain how after reversing the head of the list becomes 4 ??  head_ref is a reference to the first node in the (sub) list at the current level of recursion. Rest refers to the first node in the remainder of the list. So setting head_ref to rest has the effect of chopping off the old head.  @ChrisCudmore Please tell how does rest retain its value as 4(i.e the last element of the actual list) after the backtracking of the recursion? Is it because we are passing the address of rest in the function call? Is it matched by the same name of the variable?  Where points to the first node and rest points to the node next to .  Since the list is not empty and list does not contain one node we make recursive call to to reverse the list pointed to by . This is how the list looks after reversing the rest of the list:  As seen now points to the reversed list which has at the beginning and at the end of list. The next pointer of node is .  Now we need to append the first node to the end of the reversed-rest list. To append anything to the end of the list we need to have access to the last node of the list. In this case we need to have access to the last node of the reversed-rest list. Look at the diagram, points to the last node reversed-rest list. Therefore will be next pointer of the last node of the reversed-rest list. Now we need to make it point to so we do:  After this step the list looks like:  Now the field of the last node of the list must be . But it is not the case now. The field of the last node ( node ) is pointing to the node before it ( node ). To fix this we do:  After this the list looks like:  As seen the list is now correctly reversed with pointing to the head of the reversed list.  We need to return the new head pointer so the that changes are reflected in the calling function. But this is a function and is passed as double pointer so changing the value of will make the calling function see the changed head:  The rest isn’t , it’s , which gets reversed recursively. After that we set to , which is now (recursively reversed!) .  The important point here is that although both and have the same type, i.e. , they are conceptually fundamentally different: points to one single element, while points to a linked list of elements. This linked list is reversed recursively before it gets assigned to .  I recently wrote a recursive method for reversing a linked list in ruby. Here it is:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  