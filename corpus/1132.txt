 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  To be on the safe side I am already using old style function pointers in my DLL calls like that:  Whereas I could use this one:  The latter however, as known, uses type erasure. cannot be a raw function pointer (for it may be passed a lambda which has captures and thus, cannot be a raw pointer).  So, in Visual studio, using a DLL build in release mode with a function signature that contains crashes, when used from an executable build in debug mode and vice versa. Even if it's both debug or release mode, the behavior is not the same. Sometimes it crashes, some times it works.  Is there a defined run-time behaviour that we can rely on to use ? Or this is a compile-only thing that is specialized by the compiler depending on what I pass to it and therefore, run-time behaviour cannot be assumed behorehand?  At the assembly level the function signature on a precompiled unit must be known. As far I as know runtime implementation is not well defined.  So, for example, when I'm compiling, then  can take any argument like , etc via type erasure. But when this is precompiled and thus runtime only, what can be accepted? How std::function is implemented? With a class pointer? Is there a well defined way?  I'm not looking for a necessarily VS-related solution, but a standard definition of , if any.  9,24122 gold badges3535 silver badges6363 bronze badges  3  4  I'm not sure I understand the question. There are a number of reasons why Debug and Release components cannot be mixed, not just this one.  @PaulSanders I edited, debug/release was an example. It also fails when anything precompiled is actually used. The main idea is to know how the runtime implementation of std::function is defined.  Type erasure is about implementation, what are you trying to say about the specified behaviour/meaning of the language?  2 Answers 2  So, in Visual studio, using a DLL build in release mode with a function signature that contains crashes, when used from an executable build in debug mode and vice versa.  This will never work because it changes the ABI.  Even if it's both debug or release mode, the behavior is not the same. Sometimes it crashes, some times it works.  This may work if you are careful about compiler flags, dependent static vs. dynamic libraries, how the C and C++ standard libraries are compiled, exceptions, etc. It is a complex topic and depends on what the compiler vendor guarantees.  Is there a defined run-time behaviour that we can rely on to use ?  In general, your best bet (and the most useful one for creating bindings for other languages) is to avoid C++ interfaces and use plain C ones with trivial types.  That is, if you want to pass C++ types, pass them as opaque types instead and only manipulate them from one side.  I'm not looking for a VS-related solution, but a standard definition of , if any.  The C++ standard does not force any particular ABI nor gives implementation details like data members for the vast majority of types.  That is why mixing different STL libraries is also a problem even if you compiled everything in the exact same way.  22.8k44 gold badges3131 silver badges6464 bronze badges  2  It's not only an issue on dynamic/static or debug/release like other C++ aspects. Even if all the options are the same I don't see a guarantee on how it will work. I'm not looking for a VS'related solution, but a standard definition of std::function, if any.  Old style callbacks should be a function pointer and a void pointer.  With that, you can send a std function (but not store it).  You can wrap up these operations in a standard layout class, and that is 99.99% safe to cross DLL boundaries. The code that is run/injected cannget unloaded early, but that is no different than with C style callbacks.  To safely store callable data, you need call-with-state, and destroy-state operations.  To do this in a totally dll safe manner...  you can convert a std function to the above pretty easily, and even vice versa.  It is standard layout, so should be safe crossing DLL boundaries.  But if insanely paranoid, you can unpack it and send 2 function pointers and a void pointer one by one.  Making a stateful object into above:  which works on lambdas or std functions.  A raw function:  no cleanup needed.  This is a move-only stripped down std function implementation. Many more improvements can be made while keeping it dll safe.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  