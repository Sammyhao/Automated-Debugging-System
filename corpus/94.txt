 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  i was recently solving a bfs problem where each node is a different arrangement of elements of an array. but i was unable to come up with a suitable data structure to keep track of the visited nodes in the expanded tree. generally the nodes are different strings so we can just use a map to mark a node as visited but what DS should i use in the above case?  5 Answers 5  The "visited list" is stored as the node's parent. Coding this to C++, you would probably handle most of the nodes as references or pointers since this pseudocode relies on referential behavior.  You start with an Area, which is a field of Nodes. The area knows where each node is in relation to the others. You start at one specific Node, the "start" node, and push it into a queue.  Traversing the area is as simple as getting the list of neighboring nodes from the Area, skipping them if they're already visited, and setting their parent and adding them to the queue otherwise. Traversal ends when a node removed from the queue equals the destination node. You could speed up the algorithm a little by doing this check during the neighbor loop, when the node is initially encountered.  NOTE: You do not need to generate every possible node within the area before beginning the traversal, the Area requires only that once it has created a node, it keeps track of it. This might help your situation where it appears you use permutations of strings or arrays: you could push the starting and ending nodes into the Area, and it could generate and cache neighbor nodes on the fly. You might store them as vectors, which can be compared for equality based on their order and contents with the == operator. See this example.  The traversal goes backwards rather than forwards because it makes rebuilding the path easier (rather than ending up at the end node, with each parent the node before it, you end up at the start node, with each parent the node after it)  Data Structure Summary  would need to keep track of enough information for to identify it uniquely (via an array index or a name or something), as well as a parent node. The parent nodes should be set to NULL before the traversal to avoid weird behavior, since traversal will ignore any node with its parent set. This keeps track of the visited state too: visited is equivalent to (parent != NULL). Doing it this way also keeps you from having to keep track of the entire path in the queue, which would be very computationally intensive.  needs to maintain a list of , and needs a neighbor map, or a mapping of which nodes neighbor which other nodes. It's possible that this mapping could be generated on the fly with a function rather than being looked up from a table or some more typical approach. It should be able to provide the neighbors of a node to a caller. It might help to have a helper method that clears the parents of every node as well.  is basically a list type, containing an ordered list of nodes.  is whatever FIFO queue is available. You could do it with a linked list.  I like how the syntax highlighting worked on my Wuggythovasp++.  At least as a start, you could try using/implementing something like Java's Arrays.toString() and using a map. Each arrangement would result in a different string, and thus it'll at least get somewhere.  4,9721414 gold badges3131 silver badges3636 bronze badges  6  yes i tried doing that but as the numbers can be more than one digit, the subsequent string was ambiguous in most cases ... for eg. if the array is 12 3 56 it gives 12356 and so does the array 1 235 6 .... is there a standard way to code such things?  Er, I'm silly. In Java, Arrays.toString() will return a string with the elements comma-separated, and the entire string starts with and ends with . From what you say, not all languages have as helpful of a solution. :/  If you want a language-independent solution, you can just implement a function that does the same thing as Java's Arrays.toString().  yes well i forgot to mention that am coding in c++. and i tried searching for an equivalent function in c++ but don't think it exists. I guess then a user-defined function is the only way! thanks....  Actually, wait. If we're talking about c++, is there any reason why we can't also just create a comparator for arrays, and make a map with that?  Just for the purpose of understanding, i have provided my sample code here (its in C#)  Here is BFS implementation using C++ STL(adjacency lists) for Graph. Here three Array and a Queue is used for complete implementation.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  