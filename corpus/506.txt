 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have written a code for this but it gives segmentation fault for disconnected graphs. It works fine for graphs that are connected. How can I overcome this error?  I did a dry run of the code. It will first create adjacency matrix edges and mark all the edges in it. Visited array is used to keep track of all the vertices that have been visited till now so that there is no infinite loop. For the test case given below it will work till the queue contains 1 then it will pop 1 and the loop will end because there is no edge left that is connected to 1 and is not visited. After this the while loop should ideally break and as done==0 it should return an empty vector. I can't understand why the segmentation fault is coming.  The map is being used to keep track of which vertex was put in the queue by which vertex.  Doesn't work for the test case:  Below is the image of the graph for the above test case:  Here we need to find the path from vertex 0 to 3. The input format is : Number of Vertices in the graph, Number of edges  In inner loop you don't check if is not empty, if queue is empty the call of method causes seg fault.  Your question title mentions depth-first search(DFS), but your code sample presents us your usage of breadth-first search(BFS). Which is the correct one?  @AManoj In unconnected graph some of items are not set (0 value), so your condition in if clause is false, then you read elements from which may not exist (first you have one element in , but in for loop you are reading to V elements).  1 Answer 1  You are popping the BFS queue incorrectly. Instead of the inner for loop, which is executed times for each entry in the queue, you should pop the queue in the outer loop, which is executed once for each element in the queue.  Also, in function of your code, there is a redundant expression in the for loop where you are printing the answer(s).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  