 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am writing a function that iterates over the entries in a map. I want to be able to deal cleanly with items which are added or deleted from the map while iterating, like does, but I am processing just one key/value pair per iteration so I can't use range. I want something like:  I know that range is using a '' struct and associated functions, as defined in , to perform iteration. Is there some way to gain access to this iterator as a reified (first-class) Go object?  Is there an alternative strategy for iterating over a map which would deal well with insertions/deletions but give a first-class iterator object?  Bonus question: is there an alternative strategy for iterating over a map which could also deal with the map and iterator being serialised to disk and then restored, with iteration continuing from where it left off? (Obviously the built-in iterator does not have this capability!)  1,38011 gold badge1212 silver badges2424 bronze badges  2  1  I don't understand what it is you are trying to do. Changing values in a map while iterating over it is perfectly valid. Is it that you are wanting specifically to have a data structure you can carry around that will resume a partially iterated map?  Correct: I want a datastructure I can carry around that will let me resume a partially-completed iteration of a map.  4 Answers 4  The only way to iterate over a is by using and you can't get an iterator object out of that.  14.5k1111 gold badges4444 silver badges4343 bronze badges  2  Looked at the go source for the range statement. It's a tough read, but from what I can tell, it might be possible to code another keyword into the language. It wouldn't be an iterator per se, but given you could do . Of course, for any type of key. Could do for slices too, to start from index 42. Of course you could do your own iteration on a slice, but range is kinda nice.  Nevermind that comment. I'll leave it up for possible discussion, but given the nature of maps, iterators for them just don't make sense on a fundamental level. At least not enough sense to add a keyword to the language.  Your iterator would be a function returning a channel that communicates the current iteration value to whoever receives it:  This is of course not generic, you could make it generic using and/or reflection but that shouldn't be too hard if you actually need it. Closing the channel at the end of iteration will notify the end of iteration, demonstrated later.  The type is just there so you can send key and value at the same time, it would look something like this:  50.2k1212 gold badges127127 silver badges128128 bronze badges  2  I like this. It does not quite handle deletion correctly, though, and I'm slightly concerned that it could fall foul of the internal checks hashmap.go does to try to detect concurrent access to the map from different goroutines.  Ah, yeah I forgot about the modification part, sorry. In that case you'd probably have to model the modification in the iterator and then it would look less nice than this.  A very simple approach is to obtain a list of all the keys in the map, and package the list and the map up in an iterator struct. When we want the next key, we take the next one from the list that hasn't been deleted from the map:  You can define your own map type. Also it will be good to solve concurrency problem:  20.3k2626 gold badges105105 silver badges141141 bronze badges  1  The sync mutex will prevent panics due to concurrent map access, but it will (if used correctly) also prevent modifications to the map while iterating over it. I need to be able to modify the map while iterating. This works great (provided iteration and modification are done in the same goroutine) with an ordinary map.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  