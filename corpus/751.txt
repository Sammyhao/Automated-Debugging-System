 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have been trying to implement a queue in Python, and I've been running into a problem.  I am attempting to use lists to implement the Queue data structure, however I can't quite figure out how to make and O(1) operations.  Every example I have seen online, seems to just append the operation and remove the first element from the list for the operation. But this would make the operation O(n) (where n is the size of the list) correct?  Is there something basic I have missed? Or do you have to use LinkedLists to implement a Queue efficiently?  7 Answers 7  As Uri Goren astutely noted above, the Python stdlib already implemented an efficient queue on your fortunate behalf: .  What Not to Do  Avoid reinventing the wheel by hand-rolling your own:  Linked list implementation. While doing so reduces the worst-case time complexity of your and methods to O(1), the type already does so. It's also thread-safe and presumably more space and time efficient, given its C-based heritage.  Python list implementation. As I note below, implementing the methods in terms of a Python list increases its worst-case time complexity to O(n). Since removing the last item from a C-based array and hence Python list is a constant-time operation, implementing the method in terms of a Python list retains the same worst-case time complexity of O(1). But who cares? remains pitifully slow.  Though objects support similar operations, they are optimized for fast fixed-length operations and incur O(n) memory movement costs for and operations which change both the size and position of the underlying data representation.  More critically, also provides out-of-the-box support for a maximum length via the parameter passed at initialization time, obviating the need for manual attempts to limit the queue size (which inevitably breaks thread safety due to race conditions implicit in if conditionals).  What to Do  Instead, implement your class in terms of the standard type as follows:  The proof is in the hellish pudding:  It Is Dangerous to Go Alone  Actually, don't do that either.  You're better off just using a raw object rather than attempting to manually encapsulate that object in a wrapper. The class defined above is given only as a trivial demonstration of the general-purpose utility of the API.  ...iteration, pickling, , , , , membership testing with the in operator, and subscript references such as .  Just use anywhere a single- or double-ended queue is required. That is all.  8,48044 gold badges3333 silver badges4444 bronze badges  3  8  In your example, shouldn't be the first thing off the queue? I would think your method would use ( instead of ). Then again, this just goes to show another problem with rolling one's own. :)  Related to what @lindes wrote, what's implemented in this answer is sometimes referred to as a last in first out (LIFO) queue, but its more commonly called a stack. The word 'queue' by itself is widely used to refer to a first in first out (FIFO) queue, hence the confusion.  Your code comment says collections.dequeue is "memory efficient", yet each node contains twice as many pointers as needed here (since all that is needed is a singly linked list, you don't need the back-links). This is just like recommending using a binary tree data structure in order to implement a singly linked list (by using only the left child pointer and ignoring the right one), isn't it?  Queue implementation using list in Python, handling enqueue and dqueue as per inbuild queue data structure:  Here is my implementation of Queue using array, and are both O(1) operations. The implementation is based on CLRS.  In dequeue method there is no any loop. You only have to do list operations. Therefore the time complexity for dequeue is also O(n)(linear).  No. Python lists are internally implemented as C arrays rather than linked lists. While the average and amortized worst-case times for appending to Python lists is O(1), the non-amortized worst-case time for the above call is O(n) (i.e., linear rather than constant). Ergo, your implementation does effectively contain an implicit loop. While that loop is presumably implemented via an efficient assembly-based contiguous memory copy, efficient alternatives requiring no such copy are well-known.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  