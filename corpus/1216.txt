 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  This must be me doing something stupid, but has anyone seen this behaviour before:  I have a map in a class member defined like so:  all behaves fine in debug but all goes wrong in release mode. map gets initialised to some crazy number:  Any member I have after the map gets completely corrupted, ie if I put an int on the line after the map like this:  and in my constructors set m_myIntThing to 0, after the constructor has been called m_myIntThing is some crazy number. If I move m_myIntThing to the line above the map everything for m_myIntThing is fine. This ends up causing big problems for me further down the line. Do I need to do something to the map in my constructor? I'm not at the moment.  I am using visual studio, this works fine with gcc. I only see the problem in release. The project is a dll.  If you have seen this kind of madness before please help its driving me mad. :-)  Something else is probably corrupted it. That's all anyone can tell you. Now you either have to properly investigate your program to see why, or show us code.  The key doesn't need to be const-qualified. Map takes care of that for you. Doing so could be exercising some bug in the compiler.  6 Answers 6  This has happened to me lots of times. Although it's hard to say in your case, a very likely reason is that you have different versions of the C run time library in between different projects. Check your "code generation" tab in the compiler settings for your different projects and make certain they are the same.  What's effectively happening is that different versions of the C run time libraries implement STL containers in different ways. Then when the different projects try to talk to each other, the meaning of what an std::map is (for instance) have changed and are no longer binary compatible.  The strange behavior is very likely some kind of heap corruption, or if it's being passed as a parameter to a function, stack corruption.  A bug that I have seen often in C++ projects is using an object after it has been deleted.  Another possibility is a buffer overflow. It could be any object on the same stack or nearby on the heap.  A pretty good way to catch the culprit is to set a debugger breakpoint that fires on memory change. While the object is still good, set your breakpoint. Then wait until some code writes into that memory location. That should reveal your bug.  If you're getting your information from the VS debugger, I wouldn't trust what it is telling you for a Release DLL. The debugger can only be really trusted with Debug DLLs.  If program output is telling you this, then that's different -- in that case, you're not providing enough information.  Hi, thanks for this, this is pretty much what was causing the problem. The reason for not posting all the code is that it involves several dlls and probably wouldn't help a great deal. I wanted to rule out any stupidity i might have been doing with the stl stuff. I'm always nervous around the stl as there do seem to be quite a few gotchas. Anyway I'm fixed now, one of my dlls was debug compiled and was throwing misleading data out. Once I changed that I was able to find the actual problem. Many thanks to all who replied.  Otherwise it sounds like memory corruption, although I can't say for sure.  Something else is stomping on memory  You're accessing deleted memory  You're returning a temporary by pointer or reference  etc  Any of these could appear to work fine in some cases as they're undefined behavior, and only in release mode do they blow up.  I had the exact same problem on g++, I got it resolved by removing the pragmas in a pragma paragraph before that. Eventhough the code is correct, I wonder if this is a compiler bug on the platform showing up when using stl::map in some situations.  Just to give a concrete example for the memory corruption:  Accidentally, I defined a ref to a member variable and not the member variable itself. It gets initialized alright, but as soon as the scope of static_init() is left, the map is destroyed and the ref will just show up in debug as "std::map with 140737305218461 elements" (pretty-printed) or similar as it points to now unallocated meory (or worse).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  