 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  The objective is to find whether a undirected, unweighted graph is a tree, i.e. check whether it contains a back edge. I'm using a modified form of White-Gray-Black DFS algorithm(which is given in Cormen and on the notes mentioned here: http://www.cs.cornell.edu/~wdtseng/icpc/notes/graph_part1.pdf )  Update: I'm now getting a WRONG answer for this problem. The code works for the sample test cases though.  Two things. The array should probably have 20001 elements. And you use before it has a value.  Additionally, it is very helpful if you name your variables with something longer than , and .  @sharth: I've updated the array color[20001] but however as you can see, n is assigned a value before function calls.  Please look at the first line of your main() function where you use in the loop condition. And unless I'm mistaken, is still an array of 128 s.  Since the graph is undirected, shouldn't you create 2 edges for each line of the input?: and ?  1 Answer 1  A graph is a tree if it is connected and , where and are the number of edges and nodes respectively. So, you should be able to solve it in time as long you check that before launching the DFS.  Can you test your program against a graph which is a path with nodes, with the node numbered being a leaf and there being an edge from to ? Please try to run it with stack size limits set to those on SPOJ(8MB IIRC) and ensure that you don't have a stack overflow. This is the worst case graph for the stack usage. If you do see the recursion being too deep, you can use a instead to check that the number of connected components is 1. Alternately, you can use path compression, which will make your runtime , but still easily fast enough to fit in the 1 second limit.  15.5k33 gold badges4141 silver badges5656 bronze badges  4  I've updated my question. The number of nodes are actually <=10000. I've updated my code accordingly (please have a look at it) and it gives the correct answer for small inputs but fails with bigger numbers.  On which node do I need to call DFS? I called DFS(0, -1). Which node should I call first?  You are calling condition2 any time a dfs finishes on a node. That isn't right. You should only be calling when dfs(0,-1) finishes. Anyway, since you have established that the dfs depth is acceptable, a simpler way to think if the problem is in terms of edges, nodes and connected components. You are being asked to check that CC=1 and that E+CC=V. So, forget about he parent node info that you are passing in the dfs and just use it to compute CC.  @user3125772 In my opinion, you should not hard code the parameters for the dfs() call in the main() function. It is possible that the tree might start with some other shortest node. In my accepted solution, I found out the least value of the entered nodes, and passed it as the parameter to the dfs() function.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  