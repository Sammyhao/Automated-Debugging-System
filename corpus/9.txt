 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  In order to not add duplicate lists (lists with same elements) in the result, I am pushing all unique values to a set. Then checking if the set doesn't contain at least one of the three elements before adding to the list. I think this should prevent me from adding duplicate lists. Please correct me if I am wrong.  But the output result I see is :  I don't understand why is getting added to my result even though the set contains all three elements . Where am I going wrong?  EDIT  Using the answers posted below, the final logic I built is:  However, when I run this, time limit is exceeding for a large input. I get the error message . 311/313 testcases passed and 2 of them failed.  Is there a way to improvise the runtime for this logic?  2 Answers 2  Here is lists of lists and are . So this is definitely evaluate to and you always append to the list.  Also you must first sort the lists before adding to the , so that and are identified as same.  Thanks for the answer. In this case, we don't need the set anymore. To improvise it, we can just remove out of the picture.  Sort your list, so that all solution lists will be in order. Then add only when the new list is not in the solution set -- your current test is useless, as it checks scalars against lists, which will always result in "I need this solution".  74.6k1414 gold badges5151 silver badges7575 bronze badges  1  1  thanks for the answer. In this case, we don't need the set anymore. To improvise it, we can just remove out of the picture.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  