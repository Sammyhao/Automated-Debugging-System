 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Edit: I have added all files (.c, .h and a Makefile). The program works but has many memory leaks.  How do you iterate through a hash table to call free()? I am wondering if I need to create a separate function to call free() on htable and results or I can do it inside this code. Any ideas? I just need to call free() on htable and results.  Are you sure to understand what hashtables are? You definitely should explain what is... We can only guess .... and then your code seems incorrect...  2 Answers 2  Before the 'whole program' was provided  Given the information in the function:  we have to infer (since you didn't include the actual information) that your hash table is an array where the elements are linked lists of individually allocated elements containing an allocated name, a frequency and a pointer to the next item. Therefore, freeing the hash table involves visiting each element of the array in turn, chasing down the linked list, freeing the name and the element.  After the 'whole program' was provided  We still don't have the data structures, so we still can't really say what is going on. So, we can add this to the top of the code:  However, one issue that arises when we add that is:  The compiler says:  identifying that line. Now, it might be that your have some typedef like:  And for the last four names, the linker fails to find them. We need code that doesn't use code that is not available. Reduce your code to an SSCCE (note self-contained!).  I've hacked out the calls to those functions and simplified main accordingly. When run on its own source (), it produces:  Looks OK...but run the optimized build under and another story shows up...but I've since concluded that the problem is in the optimized implementation of in the specific version of GCC I'm using (because, in part, using a different version of GCC on the very same code makes the errors go away, and because the errors were in a call to which has no business reading 4 bytes starting at offset 4 in an allocation of 5 bytes).  I added a function . I think that for almost any non-trivial structure, it is worth having a 'print' or 'dump' function available like this.  I inserted a call to this just before . This showed that despite the not dreadfully effective hash algorithm, the data structure was intact.  I also inserted a call to after , and that showed that the hash table was comprehensively destroyed by the sorting process. The sort phase eliminates the hash table as a hash table; the only thing to do is to release the table as whole (). Freeing all the table entries has to be done at the foot of the function :  And the free_hashtable() code has to be simplified:  In this program, it's not critical to reset the pointers and counts to null/zero. Also, the and pointers are invalidated by , so arguably those should be nulled/zeroed in that function.  This runs leak-free for me, and with only system-allocated memory still in use at the end.  685k128128 gold badges842842 silver badges12131213 bronze badges  9  But nowhere in his code does the original poster sets in so we cannot be sure that the hash-table is an array of linked list buckets.  @BasileStarynkevitch: I think is used to create an element that is added to the appropriate list in , but I agree that it was an inference and I said as much with 'we have to infer'. Let's see what the changes are with the whole program present.  @JonathanLeffler: Great, but we still miss the header file, and I'm getting the impression that the original poster (@RedWorkerGia) don't understand fully what his hash-table should be (or some basics about C programming).  sorry guys, I have added the h file. I should have explained it before. My bad. I do understand C but I mostly work in C++ and never had to deal with memory management like malloc and free. I just call new and it does everything :)  First, you don't need to clear each individual after having allocated thru (because gives you a cleared memory zone or fails). I do suggest using also in for .  Then, you probably want to have some function to delete your . Something like  Remember that you can a pointer (nothing harmful would happen).  And you probably want to call before your (just to avoid memory leaks, and make valgrind happy).  At last, you might consider using existing hashing functions in existing libraries. Consider for example Glib (within GTk, but you can use Glib outside of any GTK application). It gives you hash-tables already (and given that these are often used, you may be confident about them). Don't forget that GTK (hence Glib) is a free software library under LGPL2.1 license so you can download its source code, study and improve it. You want to look inside glib/ghash.h header and glib/ghash.c code source files (and some others).  Thank you for your response. I tried the similar thing before but didn't set the htable to NULL. I understand now, since htable is a global pointer variable, we need to set it to NULL after calling free. Thanks bro, u r the man. Any ideas on freeing results. I created a for loop to iterate through the list and call free but it broke my program.  I don't understand why it (and what exactly) has broken your program. Consider compiling with and debugging with and . Since we don't know what is (to what exact -ure does it point to) we cannot help much more.  program works, but I need to fix "still reachable" memory leaks. I am using Valgrind  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  