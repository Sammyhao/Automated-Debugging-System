 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  The problem with this code (aside from being horribly slow for large arrays, but that's not the point) is that since the undeclared elements for the array will be set to , the duplicate elements from the first array are being set to in (if that makes any sense). I understand why this happens, but cannot find an efficient way to fix this. I tried setting the duplicate elements to in the unique array and then printing only the elements of which are not equal to , but that seems like a weak solution to the problem. How can I fix this problem?  EDIT: If I run the code:  How many numbers are you going to enter? 4 1 2 2 0  Output:  Since the second element of the array is a duplicate, I do not set to any value, making it default to 0. How do I avoid printing that 0, since it is not part of the original array?  EDIT 2: Yes, this is homework, but the reason I don't want to use sets, sorting, etc. is primarily that I am not familiar with them. Also, as I am not asking anyone to write the entire program for me, I think it's fine to ask for a little help.  1,83022 gold badges1919 silver badges3939 bronze badges  8  Im afraid it doesn't make any sense to me, perhaps you could reword what you are trying to say in your question?  Without using a List or Set the solution gets extremely messy. If you have to not use a List or Set, i'd just suggest setting duplicate values to Integer.MIN_VALUE, like you said, or creating a parallel of boolean values  Java arrays are not dynamically sized, so you can't remove an element without more code. Also, the or are not a or sorting.  10 Answers 10  Any value that you choose (zero, min-int, max-int) to represent a removed duplicate is a problem. The user could always enter that number, and your program wouldn't behave correctly. (The only way you could legitimately use (say) min-int or max-int would be if the requirements clearly said that that number was invalid input.)  The correct way to deal with duplicates is to keep a counter of the number of non-duplicates, and make sure that the duplicates (or slots that would contain them) are at the high end of the array; i.e. indexes >= the counter. (That becomes an invariant that your algorithm needs to maintain ...)  The best solution is to eliminate the duplicates before you add them to the array. Keep a count of the number of non-duplicates and iterate until that reaches your ... rather than the length of the array.  But if you do want to add all values to the array and then eliminate the duplicates, when you find a duplicate you need to swap elements so that you can maintain the invariant. The logic is a little bit fiddly ... but quite doable.  UPDATE  I just noticed that your original solution was using two arrays. I assumed that you were using one array, and doing an in-place update to eliminate the duplicates.  657k9090 gold badges752752 silver badges11371137 bronze badges  7  That is true, and I admit, that is a flaw in my answer, but the OP admitted that this is homework and only wants an answer that uses tools the OP knows how to use and can deal with a reasonable set of inputs. Your point is still valid, it's just that this is homework that the answers are dumbed down  "The idea to to have a quality answer for anyone to use." - The quality answer to the functional requirements (as stated) is to not use an array at all. (Using an array is not a functional requirements. It is an implementation constraint ... that doesn't make much sense for anyone trying to write quality code for Java SE, EE, Android.)  So what I understand is that I should check each inputted integer with the previous inputs and only add it to the original array if it is unique. Also have a counter that counts how many inputs have been added to the array (i.e. inputs that are unique). Then create a new array of length which contains the first elements of the original array. Is this what you are saying? In this case I would not need to ensure that the duplicates are near the end of the array, correct?  Maybe I misspoke. It depends on whether you eliminate the duplicates before or after. In the former case, you are right. The duplicates shouldn't be in the array at all, and the slots greater than the 'count' position can be left in their initial state. (Just don't print them ...) Anyway, you should think it all through for yourself rather than taking my (or anyone else's) word for it.  I am going to use the tools that you used to solve the problem, cuz something in me is telling me this is homework...  So, you see where I commented out my edit? that's the new thing, a very easy way to check is to give the values a number that is not expected, in this case, a negative number. Now, that is an assumption on my part, change -1 to whatever value you know will not be entered into that . Same for the if statement.  This answer makes the most sense to me, as it is what I was thinking to do at first. However, I do not know what values will not be entered, so I decided to use a and use as the value that will not be entered (the inputted values should be integers, so 0.5 should not be entered).  An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value.  I don't know why you would not want to use a set unless you are doing homework...  If you really can't use a set. Go ahead and create an . Store the elements of the inside, but everytime you want to store you check if the element is already part of the .  You can, if you want, turn your back into an array.  Yes, this is homework, but the reason I don't want to use sets, sorting, etc. is primarily that I am not familiar with them. Also, as I am not asking anyone to write the entire program for me, I think it's fine to ask for a little help.  You can store the maximum value entered by user (while the user is entering the values in the first loop) and then make the default value for unique equals to max + 1.  Or you can try another approach for solving the problem, something like this:  Note that this solution is under the assumption that the user will not enter a number greater than .  Hmmmm, the OP is worried about inefficiency, I have to give a -1 for lack of efficiency, since it's something the OP specifically asked for...  That doesn't mean anything when you are creating a million unit long array... efficiency can cap off when the individual load of an action outweighs the efficiency of that action  There's a trade-off between performance and storage, performance wise, it's efficient, note that we're not going to iterate over them at all.  Regardless, creating that array will take time, time the OP is already pressed for. Perhaps I misspoke, the OP is concerned about time, and every unnecessary action is detrimental to the OP, if you look at my answer, a little type-casting quickly solved the issue of permitted responses without going overboards  This solution allows you to enter any integer value even negative. It's your same code with some modifications and has added a parallel array for comparisons. It has also removed some lines of code that are no longer needed.  Create a parallel character array with all the values as '.' Whenever you find a duplicate, set the value to a ',' in the character array. Then Print only the values of your array that have a corresponding '.' in the character array.  I tried to improved this code, please comments/suggest if further improvement can be done.  Although the code is appreciated, it should always have an accompanying explanation. This doesn't have to be long, but it is expected.  While your code actually seems to accomplish what the title of the question asks, it doesn't relate to the code provided in the question. Also, your answers should always be accompanied by an explanation to make reading easier for people unfamiliar with the topic.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  