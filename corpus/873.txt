 Kth largest pairwise product possible from given two Arrays  Last Updated : 29 Dec, 2021  Given two arrays arr[] and brr[] containing integers. The task is to find the Kth largest product of a pair (arr[i], brr[j]).  Examples:  Input: arr[] = {1, -2, 3}, brr[] = {3, -4, 0}, K = 3 Output: 3 Explaination: All product combinations in descending order are : [9, 8, 3, 0, 0, 0, -4, -6, -12] and 3rd largest element is 3.  Input: arr[] = {-1, -5, -3}, brr[] = {-3, -4, 0}, K =5 Output: 4 Explaination: All product combinations in descending order are : [20, 15, 12, 9, 4, 3, 0, 0, 0] and 5th largest element is 4.  Naive Approach: Generate all the possible products combination for each element in array arr[] with each element in array brr[]. Then sort the array of results and return the Kth element of the results array.  Python3  Output:  Time Complexity: O(N*M + (N+M) * Log(N+M)) Auxiliary Space: O(N+M)  Efficient Approach: This problem can be solved by using the Greedy Approach and Heaps. Follow the steps below to solve the given problem.  Sort the brr[] array.  Keep larger size array in the array arr[].  Create a max heap to store the elements with their respective indices.  Traverse each element from array arr[]. The element can be either positive or negative.  Positive: Multiply current element from arr[] with the largest element of sorted array brr[]. To ensure that maximum element is obtained.  Negative: In this case multiply with the smallest value, i.e. with the first element from array brr[]. This is due to the property of negation, as a larger value can be obtained by multiplying with the smallest one.  Insert three values into heap such that : ( product, i, j ) where i & j are the indices of arrays arr[] and brr[].  Now run a for loop K times and pop elements from the heap.  Now check if the value present at arr[i] is positive or negative  Positive: So next_j = ( current_j â€“ 1) because as max heap is been used, all the higher indices might have been already popped from the heap.  Negative: next_j = (current_j +1) because all the smaller values yielding larger elements might have been already popped from the heap.  Finally, return the answer  Note: Max heap is implemented with the help of min-heap, by negating the signs of the values while inserting them into the heap in Python.  Below is the implementation of the above approach.  Python3  Output:  Time Complexity: O(M*Log(M) + K*Log(N)) Auxiliary Space: O(N)  Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here.  We use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy Got It !  