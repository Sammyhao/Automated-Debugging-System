 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am implementing a graph structure for a path finding algorithm in C++.  When a new edge or node is created, it is stored in a separate vector for later deletion by the graph class' destructor. I use pointers because they provide easy graph navigation; I can easily test nodes' identity by simply comparing their addresses or I can create paths by creating vector of pointers and later directly use these pointers to navigate through the graph.  I have read articles about how pointers are bad and should be avoided or replaced with smart pointers (but even they should be avoided). Or that good programmers don't use them at all (with exceptions). I understand that they are sources of memory leaks, security risks and overall are hard to manage correctly (especially in multithreaded applications).  My question: is pointer approach in this case bad?  "...modern C++ idioms often don’t need pointers at all..."  "For somebody who knows modern C++, it’s clear that you very rarely need any pointers (either smart or raw; except when using them as iterators)."  Where did you read that smart pointers should be avoided? (I am not asking where you read about good programmers not using pointers because this is obviously nonsense)  Pointers are not bad, they're part of the language and one of the most useful ones. The whole thing about smart pointers is ownership of the memory that a pointer points to. In this specific context I don't see why you should use smart pointers.  @101010, using smart pointers in given scenario will either render setup buggy (if auto_pointers are used) or incur unncessary performance degradation.  5 Answers 5  I am going to repeat myself. POINTERS ARE NOT BAD. Print it in friendly yellow letters (C) and pin on the wall. They are extremely useful. I have never seen a professional C++ program which managed to avoid pointers completely.  Managing your own pointers is usually bad, unless you are working on pointers manager.  Unconstrained standard memory allocation can be a bottleneck in high performance applications - but pointers are NOT sinonyms with standard memory allocations.  Pointers ARE not source of memory leaks, or security risks. Pointers are NOT hard to manage (no harder than write good programms in general).  If you do not want to use pointer, you've choosen wrong language.  59.4k55 gold badges6868 silver badges122122 bronze badges  6  You might think about using std::shared_ptr. Graphs may have many edges pointing to the same node. How how would you know when to delete it. shared_ptr uses a reference count for this to prevent memory leaks.  One might add, that managing heap memory "manually" which is usually the first case where newbies encounter pointers is bad, but this is not the only use of pointers.  @tobi, this is exactly the message I was trying to convey. May be I've used bad wording here?  @SergeyA no, actually imho your wording is completely fine. I was just afraid that novices might confuse "using pointers" with "using new and delete all over the place" (I consider myself as just one step beyond being a bloody noob, thus I am still quite picky about this stuff. I took me a while to swallow all the "pointers are evil" articles until I reached a point where now I can again appreciate how nice pointers can be ;)  Why are pointers to be avoid if possible for performance reasons? Because you have to follow them around in memory, they suffer from very bad cache locality.  How many owners can there be of an object? There can be only one! unless its a (which then is the real single owner). Hence you can use none-owning pointers as long as you only follow them and don't delete or transfer owner ship with them.  Will pointers magically update if what I point to move? No! if you use a vector for storage and you exceed its capacity it will relocate rendering all pointers to it invalid. If your sure that you have enough capacity you can use pointers.  So in this case I would consider the following structure, a pointer into a memory is just just an index into memory so why not use the indexes themselves?  or more radically if you don't need to traverse all edges  What you can't do with this is: a) delete any Node/Edge and move the rest up. b) move any of them including c) sort them  remember to erase the Edge in both Nodes if you remove it.  If you got a lot of edges in each vector it might be relevant to sort them so you can use a binary search to find a specific one.  If you want to use pointer just be sure to have one owner for each node and edge. Placing them in a vector secures this, but beware of resizing as it invalidates all vectors.  14.6k33 gold badges2323 silver badges3636 bronze badges  1  Thank you for your answer. I thought of this and i think it's one the best way to avoid pointers, but another drawback is that i can't use Nodes or Edges on their own and every time i pass Node to some function i need to pass reference to whole graph aswell.  Here, Nodes either contain other Nodes or references to them. In containment, maintaining coherency among N-to-the-N copies of Nodes would be a nightmare. A reference of some sort is vastly less complex and less likely to result in problems.  But now managing ownership becomes a problem. Who owns the Node and is responsible for deletion when it's no longer used?  With an undirected graph, a Node can own itself and self destruct ( or remove itself from a Node pool) when it has no further connections.  In a directed graph, a Node can't self-determine because it has no knowledge of who may still be pointing to it. Its fellow Nodes must be collectively responsible and free the Node when no Nodes touch the node. Tracking this is a fun management task, but also kind-of the point of a graph.  30.1k66 gold badges2929 silver badges4949 bronze badges  2  In this case Nodes or Edges don't perform any deletion. Graph class keeps vectors of all created Nodes and Edges and deletes them when Graph itself is deleted.  @FrantišekNěmec A node pool. Good management strategy for most cases and usually easy to detect when it isn't.  Using plain pointers for the class is all right, as long as a node that has been added does not get removed again. You can still delete the whole graph in its entirety. If your graph mutates frequently I'd suggest to use for the edges.  However the class is completely obsolete.  This is sufficient for directed and undirected graphs. In both cases you only need to record outgoing edges. In an undirected graph you have to record the edge in both nodes (with a pointer in the other direction).  The meme about pointers being bad is simply false. Pointers are an important part of the language, and often the best (or only) way to reference one data structure from another. Even the NASA JPL uses pointers freely in their performance- and safety-critical code on spacecraft. See their programming standard: http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf  Using pointers carelessly can get you into trouble, but that is true of everything in life.  @M.M Pointers in C++ are equivalent to and no more or less harmful than pointers in C. The difference is simply whether one chooses to wrap them in a templatized wrapper class.  You're thinking of C++ as "C with classes". Things have changed a bit in the last 30 years.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  