 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Humpy likes to jump from one building to another. But he only jumps to next higher building and stops when no higher building is available. Stamina required for a journey is xor of all the heights on which humpy jumps until he stops.  If heights are [1 2 4], and he starts from 1, goes to 2 stamina required is 1XOR2=3 , then from 2 to 3. Stamina for the entire journey is 1^2^4=7. Find the maximum stamina required if can start his journey from any building.  Please fix your indentation. Looks like you have a loop inside a loop there. why is this necessary? shouldn't 1 loop be enough? also in the first loop I don't understand why you append both and ? I think it will cause a duplicate  2 Answers 2  What you are doing is going over each index in the array and calculating the stamina required for the journey starting from that index. This will work fine for small inputs, but will be very inefficient for longer inputs.  take this example input . You will have 5 journeys to calculate:  1, 10, 11, 12  10, 11, 12  11, 12  If you look at the first 2 journeys, we can see that they are the same except for the first member (2 and 1). so if you had the XOR sum for (10, 11, 12) in memory somewhere, let's say in a variable called , you could just do , and to calculate these two.  So to improve your algorithm, try saving the results of these calculations somewhere and reusing them whenever they are needed.  You can do a unique sort of the list of buildings and rule out the duplicates. (If two buildings A and B have the same height, any route that includes A will also occur with B with exactly the same score, but there is no route that contains both A and B).  Now if your list of heights has a length of , the number of possible routes is something like : For each route to buildings don't participate. If a route with zero buildings is also considered OK, with a required stamina of zero, we end up with possible routes. That's quite a few if you start with thirty buildings, or so.  The problem with the weight is that the function doesn't behave that well. E.g. a route like 1, 10, 11, 12 shows a total cost of 12 (1^10=11, 11^11=0, 0^12=12), where the route 1, 12 shows a total cost of 13. Hence, just because a route passes less buildings, it is not guaranteed that it is cheaper.  Maybe the better idea is to look at the XOR operation. This is a bitwise operation. And if, let me say, bit 2 is affected by the operation, this doesn't imply anything for the rest of the bits.  Now a bit remains 1 if you XOR an odd number of operands that have that bit set. The highest building will limit the range of the stamina value. This building will set the most significant bit and maybe some others. Note that there might be more buildings that would set that highest bit though.  Now for each lower bit try to find a building or a combination of buildings that would set that bit without changing any of the higher bits. If there is no such a building, well just skip that bit.  Example:  Imaging your buildings are given by (1, 2, 3, 7, 8, 11, 15, 21, 22, 33). To make it a bit easier: (1, 10, 11, 111, 1000, 1011, 1111, 10101, 10110, 100001). Obviously the maximum costs can only be 111111.  So we start with 33, or 100001. The next bit to set would be the 4th bit, which is set for both building 21 and 22. We'll have to try both from here.  Path 33 <- 22:  100001 xor 10110 = 110110. Now we'll have to look for the 3rd bit, for which we have 3 candidates: 1000, 1011, 1111.  Path 33 <- 22 <- 8:  110110 xor 1000 = 111110. Only the 0th bit is left zero now. And fortunately we have a building with height 1.  Path 33 <- 22 <- 8 <- 1:  This is one path with max costs (63, or 111111).  We could try to find something similar for the other second building (21) or any of the other buildings that would set the 3rd bit, but since we've already found the maximum, no need to try.  It is possible that you'll need an odd number of buildings, not just 1, in order to set a bit, because it is possible that this way "the right" less significant bits are cleared. Hence, if my example would have had (..., 33, 34, 35, 36, 37, 38), the combinations that set the highest bit are, naturally each building on itself, then 20 combinations of 3 buildings and 6 combinations of 5 buildings.  You need to evaluate each bit, even if it's set, because adding another pair of buildings can have a positive effect at the lower order bits.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  