 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am working on an existing large project which basically:  Uses a scene graph, where each node has children slots  Performs an initialization step where each node recursively initializes its children, and do some precalc/cleanup tasks on its own data members.  Then a large computation is started, the scene graph is then accessed in pure read-only mode from const member functions only  Currently, children are stored using smart pointers, mostly to avoid deep copies when building the graph from file read and during user edition of the graph.  As the smart pointers (std::shared_ptr) do not propagate constness, I have the following options:  Store the children using smart pointers to const objects. When recursively doing the initialization step, const_cast them to non-const pointers Store the children using smart pointers to const objects. For recursively doing the initialization step, const_cast them to non-const pointers. I do not like abusing of const_cast  Store the children using smart pointers to const objects. When recursively doing the initialization step, do a deep copy of each children to a non-const object, initialize it, and replace the children by the initialized one. This is not efficient, each node is deep-copied during initialization  Store the children using smart pointers to non-const objects. Then initialization is not a problem anymore, but all const member functions used during computation may call non const member functions of children, which is a potential source of bugs and clearly non const-correct.  I know that using smart pointers only to avoid deep copies during tree manipulation is not the nice way to implement this at the age of c++11 and move semantics. Rewriting all the code with move semantics might be done one day, but this represents quite a large work.  What would be, in your opinion, the nicest way to implement that pattern, without rewriting all with move semantics? I have thought of wrapping std::shared_ptr to propagate constness, are there other ideas?  8,15611 gold badge3131 silver badges7878 bronze badges  5  How about using raw pointers? Probably, in your data structure, the only changes should be in node destructor (to delete all children) and node removal method (to delete the node being removed). However, if things are more complicated than what I think, then make the wrapper.  @AndreSassi Raw pointers will not propagate constness any better than smart-pointers. Also using raw pointers is going to make life difficult especially with node copying behaviour.  "As the smart pointers (std::shared_ptr) do not propagate constness" You can do that manually, if those smart pointers are not public data members: don't modify the object pointed to in member functions (and don't provide non-const access to that object in member functions).  @dyp : yes, but mistakes are always possible, such as calling a non-const member function of a child. And the compiler won't complain. The whole purpose of constness is lost if you have to manually think about not doing non-const operations in const functions  1 Answer 1  I would go with option 3 but store the children in private member variables in a base class or composed object.  Only allow access to the children via getters that enforce const correctness.  The const getter returning a raw pointer-to-const. The non-const getter returning a raw pointer or shared pointer.  I've used instead of in my example because I can but you may have a good reason to use .  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  