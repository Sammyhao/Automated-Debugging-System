 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  An additional hash table can be used to make deletion fast in min-heap.  Question> How to combine and so that I can implement the idea above?  Question> I am not able to make the following work:  I have to use list as the container b/c the iterators of list is not affected by insertion/deletion (Iterator invalidation rules)  32.4k6666 gold badges229229 silver badges363363 bronze badges  5  I guess I'm wondering why you're using a priority queue to implement a min-heap, since I'm used to it being the other way around.  "An additional hash table can be used to make deletion fast in min-heap." While that may or may not be true, the statement is NOT referring to and specifically, and I would seriously doubt they can be used together in any effective way, much less in the way the comment discusses.  You are right and the book doesn't mention priority_queue or unordered_map. Here, I just want to implement the idea in c++ based on the idea.  1 Answer 1  You can't do this with the supplied data structure:  In a priority queue you don't know where the elements are stored, so it is hard to delete them in constant time, because you can't find the elements. But, if you maintain a hash table with the location of every element in the priority queue stored in the hash table, then you can find and remove an item quickly, although I would expect log(N) time in the worst case, not constant time. (I don't recall offhand if you get amortized constant time.)  To do this you usually need to roll your own data structures, because you have to update the hash table each time an item is moved around in the priority queue.  It's based on older coding styles, but it does the job.  To illustrate:  Inside the statement we do the normal heapify operations on the heap and then update the location in the hash table () to point to the current location in the priority queue.  5,14933 gold badges4343 silver badges5353 bronze badges  3  2  You get amortized constant with the hash table, but the priority queue can't do better than without tearing up the implementation of said priority queue  ... and with that probably destroying the performance of other operations (eg: insert)..  ... and for most of those variants that claim O(1) for insert (or delete), it comes with a huge constant factor that makes the real world performance worse than with a simple binary heap.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  