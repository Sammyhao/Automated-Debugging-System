 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I was looking for a tree or graph data structure in C#, but I guess there isn't one provided. An Extensive Examination of Data Structures Using C# 2.0 a bit about why. Is there a convenient library which is commonly used to provide this functionality? Perhaps through a strategy pattern to solve the issues presented in the article.  I feel a bit silly implementing my own tree, just as I would implementing my own ArrayList.  I just want a generic tree which can be unbalanced. Think of a directory tree. C5 looks nifty, but their tree structures seem to be implemented as balanced red-black trees better suited to search than representing a hierarchy of nodes.  I would consider it to be a bad idea to import an entire UI library for a very simple tree.  Could you motivate? Its not like actual harddrive space requirement is an issue anymore? Clumsy? As I mentioned before, I can understand that this is not a solution for an specialised software or something without an existing user interface. I am a lazy programmer, if I can get a structure for free its all good. And an existing library does have a lot for free, one can find a lot of code from people that used it for a lot of things.  Also, it might creates a lot of compatibility and maintenance issue. Your program is Windows only... just because you used some UI tree for winforms or WPF? What happens if you want to update your software, but you also depend on the (probably lots of) dependencies compatibility of the UI machinery?  19 Answers 19  My best advice would be that there is no standard tree data structure because there are so many ways you could implement it that it would be impossible to cover all bases with one solution. The more specific a solution, the less likely it is applicable to any given problem. I even get annoyed with LinkedList - what if I want a circular linked list?  The basic structure you'll need to implement will be a collection of nodes, and here are some options to get you started. Let's assume that the class Node is the base class of the entire solution.  If you need to only navigate down the tree, then a Node class needs a List of children.  If you need to navigate up the tree, then the Node class needs a link to its parent node.  Build an AddChild method that takes care of all the minutia of these two points and any other business logic that must be implemented (child limits, sorting the children, etc.)  18.2k77 gold badges5757 silver badges9494 bronze badges  3  6  personally i wouldn't mind some sort of self-balancing binary tree to be added to the library as this is some extra work than just using an adjaceny list.  @jk I believe that SortedDictionary and SortedSet are built atop red/black trees, so using these should work.  Simple recursive implementation... < 40 lines of code... You just need to keep a reference to the root of the tree outside of the class, or wrap it in another class, maybe rename to TreeNode??  2,27311 gold badge1616 silver badges1515 bronze badges  16  27  In this case, in C# anyway, you could avoid writing your own delegate and use the pre-made delegate: . Action<>'s signature is: . There are also versions from 0 to 4 different parameters. There's also an analogous delegate for functions called .  Advantage of LinkedList is it is more efficient for the purposes we put it to here, and it only consumes as much memory as it needs for however many child nodes are stored. The only action that would be more efficient with an array based List implementation is the getChild(int), but I would expect that to be invoked sparingly, usually add and traverse will be used, for which LinkedList is ideally suited. Completing the implementation and adding in Remove may complicate things. Be nice if C#s generics allowed the user to specify the List implementation to best suit usage, but it doesnt.  changing the traverse method to be static or possibly wrapping it to hide the recursive nature would be a good idea, but it is simple to traverse: create a method with the signature of delegate ie for a tree of ints: void my_visitor_impl(int datum) - make it static if you need, instantiate a delgate: TreeVisitor<int> my_visitor = my_visitor_impl; and then invoke on the root node or NTree class if u make it static: NTree<int>.traverse(my_tree, my_visitor)  Making addChild() return the NTree that it added would make it nicer for adding data to a tree. (Unless I'm missing a cunning way to build a tree with this, without relying on the implementation detail that a newly added child == getChild(1)?)  Here's mine, which is very similar to Aaron Gage's, just a little more conventional, in my opinion. For my purposes, I haven't ran into any performance issues with . It would be easy enough to switch to a LinkedList if needed.  42.9k7070 gold badges261261 silver badges340340 bronze badges  5  why is your Value property exposed when you're setting it in the constructor? that leaves it open for manipulation AFTER you've already set it via constructor right? Should be private set?  Thanks! I quite liked not having to write my own. (Still can't believe it isn't a thing that exists natively. I always thought .net, or at least .net 4.0, had everything.)  I liked this solution. I also found I needed to insert, I added the following method to do that.  This is an exceptional piece of code and in my opinion the best answer. Reading through it was a lecture in of itself.  2,82611 gold badge1616 silver badges1717 bronze badges  5  How do I use the search in your code example? Where does come from? Does it mean I have to iterate over the tree in order to use the search code?  @GrzegorzDev Maybe -1 because it does not implement all members, so it doesn't compile.  only problem i see is that it will not be correctly serialized with basic JsonConvert as it implement IEnumerable<>  @Grzegorz Dev - Hi is there a way to get all the nodes at level two as a list of strings?  The generally excellent C5 Generic Collection Library has several different tree-based data structures, including sets, bags and dictionaries. Source code is available if you want to study their implementation details. (I have used C5 collections in production code with good results, although I haven't used any of the tree structures specifically.)  13.3k77 gold badges3333 silver badges4040 bronze badges  3  7  Don't know if maybe things have changed but right now the book is freely available to download as PDF from the C5 site.  Lack of documentation is no more a concern as there's a 272 pages long pdf complementing the library... Can't comment on code quality, but judging from the doc quality, I'm really looking forward to digging into this tonight!  From what I understand, this C5 library doesn't have trees at all, but only some tree-derived data structures.  QuickGraph provides generic directed/undirected graph data structures and algorithms for .NET 2.0 and up. QuickGraph comes with algorithms such as depth-first search, breadth-first search, A* search, shortest path, k-shortest path, maximum flow, minimum spanning tree, least common ancestors, etc... QuickGraph supports MSAGL, GLEE, and Graphviz to render the graphs, serialization to GraphML, etc.  3,77911 gold badge3030 silver badges3434 bronze badges  1  The QuickGraph link is broken: "Hmm. We’re having trouble finding that site. We can’t connect to the server at quickgraph.codeplex.com."  Using a recursive generic declaration and a deriving subclass, you can better concentrate on your actual target.  Notice, it’s different from a non generic implementation, you don’t need to cast 'node' to 'NodeWorker'.  @WeDoTDD.com looking at his class you see Traverse declares it as 0 to start at the root node, then uses the method traverse adding to that int each iteration.  There is the now released .NET codebase: specifically the code for a that implements a red-black tree: sortedset.cs  This is, however, a balanced tree structure. So my answer is more a reference to what I believe is the only native tree-structure in the .NET core library.  8,18055 gold badges4444 silver badges7171 bronze badges  1  Good design. However I'm not sure if a node 'is' a sequence of its child node. I'd consider the following: a node 'has' zero or more child nodes, so a node is not derived from a sequence of child nodes, but it is an aggregation (composition?) of its child nodes  I created a Node<T> class that could be helpful for other people. The class has properties like:  There is also the possibility to convert a flat list of items with an Id and a ParentId to a tree. The nodes holds a reference to both the children and the parent, so that makes iterating nodes quite fast.  Most trees are formed by the data you are processing.  Say you have a class that includes details of someone’s , would you rather have the tree structure as part of your “domain class”, or use a separate tree class that contained links to your person objects? Think about a simple operation like getting all the of a , should this code be in the class, or should the user of the class have to know about a separate tree class?  Both of these examples show that the concept of a tree is part of the domain of the data and using a separate general-purpose tree at least doubles the number of objects that are created as well as making the API harder to program again.  We want a way to reuse the standard tree operations, without having to reimplement them for all trees, while at the same time, not having to use a standard tree class. Boost has tried to solve this type of problem for C++, but I am yet to see any effect for .NET to get it adapted.  50.1k5151 gold badges206206 silver badges308308 bronze badges  1  @Puchacz, sorry I am 15 years out of data on C++, have a look at Boost and Templates, after a few weak of study you may understand them. Power has high learning costs!!  I have added a complete solution and example using the NTree class above. I also added the "AddChild" method...  Using it  Should traverse maybe be a static method? It seems very awkward as a n instance method passing itself into itself  XML is the most mature and flexible solution when it comes to using trees and LINQ provides you with all the tools that you need. The configuration of your tree also gets much cleaner and user-friendly as you can simply use an XML file for the initialization.  If you need to work with objects, you can use XML serialization:  66422 gold badges88 silver badges1313 bronze badges  1  This is a good opportunity to practice French, but perhaps provide the corresponding English ones as well?  If you are going to display this tree on the GUI, you can use TreeView and TreeNode. (I suppose technically you can create a TreeNode without putting it on a GUI, but it does have more overhead than a simple homegrown TreeNode implementation.)  An explanation would be in order. E.g., what is the idea/gist? What is the purpose of SafeRelease()? E.g., why is SafeRelease() necessary? Thread safety? What is the thinking behind the decision to use and ? What is the minimum version of C# required? Please respond by editing (changing) your answer, not here in comments (without "Edit:", "Update:", or similar - the answer should appear as if it was written today).  In case you need a rooted tree data structure implementation that uses less memory, you can write your Node class as follows (C++ implementation):  15.3k4545 gold badges119119 silver badges193193 bronze badges  3  12  Posting C++ code on a question specifically for C# is not the best idea, Jake. Especially one that includes pointers. You do know that pointers are being hunted down mercilessly in C#, right? :p  @ThunderGr that is not fair. Answering in C# would have been better, but those C++ pointers can be understood by C#-speakers as references (they're less safe, ok). After David Boike, Aaron Gage, Ronnie Overby, Grzegorz Dev, Berezh and Erik Nagel all having sugested basically the same data structure with minor differences only in expression, Jake sugested breaking down the linked list yielding a simpler structures with only one type of node and sibling navigability. Don't express your dislike of C++ by down-voting a constructive answer.  @migle I did not downvote the answer(did not upvote either). And I do not dislike C++. I saw that the answer was downvoted without anyone suggesting anything to Jake about why and how he would improve his answer. It is not about "being better". The question is tagged for C# only. Posting answers in another language than the tag is not recommended and some people will downvote.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  