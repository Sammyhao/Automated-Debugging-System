 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Say we have a Map: , using returns a map iterator.  But I can't use or on that iterator and implementing a while loop on that iterator seems like an anti-pattern since ES6 offer functions like .  5,14688 gold badges5353 silver badges111111 bronze badges  6  Not out of the box, but you can use third party libraries like function which supports Map as well.  Converting the iterator to an array and map on it like works, but I think it's not the best way to do this.  which problem like you to solve with using an iterator while an array would fit better for using ?  8 Answers 8  The simplest and least performant way to do this is:  Better yet  takes any iterable or array-like thing and converts it into an array! As Daniel points out in the comments, we can add a mapping function to the conversion to remove an iteration and subsequently an intermediate array.  Using will move your performance from to as @hraban points out in the comments. Since is a , and they can't be infinite, we don't have to worry about an infinite sequence. For most instances, this will suffice.  There are a couple of other ways to loop through a map.  Using  Using  @ktilcu for an iterator: yes. a .map on an iterator can be thought of as a transform on the generator, which returns an iterator itself. popping one element calls the underlying iterator, transforms the element, and returns that.  The problem with this answer is it turns what could be an O(1) memory algorithm into an O(n) one, which is quite serious for larger datasets. Aside from, of course, requiring finite, non-streamable iterators. The title of the question is "Using map() on an iterator", I disagree that lazy and infinite sequences are not part of the question. That's precisely how people use iterators. The "map" was only an example ("Say.."). The good thing about this answer is its simplicity, which is very important.  @hraban Thanks for adding to this discussion. I can update the answer to include a few caveats just so future travelers have the info front and center. When it comes down to it we will often have to make the decision between simple and optimal performance. I will usually side with simpler (to debug, maintain, explain) over performance.  @ktilcu You can instead call (notice the mapping function is inside the ) and then no intermediate array is created (source). It still moves from O(1) to O(n), but at least iteration and mapping happen in just one full iteration.  You could define another iterator function to loop over this:  Now you might ask: why not just use instead? Because this will run through the entire iterator, save it to a (temporary) array, iterate it again and then do the mapping. If the list is huge (or even potentially infinite) this will lead to unnecessary memory usage.  Of course, if the list of items is fairly small, using should be more than sufficient.  it doesn't, that's the point. Using this you can create "data streams" by chaining an iterator source to a bunch of iterator transforms and finally a consumer sink. E.g. for streaming audio processing, working with huge files, aggregators on databases, etc.  I like this answer. Can anyone recommend a library that offers Array-like methods on iterables?  does not guarantee that underlying iterator will be properly closed ( called) unless the return value's next was called at least once. See: repeater.js.org/docs/safety  This simplest and most performant way is to use the second argument to to achieve this:  This approach works for any non-infinite iterable. And it avoids having to use a separate call to which would iterate through the iterable twice and be worse for performance.  Other answers here are... Weird. They seem to be re-implementing parts of the iteration protocol. You can just do this:  and if you want a concrete result just use the spread operator .  Works with all of iterables (Map, generator function, array) and async iterables.  "As always, Rust gets it right" sure... There's a standardization proposal for all sort of helper functions for the iterator interface github.com/tc39/proposal-iterator-helpers You can use it today with corejs by importing the fn from "core-js-pure/features/iterator" which returns the "new" iterator.  You could retrieve an iterator over the iterable, then return another iterator that calls the mapping callback function on each iterated element.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  