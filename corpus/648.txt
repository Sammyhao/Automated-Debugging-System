 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  In our project we are migrating to java 8 and we are testing the new features of it.  On my project I'm using Guava predicates and functions to filter and transform some collections using and .  On this migration I need to change for example guava code to java 8 changes. So, the changes I'm doing are the kind of:  To...  Using guava I was very confortable debugging the code since I could debug each transformation process but my concern is how to debug for example .  Using the debugger I can see some code like:  But it isn't as straighforward as Guava to debug the code, actually I couldn't find the transformation.  Is there a way to see this transformation or a way to easy debug this code?  EDIT: I've added answer from different comments and posted answers  Thanks to comment that answered my question, the approach of having lambda block allowed me to see the transformation process and debug what happened inside lambda body:  Thanks to the approach of having method references also allowed me to debug the transformation process:  Thanks to answer I noticed that my Eclipse doesn't show what it should and the usage of peek() helped to display results.  28.2k1212 gold badges7777 silver badges113113 bronze badges  2  You don’t need to declare your temporary variable as . A simple should do as well if you are ping an to an …  Also i add that there is the improved debugger in IntelliJ IDEA 14. Now we can debug the Lamdas.  6 Answers 6  I usually have no problem debugging lambda expressions while using Eclipse or IntelliJ IDEA. Just set a breakpoint and be sure not to inspect the whole lambda expression (inspect only the lambda body).  Another approach is to use to inspect the elements of the stream:  UPDATE:  I think you're getting confused because is an - in other words: it is a lazy operation which will be executed only after a was executed. So when you call the lambda body isn't being executed at the moment. You need to set a breakpoint and inspect it after a terminal operation was called (, in this case).  What makes it tricky here is that the call to map and the lambda expression are in one line so a line breakpoint will stop on two completely unrelated actions.  Inserting a line break right after would allow you to set a break point for the lambda expression only. And it’s not unusual that debuggers don’t show intermediate values of a statement. Changing the lambda to would allow you to inspect result. Again, insert line breaks appropriately when stepping line by line…  11.8k66 gold badges3535 silver badges4444 bronze badges  14  Thanks for the print screen. What version of Eclipse do you have or what did you do to get that dialog? I tried using and and get . Btw, peek is useful too but is prints all the values at once. I want to see each iteration process to check the transformation. Is it posible?  I'm using Eclipse Kepler SR2 (with Java 8 support installed from Eclipse's marketplace).  Are you using Eclipse too? Just set a breakpoint on line and press F8 multiple times.  @Fede: what makes it tricky here is that the call to and the lambda expression are in one line so a line breakpoint will stop on two completely unrelated actions. Inserting a line break right after would allow you to set a break point for the lambda expression only. And it’s not unusual that debuggers don’t show intermediate values of a statement. Changing the lambda to would allow you to inspect . Again, insert line breaks appropriately when stepping line by line…  @Marlon Bernardes: sure, you may add it to the answer as that’s the purpose of comments: helping to improve the content. Btw., I have edited the quoted text adding code formatting…  It extends the IDEA Debugger tool window by adding the Trace Current Stream Chain button, which becomes active when debugger stops inside of a chain of Stream API calls.  It has nice interface for working with separate streams operations and gives you opportunity to follow some values that u should debug.  You can launch it manually from the Debug window by clicking here:  Too bad this is not valid for optionals, which can grow up to the same complexity  Debugging lambdas also works well with NetBeans. I'm using NetBeans 8 and JDK 8u5.  If you set a breakpoint on a line where there's a lambda, you actually will hit once when the pipeline is set up, and then once for each stream element. Using your example, the first time you hit the breakpoint will be the call that's setting up the stream pipeline:  You can see the call stack and the local variables and parameter values for as you'd expect. If you continue stepping, the "same" breakpoint is hit again, except this time it's within the call to the lambda:  Note that this time the call stack is deep within the streams machinery, and the local variables are the locals of the lambda itself, not the enclosing method. (I've changed the values in the list to make this clear.)  As Marlon Bernardes pointed out (+1), you can use to inspect values as they go by in the pipeline. Be careful though if you're using this from a parallel stream. The values can be printed in an unpredictable order across different threads. If you're storing values in a debugging data structure from , that data structure will of course have to be thread-safe.  Finally, if you're doing a lot of debugging of lambdas (especially multi-line statement lambdas), it might be preferable to extract the lambda into a named method and then refer to it using a method reference. For example,  This might make it easier to see what's going on while you're debugging. In addition, extracting methods this way makes it easier to unit test. If your lambda is so complicated that you need to be single-stepping through it, you probably want to have a bunch of unit tests for it anyway.  118k3535 gold badges189189 silver badges248248 bronze badges  6  My problem was that I couldn't debug the lambda body but your approach of using method references helped me a lot with what I wanted. You could update your answer using Holger approach that also worked perfectly by adding in different lines and I could accept the answer since both answer were helpful. +1 of course.  @Fede Looks like the other answer got updated already, so no need to update mine. I hate multi-line lambdas anyway. :-)  @Stuart Marks: I prefer single line lambdas too. So usually I remove the line breaks after debugging ⟨which applies to other (ordinary) compound statements as well⟩.  @Fede No worries. It's your prerogative as the asker to accept whichever answer you prefer. Thanks for the +1.  I think that creating method references, besides making methods easier to unit tests also makes for a more readable code. Great answer! (+1)  Just to provide more updated details (Oct 2019), IntelliJ has added a pretty nice integration to debug this type of code that is extremely useful.  When we stop at a line that contains a lambda if we press F7 (step into) then IntelliJ will highlight what will be the snippet to debug. We can switch what chunk to debug with Tab and once we decided it then we click F7 again.  Here some screenshots to illustrate:  1- Press F7 (step into) key, will display the highlights (or selection mode)  2- Use Tab multiple times to select the snippet to debug  Debugging using IDE's are always-helpful, but the ideal way of debugging through each elements in a stream is to use peek() before a terminal method operation since Java Steams are lazily evaluated, so unless a terminal method is invoked, the respective stream will not be evaluated.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  