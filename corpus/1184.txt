 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have been asked this question and I think it's doable, However I am having a hard time coming up with an algorithm to do this. The restrictions is that you can not use any other data structure nor create another queue. Also you only can use enqueue, dequeue and peek (NOT a priority queue).  46911 gold badge77 silver badges1616 bronze badges  6  I'd be very surprised if you could do this. However, I think you need to be a little more specific about what kind of temporary memory you're allowed to use. I'm assuming you're only allowed memory?  There are no limits neither on time nor space complexities. However It's kind of implied that space complexity would be 1, Unless there is a recursive solution and counting StackFrames created per recursive call is considered adding to space complexity.  Does only return the head of the queue, or can you use it to find the value of any position the queue?  @3ashmawy: Stack frames created have to be counted, otherwise there is a very simple solution.  2 Answers 2  Ascending sort, runs in O(n^2) time, in space O(1) (i.e. the queue is O(n) space, and extra space required by the algorithm is O(1))  Explanation:  Essentially, we iterate through the queue n times, each time the iteration costs 2n.  On each iteration, we go through the entire queue and pick the minimum within the relevant number of items. So at first the relevant number of items is n, since we want the minimum of them all. The next iteration we want the minimum of the first n-1 items, and then n-2 items, etc. Since the algorithm will stack these minimums at the end.  Once we found the minimum, we need to iterate over the whole stack again in order to snatch it and stack it on the end.  The main idea here, is that a dequeue followed by an enqueue of that same element will allow us to iterate over the queue and check minimum/maximum while preserving order.  42.5k88 gold badges7676 silver badges7777 bronze badges  2  damn, i came up with the same solution and as i came back to post it, i saw your answer already posted...eeeeeeh..speed ;)...i upvoted you for the speed  @Suraj, if i got 1 rep. point for every time that happened to me, SO would have to invent a new data type to hold BigBigBigInt :)  82.1k1919 gold badges132132 silver badges136136 bronze badges  2  Thank you for the awesome answer it helped me a lot. Just one thing i noticed here is that there has been a typo in the above pseudo code. The line enqueue x (the last line) is having an extra space in the beginning. So it is appearing as though enqueue x should be repeated (n-1) times instead of n times.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  