 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  there is no problem, and everything is fine, until I tried to make a function to do the job like  well firstly you are much better using an ADT, ideally from a numerical library, like boost uBlas or NT2. (They'll provide matrix and vector types). However if you must roll you're own it's much better to have a single with number of elements and then calculate the offset like or whatever have you.  3 Answers 3  The problem is how you pass the parameter. After you called the method, the value of has not changed. You need to either return it or pass the parameter as a reference:  53.5k1111 gold badges113113 silver badges174174 bronze badges  6  it worked as you said, but i didn't get the point, why I need a reference when array is a pointer itself?  @dare When you pass the pointer, the argument is a copy of said pointer. You need the reference to tell the compiler that you want, well, a reference to the pointer that is passed. Otherwise the assignment within the function is applied to the copy (the parameter) and not to and when the function returns, the value of is thereby lost.  @dare Er, no, you don't pass the address. You pass a pointer to a pointer to , for short, which is not initialized and which is called . That pointer is copied into another which is called . You then assign a value to . When the function ends, the copy called is thrown away and is still not initialized. That's exactly why you need to pass a reference to the called , now the reference is called . When you assign something to , it assigns to the referenced pointer called .  @dare Actually, nio's solution is a preferable in your specific example (I gave him a +1), but you still need to understand how pointers, references, etc. work as this will be essential in the future.  I think the problem is that you need to pass pointer to your pointer.:) Something as  The pointer in your createArray function itself is a variable, that gets passed into createArray function as an argument but by value...  This means, that inside the is just a local variable that will be set to value of and will exist only inside the function. You will allocate the array of double* and store the pointer into the local variable, but once you leave the function, the value will be lost and you would have no way to determine where did you allocate everything. The will be left with previous value.  The simplest solution for you would be returning the pointer from createArray:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  