 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a program which prompts me the error in VS2010, in debug :  This gives me the function where a stack overflow likely occurs, but I can't visually see where the problem is.  Is there a general way to debug this error with VS2010? Would it be possible to indentify which write operation is overwritting the incorrect stack memory? thanks  7,05099 gold badges3737 silver badges7070 bronze badges  6  1  I don't know of any general ways off hand, but if you post your code we can help with this particular instance.  @Corey Ogburn : I am trying specifically to have answers that are not related my specific program. Besides I can't post it anyway  That's really NOT helping at all when you are trying to debug someone else's code. Besides are people supposed to be born knowing correct C++?  If you don't post the C++, how can anyone tell you what's wrong with it? The general technique is to write correct C++, and the specific solution is specific and you won't give enough information to find it!  By "general way" to debug the error I meant using the VS debugger to narrow down the source of the error. I don't exactly know how the debug build is able to notice that memory has been overwritten, but I'm assuming that having access to this kind of infos about the memory would help me narrow down the problem. I think it's a legit question  9 Answers 9  Is there a general way to debug this error with VS2010?  No, there isn't. What you have done is to somehow invoke undefined behavior. The reason these behaviors are undefined is that the general case is very hard to detect/diagnose. Sometimes it is provably impossible to do so.  There are however, a somewhat smallish number of things that typically cause your problem:  Improper handling of memory:  Deleting something twice,  Using the wrong type of deletion ( for something allocated with , etc.),  Accessing something after it's memory has been deleted.  a variable allocated with or a variable allocated with  something allocated with  an automatic storage variable  returning a local by reference  If it's not immediately clear, I'd get my hands on a memory debugger (I can think of Rational Purify for windows).  242k6060 gold badges438438 silver badges604604 bronze badges  6  alright, but is there a way to actually get from the VS debugger what operation caused the problem? I mean since visual is able to check some memory value to see if they were modified  @lezebulon you can set memory breakpoints, but they usually don't help for these issues...  @LuchianGrigore: wouldn't it is nice to set the pointer to null after 1st delete to prevent heap corruption caused by double delete?  @meet no, a corruption in this case is a good indication that there's a logic error in the code. Why would you want a double delete? And if you don't want it, why is there one in the code? I'd like the program to crash so I know there's something wrong.  This message can also be due to an array bounds violation. Make sure that your function (and every function it calls, especially member functions for stack-based objects) is obeying the bounds of any arrays that may be used.  Actually what you see is quite informative, you should check in near x variable location for any activity that might cause this error.  Below is how you can reproduce such exception:  will generate (VS2010):  Run-Time Check Failure #2 - Stack around the variable 'buffer1' was corrupted.  obviously memset has written 1 char more than it should. VS with option \GS allows to detect such buffer overflows (which you have enabled), for more on that read here: http://msdn.microsoft.com/en-us/library/Aa290051.  You can for example use debuger and step throught you code, each time watch at contents of your variable, how they change. You can also try luck with data breakpoints, you set breakpoint when some memory location changes and debugger stops at that moment,possibly showing you callstack where problem is located. But this actually might not work with \GS flag.  For detecting heap overflows you can use gflags tool.  I was puzzled by this error for hours, I know the possible causes, and they are already mentioned in the previous answers, but I don't allocate memory, don't access array elements, don't return pointers to local variables...  Then finally found the source of the problem:  The intent was to increment the pointed value. But due to the precedence comes first, moving the pointer forward then does nothing, then writing to will be corrupt the stack canary if the parameter comes from the stack, making VS complain.  Set a breakpoint at a location where you can see the (correct) value of the variable in question, but before the error happens. You will need the memory address of the variable whose stack is being corrupted. Sometimes I have to add a line of code in order for the debugger to give me the address easily (int *x = &y)  At this point you can set a memory breakpoint (Debug->New Breakpoint->New Data Breakpoint)  Hit Play and the debugger should stop when the memory is written to. Look up the stack (mine usually breaks in some assembly code) to see whats being called.  I usually follow the variable before the complaining variable which usually helps me get the problem. But this can sometime be very complex with no clue as you have seen it. You could enable Debug menu >> Exceptions and tick the 'Win32 exceptions" to catch all exceptions. This will still not catch this exceptions but it could catch something else which could indirectly point to the problem.  In my case it was caused by library I was using. It turnout the header file I was including in my project didn't quite match the actual header file in that library (by one line).  There is a different error which is also related:  0xC015000F: The activation context being deactivated is not the most recently activated one.  When I got tired of getting the mysterious stack corrupted message on my computer with no debugging information, I tried my project on another computer and it was giving me the above message instead. With the new exception I was able to work my way out.  I encountered this when I made a pointer array of 13 items, then trying to set the 14th item. Changing the array to 14 items solved the problem. Hope this helps some people ^_^  One relatively common source of "Stack around the variable 'x' was corrupted" problem is wrong casting. It is sometimes hard to spot. Here is an example of a function where such problem occurs and the fix. In the function I want to assign some value to a variable. The variable is located at the memory address passed as argument to the function:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  