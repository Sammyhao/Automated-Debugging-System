 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Coming from a scripting language background with some C, trying to 'learn' Rust leads me to question my competence. I'm trying to figure out how to change an owned pointer, and struggling to do it.  Besides copying in from the extra libs, I can't figure out the recursion I need on a binary tree. Particularly, I don't know how to swap out the pointer branches. Whereas with a linked list I can cheat and use a temporary vector to return a new list, or prepend a new Cons(value, ~Cons) to the list head, branches have got me boggled.  The compiler throws 11 errors on this, and when I type it out, it feels like pseudocode. I'm frustrated because I feel okay implementing a tree with C pointers.  What I'm trying to do is update the pointers in-place--this is part of the reason I'm using them, right?--rather than copying the entire tree every time I want to make a change. But I don't even know how to get to them.  I'm not sure how I'd go about doing this with structs rather than enums. I've looked at the Treemap lib, but it seems to introduce too much complexity for what I want to accomplish right now, which is proof of concept--I might be trying to run when I should crawl, though!  1 Answer 1  I believe that you would do better with a different data representation:  This will be easier to work with and is slightly more efficient ( can be represented as a nullable pointer, while your current solution has a leaf node still requiring a pointer lookup to check if it's ).  You don't need to implement your method; it can be derived, an implementation of the trait, by putting immediately before the struct.  Of your method, you must understand that is a method bound to . When you call , that is invalid, for you are passing two arguments to one expecting one. What you meant was .  I've restructured the method significantly; here's the complete code that I would write:  The match could also be expanded to the following, if you desired:  If there's anything you don't understand in this code, just holler and I'll explain it.  77.1k2020 gold badges194194 silver badges203203 bronze badges  2  This is much clearer to read than my initial efforts! But those in the throw at me in the linter and on compilation in 0.9. If i move the up into the parameters, I end up with an .  Sorry, they should have been . I got it completely back to front for some reason!  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  