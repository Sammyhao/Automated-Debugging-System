 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I want to do BFS on a 2D array, and each of the cell can be represented as . I use to keep track of cells at each level, but I find no clever way to keep track of the depth. (I don't want to define another struct to record the depth at each level)  I am wondering if there's a similar elegant solution in C++. For now, I can think of the following ways:  1) count the number of cells() at each level, and decrement the count after each . Once , increase the depth.  2) use two and replace the old one with the new one at the end of each level. Increase the depth at the end of each iteration.  3) maybe stores a pointer to in the queue and use to separate levels?  You'd just use a "marker value". Alternatively, you could use a (assuming something like C++17 is available)  2 Answers 2  (1) can work, but it's better/easier to set count=queue.size(), and decrement it each time you pop. When it gets to 0, increase the depth and set count=queue.size() again.  (2) works fine. Use std::swap to switch queues. This is what I usually do, because I like the outer you can also use vectors instead of real queues, because you're not pushing and popping on the same object. The 2nd level loop is just an iteration through a vector.  (3) works, but it's quite wasteful. Other kinds of marker values can work, but I think the (1) above is better than this in all cases.  In cases where you prefer to use a std::deque instead of two vectors, I like to write it like this:  ... which is pretty much like my (1) above, but I get my nice depth loop and by writing the loop condition on , we can avoid any other inner loop checks to  A solution similar in spirit to inserting a null into the queue is to just insert a sentinel value that can't possibly occur as a cell. E.g.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  