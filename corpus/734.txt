 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  i do not understand this BFS code. I've read the algorithm and understand the algorithm. I've also solved graphical problems on BFS algorithm but i cant get my head around this code.  i do not understand what is 'cur.first-1' and 'cur.second'  also i didn't understand the conditions of if statements '(cur.first+1 < 4)' and the logic behind using their statements. this is code written for finding a path between two points in a grid.  What don't you understand? is defined above where it's referenced. There's nothing particularly complex going on. Stack Overflow can't explain everything to you from first principles.  i did not understand this ' pair<int,int> cur = queue.front();' because i mostly work with arduino ide so this is new to me  Perhaps read some basic tutorials on C++? You should be able to recognise that it's a variable declaration, even if you don't understand the type. Google "C++ pair" and "C++ queue" to get an understanding of what first, second, pop() and front() do -- or read a little bit on basic data structures (which most places will cover before going into algorithms).  I'm not saying this to be mean, btw, but Stack Overflow doesn't (as you can see) deal with these sorts of questions well. It's not the purpose of this site.  Also notice the that lets the programmer leave off the . That is poor style for many reasons and you shouldn't do it yourself, but should understand when others do.  so is a type. Objects of that type consist of two s the first of which is named and the second named . So it is a type very similar to:  If had been an object of the above kind of , I assume you would understand what and and if you knew what is then you would know what is (no magic meaning, just computing a value one less than the value of  And, yes, that code is finding a path between two points on a grid.  The programmer chose to represent a position as a , which is a bit lazy. Then compounded that by failing to comment the fact that the is used to hold  So all those and checks are ugly ways of testing whether a specific neighbor of the current really exists (as opposed to being off the edge of the map).  One of those is used to hold all the reachable pairs for which the distance from has been computed but for which the distance from of some neighbor might not have been computed. So the basic operation is take one of those from one end of the queue; check all of its neighbors; and for any neighbor whose distance is newly discovered, insert in the other end of the queue.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  