 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  How does Java 8's HashMap degenerate to balanced trees when many keys have the same hash code? I read that keys should implement to define an ordering. How does HashMap combine hashing and natural ordering to implement the trees? What about classes that do not implement , or when multiple, non-mutually-comparable implementations are keys in the same map?  3 Answers 3  The implementation notes comment in HashMap is a better description of HashMap's operation than I could write myself. The relevant parts for understanding the tree nodes and their ordering are:  This map usually acts as a binned (bucketed) hash table, but when bins get too large, they are transformed into bins of TreeNodes, each structured similarly to those in java.util.TreeMap. [...] Bins of TreeNodes may be traversed and used like any others, but additionally support faster lookup when overpopulated. [...]  Tree bins (i.e., bins whose elements are all TreeNodes) are ordered primarily by hashCode, but in the case of ties, if two elements are of the same "class C implements Comparable" type then their compareTo method is used for ordering. (We conservatively check generic types via reflection to validate this -- see method comparableClassFor). The added complexity of tree bins is worthwhile in providing worst-case O(log n) operations when keys either have distinct hashes or are orderable, Thus, performance degrades gracefully under accidental or malicious usages in which hashCode() methods return values that are poorly distributed, as well as those in which many keys share a hashCode, so long as they are also Comparable. (If neither of these apply, we may waste about a factor of two in time and space compared to taking no precautions. But the only known cases stem from poor user programming practices that are already so slow that this makes little difference.)  When two objects have equal hash codes but are not mutually comparable, method is invoked to break the tie, first by string comparison on (!), then by comparing .  The actual tree building starts in , beginning when a bin reaches (currently 8), assuming the hash table has at least capacity (currently 64). It's a mostly-normal red-black tree implementation (crediting CLR), with some complications to support traversal in the same way as hash bins (e.g., ).  12.5k1616 gold badges7272 silver badges8989 bronze badges  10  1  But if hashcode() is not being overridden in object then it will anyway will call System.identityHashCode() to find hashbucket. So what will happen in case key doesn't override hashcode() and tieBreakOrder been called? or will it ever be called ?  @RohitSachan If the key type is using the default identity semantics, it's highly unlikely that any bucket will become full enough to convert to a tree bucket, because identity hash codes are well-distributed. But there's no special handling for that case, so yes, will still call for the ordering.  @Rohit Sachan: if every optimization attempt fails, it has to resort to the same linked list behavior known from versions prior to Java 8.  @NateGlenn seems to look both ways in the non-comparable case (the last else-if and else), but I'd need to step through in a debugger to be sure. That raises the question of why an order is necessary at all in that case, though.  @NateGlenn Speculation: String is the most common JDK-controlled type. Each additional class check gives less benefit in the special cases and increases the cost in the general case, and maybe just String is the optimal tradeoff. Note that String is final, so it's not for subclass defense. It's probably to prevent DoS attacks based on hash collisions; the String hashCode has not always been the best. There was at some point a big list of strings that hashed to MIN_VALUE, including "polygenelubricants". I imagine collisions at other values are also possible.  It does not actually require the implementation of , but can use it if available (see for instance the find method)  has it's own hash method that applies a supplemental 2 bit lenght hash to the objects inside in order to avoid this problems:  Applies a supplemental hash function to a given hashCode, which defends against poor quality hash functions. This is critical because HashMap uses power-of-two length hash tables, that otherwise encounter collisions for hashCodes that do not differ in lower bits. Note: Null keys always map to hash 0, thus index 0.  25.6k77 gold badges6565 silver badges103103 bronze badges  2  2  Actually, no. The function reduces but does not eliminate collisions, so still has to manage keys with the same hash value.  You have linked to an OLD version of the source code. Look at the Java 8 code and you will see that it no longer does the supplemental rehashing. That method no longer exists.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  