 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm working on a genetic algorithm and I wanted to try putting some functions into cuda to see if I can achieve a worthwhile speed-up.  The data structure at the moment is a tree of nodes, where function nodes contain a vector of pointers to any child nodes they may have. I believe I will need to collapse this tree into a linked list, probably a vector of the nodes (not pointers). These nodes would contain a list of integer indexes to their child nodes. In this way I can pass by value the structure into cuda.  It could be flattened quite easily, but I'm worried that making these changes is going to require some custom functions and could be more MUCH computationally expensive than the node->childNode[x] style structure.  For example, if I want to replace the divide and its sub-structure with the number 7, I need to:  pop members 4,5  Change the divide at index 3 to be the number 7.  Update the root function so that the reference to its second child is now 4.  Update the multiply function, now at 4, that is child nodes are now at 5 and 6  There must be a better way? I'm not a c++ expert so I'm looking for advice and code examples would be very helpful!  1,52311 gold badge1818 silver badges3535 bronze badges  3  Linked list in C++ without pointer? I think pointer is usually useful in that case.  Agreed, but I believe the pointers will not be valid once passed to GPU Memory. Which is why I want to collapse into a vector of objects  As long as you are not concerned about dynamically growing your data structure, you can always replace pointers with indexes into an array.  1 Answer 1  I suggest keeping your tree structure exactly as-is, except replacing your pointers with indices into an array, as tera says.  What array am I talking about? You'll need to set up a memory pool (aka fixed-size-block allocator). You can google this. The pool is basically an array of whatever your node type is. You should choose a maximum size in advance (the maximum number of nodes you'll ever need in your tree). Then, you'll never have to resize/grow this array. Your memory pool class will have allocate and free methods, but these operate on indices into the array, not pointers.  With this approach, you'll be able to do the tree modifications you mentioned very cheaply--with the memory pool, allocating and deleting items is trivially cheap, and you'll never be copying/moving nodes around in memory.  You'll pass the root of your tree (again, just an index, not a pointer) to the GPU, along with the memory pool's array.  Hi Eric, thanks for the response. This sounds promising, I'll try this out later today  I've googled a fair bit, and I'm fairly sure this is the right answer, but I can't find an easy to follow implementation of this. I've settled on a vector for the time being, as the majority of work is insertion to the end. I'm going to re-visit in a few days, if you know of any good resources please let me know  Here's an implementation. It uses 1 stl vector and 1 c-style array. It's basically what I was describing. The constructor parameter "nSize" is the maximum array size I talked about: codeproject.com/Articles/359640/…  Went for the first option. Works very nicely and the code feels a LOT cleaner. I've been able to drop the vector per object I was going to try and hammer into Cuda. + Even with the pool allocation, one loop is about 10% faster, so I imagine I am also going to see a good speed-up once the program is running across many loops.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  