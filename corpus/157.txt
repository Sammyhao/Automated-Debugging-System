 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Can anybody give a link for a simple explanation on BFS and DFS with its implementation?  A breadth first search visits all of a node's children before visiting their children. Here's the pseudocode and the solution for the above structure:  A depth first search visits the lowest level (deepest children) of the tree first instead. There are two types of depth first search: pre-order and post-order. This just differentiates between when you add the node to the output (when you visit it vs leave it).  is Enqueue root node, is Dequeue and output. So after dequeueing the enqueued root node, will the queue not be empty?  It may be a little confusing because E is both a child of A and F but it helps illustrate the depth in a depth first search. A depth first search searches the tree going as deep (hence the term depth) as it can first. So the traversal left to right would be A, B, D, F, E, C, G.  A breadth first search evaluates all the children first before proceeding to the children of the children. So the same tree would go A, B, C, E, D, F, G.  @ThomasEding you are right that it is not a tree but wrong in saying that it is a directed acyclic graph*(DAG). In fact if it would have been a *DAG it would have been a tree. What he describes here is actually a undirected cyclic graph.  BFS is an uninformed search method that aims to expand and examine all nodes of a graph or combination of sequences by systematically searching through every solution. In other words, it exhaustively searches the entire graph or sequence without considering the goal until it finds it.  Formally, DFS is an uninformed search that progresses by expanding the first child node of the search tree that appears and thus going deeper and deeper until a goal node is found, or until it hits a node that has no children. Then the search backtracks, returning to the most recent node it hasn't finished exploring  Not only do they contain good explanations on how they are implemented in applications but also some algorithm pseudo code.  get a new queue ...initalize it with the root node .... loop through the entire queue and keep removing an item from the queue and printing it out (or saving it etc) and check if the same item has any children , if so push them onto the queue and continue in the loop until you traverse the entire segment(graph)...  BFS and DFS are applicable to all kinds of graphs. I explain it for binary tree only. BFS visit each node top to bottom, left to right. For example for this:  BFS gives us: 1 7 9 8 2 3. DFS visits depth of each branch first. Then, it comes back to its parents. You can follow this informal rule. First left child then right child then parent. But, you need to start from the depth of each branch. For example, here you start from 8, since there is no left child for 7. Then, you visit parent 7. Then, 1 parent of 7 will be visited. Then, you go to right branch. But, this time there is 2 as the left most child. So, you visit 2 (left child) then, right child 3 then, 9 their parents. So, DFS gives us 8 7 1 2 9 3. This is the implementation:  First of all, BFS and DFS are two ways to implement binary tree traversal. Breadth First means level order traversal. Depth First has three ways to implemnt -- , , .  Preorder:  Level Order Traversal Time Complexity O(n)- Number of times each node is visited is 1 only, means total is n times.  Space Complexity- Best Case: Tree only left nodes, is O(1) Average Case: Perfect binary tree is example, n/2 number of nodes, O(n)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  