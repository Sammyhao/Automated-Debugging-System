 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I cannot post the source code, but I can explain parts of it on a conceptual level and hope I can be helped to understand why my solution works.  I have an application that has 3 threads: A, B and C (main thread).  Thread B has a list of Foo objects.  Each Foo object contains exactly 1 Mutex object, which is a wrapper over recursive mutexes, and a bunch of methods used to set and get various attributes in a synchronizing manner, using the Mutex and 2 of the methods are used to set and get markedForDelete attribute.  All that Thread B does is iterate over said list using iterators, and delete Foo objects marked for delete, or execute other instructions otherwise. It is the only thread in charge with destruction of Foo objects using basic code similar to this:  Thread A and C will create and add Foo objects to list and they can also mark them to be deleted and it is done in a synchronized manner using other mutexes.  Thread C will occasionally be closed and always afterwards be restarted, but in a controlled manner and never during memory allocation / deallocation and will always release locked mutexes.  The problem is that when Foo's Mutex is allocated in heap memory (via the operator) the application will reach a deadlock state where Thread C wants to access resources locked by Thread A and the former wants to access a resource locked by Thread B and Thread B is blocked by Foo's Mutex, which is locked, but has no owner. Using GDB I found that the Mutex's pthread_mutex_t owner value is 0 or a negative number, not corresponding to the id of any threads. The blocking end of the deadlock occurs at this piece of code in Thread B: .  My very intuitive solution is to allocate Foo's Mutex on the stack and it works without any other modifications ! The application does not ever reach a deadlock state this way.  The compilation is done using g++ 4.8 with the O2 flag set.  I know it's not much to go on, but can someone help me understand why my solution works ?  I know it's not much to go on, but can someone help me understand why my solution works -- How will you confirm it actually does work and will never fail? Running a few times is not proof enough. With MT issues, unless you have a concrete reason yourself as to why this fix works, assume it doesn't really work.  @PaulMcKenzie I did not just run it a few times, I did for a few uninterrupted hours at a time, every day for about a week. With heap-allocated Mutexes the deadlock occurs in a matter of seconds every single time.  Well, that's good, at least you don't have to wait for a day. Use your debugger's data breakpoint feature to get a debugger at the moment the mutex state gets corrupted.  "I cannot post the source code" - That's a great way to start a question on Stackoverflow...  @Catalin make a minimal example you CAN post here. Chances are that breaking down your issue more will give you some hints as to what to do next. It's great that you respect your NDA, but without code, the best you'll get here is conjectures and guesses...  1 Answer 1  I certainly believe, it has nothing to do with heap bugs. Most likely, you are not initializing your mutex properly. Are you calling pthread_mutex_initialize?  59.4k55 gold badges6868 silver badges122122 bronze badges  3  Yes, pthread_mutex_init is called after setting its type to PTHREAD_MUTEX_RECURSIVE_NP. The mutex wrapper is also used successfully by nearly every other class in the project - be it heap or stack allocated.  Cataling, I am sure the initialization is done incorrectly. Since you are not posting the code, there is nothing else I can say.  Since the question has been but on hold and I found the answer but still don't have the code for it, I won't edit the question and just leave this comment here. I wasn't initializing pthread_mutexattr_t before using it. Allocating on heap would mean its internal was filled with garbage data, so the values for would differ wildly. By allocating it on stack, the mutexattr struct probably got filled with values of 0 so it had an initialization of sorts. Your answer made me quadruple check inits, which lead to the actual solution, so thank you.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  