 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  As I know that iterator in the is thread-safe due to snapshot reference to the copy of at the time of iterator is created, and in this all mutative operations are implemented by making a fresh copy of the underlying array so they do not affect the copy referred by snapshot reference and same for ,  But struggling in case of , so please share your views how the iterator is fail-safe in case of  6 Answers 6  Your question is slightly ambiguous - you mention in the title but in the body. I am assuming you mean thread-safe.  ... Retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove). Retrievals reflect the results of the most recently completed update operations holding upon their onset. For aggregate operations such as putAll and clear, concurrent retrievals may reflect insertion or removal of only some entries. Similarly, Iterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration. They do not throw java.util.ConcurrentModificationException.  so iteration is thread safe but they define the contract as Iterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration.  Despite javadoc, ConcurrentHashMap Iterator does NOT return a snapshot, it operates on live concurrent hash table handling all concurrency cases optimistically, in the same way all lock-free data structures do.  Basically, it contains reference to current hashtable, bin index in that hashtable and last returned Node. Here are some tricks it uses to operate on concurrent hash table w/o locking:  If node it currently holds have been removed, jump to next bin (by incrementing index)  Optimistic 'locking' (i.e. just try again) for cases when hash table can be in inconsistent state  Special type of node (ForwardingNode) to detect rehash  3,40922 gold badges1818 silver badges2929 bronze badges  1  Very interesting answer. Thank you. Btw: this thread shows that the javadoc for ConcurrentHashMap iterators is not sufficient. It is not clear (basing on official documentation) how this is exactly working.  From the docs: "Similarly, Iterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration."  The iterators generated by point to the hash table array as of when the iterator was created, so they don't account for updates that cause the hash table to be resized, which is allowed by their spec. Iterating through the hash buckets is safe because the hash bucket references are .  Well, all a hash map is (at least, conceptually, the real implementation is a bit more complicated) is an array of linked lists. A fail safe (not thread safe) iterator can be implemented very trivially by traversing the linked lists one-by-one, from first node to last. Something like this would work:  This is not really specific to , they could have implemented it this way for regular maps as well, but chose not to. Why? Well, because a "regular" map is not thread safe, modifying it concurrently is not a good idea, so, if that happens, chances are it is a mistake rather than an intentional occurrence, so, it is better to "fail fast", as soon as such situation is detected rather than ignore it, and proceed, risking potential subtle and hard to diagnose inconsistencies in the future.  If you ask me if I agree with this last statement, the answer is a resounding "no" :) But apparently, there were enough people among java designers, who did, at least back when this decision was made.  From Code Comments within ConcurrentHashMap.java source.  The basic strategy is to subdivide the table among Segments, each of which itself is a concurrently readable hash table.  Iterator of ConcurrentHashMap is fail-safe, it means that it doesn’t throw even if underlying is modified once Iteration begins. Looking at the java code it shows that its iterator extends (line 1251) which doesn't have any synchronization but it allows multiple iterator to read the map concurrently and the map can be changed meanwhile without throwing any exception and without any guarantee that guarantees the new element which is added will be returned. So you can say that ConcurrentHashMap is fail-safe!  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  