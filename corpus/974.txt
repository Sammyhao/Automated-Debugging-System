 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  But is it possible to overflow scanf("%8s", string)? 8 is just an example.  I know "%8s" works like a delimit, but I also notice when I input string longer than 8 chars, the program will terminate due to:  * stack smashing detected *: ./a.out terminated  ======= Backtrace: =========  ...  Obviously there's a flag that detects stack smashing turned on by GCC by default. Since this is a stack smashing, then my guess is that it is still possible to overflow and execute arbitrary code.  Contrary to normal overflow that mangles the caller of scanf("%s"), if scanf("%8s") can overflow, it will overflow within scanf function so that when scanf try to return, control is gained.  But scanf is a syscall that requires mode-switch (switching from user mode into kernel mode), and internally it will call stuff like read to the stdin etc. So not sure if we can overflow in kernel mode or something..  Comments are welcome!!  UPDATE >>  char string[9] is assumed in the above example. char string[8] in following real code.  The question is really about the seeming conflicting story between safe scanf("%8s") and GCC abortion due to stack smashing.  Simplified code:  Note:  foo is called by someone else.  Though string is 8 bytes in real code with "%8s", I don't think this lead to smashing.  1,61033 gold badges1515 silver badges2323 bronze badges  5  scanf is a runtime library function—no mode switch is necessary since it operates in user space, unless it has to request buffer filling, in which case it would call read or fread.  as noted several times in the answers, a nul byte is added, so you need a 9 character buffer to accept up to 8 characters of input.  As plenty of people have pointed out, your assumption in "Note 2." is wrong. That example allows a single byte of overflow, which is what gcc is detecting.  you guys are right. I have tested it with a even simpler program but it somehow didn't crash the last time I tried. Now when I enter "12345678" for string[8] and scanf(%8s) it crashes because of stack smashing! So here's the lesson learned. Smashing doesn't necessarily mean there's a stack overflow attack.  Even though the buffer happens to be on the stack in this case, the programming bug is a buffer overflow not a stack overflow. I retagged the question accordingly.  4 Answers 4  Each directive is composed of one of the following...An optional non-zero decimal integer that specifies the maximum field width.  s Matches a sequence of bytes that are not white-space characters. The application shall ensure that the corresponding argument is a pointer to the initial byte of an array of char, signed char, or unsigned char large enough to accept the sequence and a terminating null character code, which shall be added automatically.  @Figo: somehow you are not understanding. "%8s" will store up to 9 bytes, so you need a nine character array.  Don't ever use (or for that matter) if you want your input to be robust.  You should be using (or a similarly "protected from buffer overflow" variant) then use on that.  The main problem with and is that your file pointer can end up in an indeterminate position if the line is not of the expected format (i.e., if the fails). With the method, it's a lot easier to guarantee that you're on a line boundary, without having to use and to move around the file.  Regarding your specific query about whether the buffer will overflow, the C standard has this to say:  ... the corresponding argument shall be a pointer to the initial element of a character array large enough to accept the sequence and a terminating null character, which will be added automatically.  So, for a format, you need a 9-character array.  I suspect you have some other problem in your code. With a test program:  I get:  When I change that same program to use , I get (for exactly the same input):  799k218218 gold badges15121512 silver badges18741874 bronze badges  5  1  Yeah, I know. But right now I'm interested in knowing if scanf(%8s) has the same problem as scanf, as GCC is telling me there's still a stack smashing happening!  @ysth: (1) Get your input as lines. (2) Ensure you get whole lines (\n char at end), error otherwise with "line too long". (3) Use sscanf on line - you can do this as many times as you want on the line without worrying about the underlying file.  I also test a similar simplied code like you did and GCC won't complain about stack smashing.. I have posted orig code and the thing is at run time there will be GCC complain when I input 12345678 (Note in real code char string[8]).  @Figo, you need a 9-character array to store an 8-character string. That's because an 8-character string consist of the 8 characters (obviously) and a null terminator character (not so obvious). If you change it to char string[9], you shouldn't have any problems.  if string is allocated for less then 8 charters it will certainly overwrite the buffer also scanf will not append a null terminator. But as long as you have enough space in string for your value you should not get an overwright.  Actually I think scanf will put a '\0' at the end. C standard says "a terminating null character, which will be added automatically.", also quoted by paxdiablo  If you don't have a space for the null, it will put it there regardless (overwriting some other part of the stack if neccessary).  As ysth pointed out, the array should be able to contain the string and the terminating null-character, so using an 8-byte array (especially if it's allocated on the stack, as it is in your code) is very likely to mess it up.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  