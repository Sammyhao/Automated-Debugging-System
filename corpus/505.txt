 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  How can I retrieve the max and min element from a queue at any time in 0(1) time complexity? Earlier I was using Collections.max and min to find the elements but that would be 0(n).  You can create special field that will store max/min whatever you update your queue and read it when needed.  Search for min stack O(1). Then search for implement queue using 2 stacks. Combine them and you will have min Queue O(1), O(1) average when pop.  7 Answers 7  There exist such a structure that acts like a queue but lets you retrieve min/max value in constant time, actually not strictly constant, it is amortized constant time (named min/max queue as you could guess). There are two ways of implementing it - using two stacks or using a queue and a deque.  Deque implementation looks more less like this (language agnostic):  so we have a deque of max elements, the one on the front is the desired max, and a standard queue.  Push operation  If the queue is empty, just push the element on both, the queue and the deque.  If the queue is not empty, push the element on the queue, going from the back of the deque delete all elements that are strictly less than the one we are now pushing (they will surly not be the max, since the pushed element is larger and will last on the queue for longer) and push the current element on the back of the deque  Remove operation  If the front of the deque is equal to the front of the queue then pop both (deque from the front)  If the front of the deque is not equal to the front of the queue then pop just the queue, the poped element surely is not the largest one.  Get max  It is just the first element of the deque.  (lots of arguments should be added to make it clear why it works, but the second version presented below may be the answer to this necessity)  The Stack implementation is quite similar, I think it may be a bit longer to implement but perhaps easier to grasp. The first thing to note is that it is easy to store the maximal element at the stack - easy exercise (for the lazy ones - Stack with find-min/find-max more efficient than O(n)?). The second part, perhaps a bit tricky if seen the first time, is that it is quite easy to implement a queue using two stacks, it can be found here - How to implement a queue using two stacks? . And that is basically it - if we can get the maximal element of both of the stacks we can get the maximal element of the whole queue (taking maximum is associative or something like that if you want a more formal argument, but I bet you don't, it is really obvious).  The min versions is done analogically.  Everything may also be done using a set (or something of it's kind) in O(nlogn) time but it is pointless as the constant in O(n) is really small and it should be much faster, yet easy to implement.  NON-INTERESTING parts from the first version:  Hope I helped a little bit. And hope that didn't say anything wrong. Can give a simple implementation in C++/C if required. Would be grateful for any feedback on the form as it is my first post of this type anywhere :) (and English is not my native language). Also some confirmation on the correctness would be great.  EDIT: as this answer got me some points I felt obliged to clean it up a bit, also extending it a bit.  You only have 2 ways to get O(1) for a min/max operation:  if the structure is sorted and you know where the max / min is located  if the structure is not sorted and only allows insertion: you can recalculate the min / max every time you insert an item and store the value separately  if the structure is not sorted and allows insertions and removals: I don't think you can do better than O(n), unless you use more than one collection (but that solution does not support removal of any elements, only head / tail elements, which should be the case with a queue).  305k7272 gold badges635635 silver badges752752 bronze badges  3  1  I deleted my answer since I'm pretty sure it only works for stacks, and not queues.  Search for min stack O(1). Then search for implement queue using 2 stacks. Combine them and you will have min Queue O(1), O(1) average when pop.  I suspect you are trying to implement what a PriorityQueue does. This is a sorted queue which O(log N) to get the lowest value. I not sure why you would want to largest value as a queue only has one end.  Interesting, so you have using off heap memory? (arrays and objects are on the heap)  What i meant to say was that to implement a PQ , i would need to use min-heap / max-heap , heapify operations ! That is , heap( as a data structure).  Basically, it's a heap which has it's max heap property at even levels, and min heap property at odd levels.  It has both O(1) MIN() and O(1) MAX() operations. However it's rather tricky to iterate, but it works and meets your requirements.  I am posting the complete code here to find MIN and MAX in queue in a constant time. Please feel free to contact me if you have any doubt.  I would store two fields minIndex and maxIndex that will store index positions in your data structure for the minimum and maximum value respectively.  When new elements are added to the queue, check for two things:  The element is less than the current minimum element at the minIndex position; if so update the value of minIndex after insertion.  The element is greater than the current maximum element at the maxIndex position and update the reference accordingly.  This will give you a O(1) asymptote for the current min and max value.  Ah, yeah; so it is best to create two stack in addition, one for minimum values and the other for maximum values.  Actually, that won't help you, either. When you add at one end and remove at the other, the queue as a whole transitions between disparate states that are not equal to any previous state. Therefore the history approach is useless.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  