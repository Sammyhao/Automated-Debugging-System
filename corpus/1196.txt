 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have the following function to sort an unordered array to having even numbers in the front and odd numbers in the back. Is there a way to get it done without using any loops?  44.5k77 gold badges5757 silver badges6767 bronze badges  6  I don't think the structure of merge sort is the right kind of structure for this problem. This recurses in towards the middle, there's no divide and conquer involved, just pure iterative recursion.  Charles: How is splitting the array in the middle, using recursion on both halves, and then merging them, not a divide-and-conquer algorithm?  I was saying that this problem doesn't require divide and conquer (which merge sort IS), divide and conquer problems are usually solved in O(nlogn), where as this one can be done in O(n)  Oh and I'm assuming that it doesn't require numbers to be sorted among themselves, just the even half on the front (not necessarily sorted) and odd ones in the back.  When you do recursion, you have a base step and a recursive step.  In this case, the base condition is when front == back, because you start from the edges and end up in the middle. When you get to the middle you know it's done.  Before you do the recursive step, you have to do a bit of sorting. You're only doing the sorting one step at a time, so only deal with the elements at array[front] and array[back] for now. After you arrange those into the right place, do a recursive call.  You'll end up with something like this:  It's untested and probably doesn't work for edge conditions, but it's a good start :)  May I recommend this Python snippet to inspire high level thinking?  I think one needs to build a comparator function that returns negative, 0, and positive and use that.  141k3434 gold badges237237 silver badges450450 bronze badges  1  Hmm... If you call it with record=false, it does nothing. If you call it with recursed=true, it recurses forever.  The following should be instructive. It's a recursive solution that rearranges the even numbers in front and odd numbers in the back, but doesn't do any ordering beyond that.  I think the ternary operator makes the recursion flow more naturally, but if you're not that comfortable with how it works, you can just use traditional .  @Stephen: I disagree. There's a reason why the ternary operator is right-associative, and it's to allow this kind of expression-level like constructs.  I agree with Stephen. Just because you can write it without parentheses doesn't mean you should. The expression x ^ a + b ^ c + d is perfectly well-defined, but those who don't know the precedence rules by heart will be incredibly confused.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  