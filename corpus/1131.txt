 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  There are N users registered on a website CuteKittens.com. Each of them have a unique password represented by pass[1], pass[2], ..., pass[N]. As this a very lovely site, many people want to access those awesomely cute pics of the kittens. But the adamant admin doesn't want this site to be available for general public. So only those people who have passwords can access it.  Yu being an awesome hacker finds a loophole in their password verification system. A string which is concatenation of one or more passwords, in any order, is also accepted by the password verification system. Any password can appear 0 or more times in that string. He has access to each of the N passwords, and also have a string loginAttempt, he has to tell whether this string be accepted by the password verification system of the website.  For example, if there are 3 users with password {"abra", "ka", "dabra"}, then some of the valid combinations are "abra" (pass[1]), "kaabra" (pass[2]+pass[1]), "kadabraka" (pass[2]+pass[3]+pass[2]), "kadabraabra" (pass[2]+pass[3]+pass[1]) and so on.  Input Format  First line contains an integer T, the total number of test cases. Then T test cases follow. First line of each test case contains N, the number of users with passwords. Second line contains N space separated strings, pass[1] pass[2] ... pass[N], representing the passwords of each user. Third line contains a string, loginAttempt, for which Yu has to tell whether it will be accepted or not  I tried to solve it using recursion along with memoization Here is my solution in python3  But it is failing a lot of test cases with runtime error or Time limit exceeded. One particular test case for which it fails is with input  I am not able to figure out how to improve this. Can anyone please suggest a better alternative solution.  Maybe I'm wrong, but it looks like an evil regex issue. You are matching the string against the regex . It won't work...  3 Answers 3  All you have to do in this exercise is insert spaces into so as to separate it into valid passwords, or return if this is not possible.  Therefore, the only information you need to keep track of is where these spaces should be added.  You can do this without a dict, and without creating any partial lists of matched strings.  Just start with a simple list of numbers (e.g., ). Whenever you find a match, store the index of the next unmatched character. If this index happens to be equal to , then you can obviously stop searching. If no match exists for a particular location, store that result too.  When you get a successful match, step through the list of string offsets to find out where the spaces need to be inserted.  EDIT:  I had a crack at solving this problem at HackerRank. The above method basically worked fine, but needed a few minor tweaks to pass all the tests. In particular, you'll probably need to call to allow for a greater level of recursion.  I want to add a few hints to @squeamish-ossifrage's answer. You are exploring a colossal number of possibilities. Let's say the has a size and you have passwords. You can imagine your exploration as a big tree where every node has children, namely the next possible passwords in the sequence. If the minimum length of a password is , your algorithm has an approximate time complexity of , since you will build every string of passwords and that's why your solution ends with a .  As @squeamish-ossifrage wrote, you can improve your memoization technique. But there are other points to consider.  First, in your example, contains a that is absent of every password. More formally, if the set of characters of is a strict superset of the set of characters of the passwords, you are sure you won't find a solution. If is the maximum length of the password, the time complexity is O(n+kL).  Second, try to prune the research tree (ie reduce the number of children of every node). How to do this? Simply try to limit the number of acceptable passwords.  The basic idea is that if the does not contain a password, then this password should be excluded from the exploration. You can repeat this operation a each step, since may not contain a password that was contained in . Time complexity: O(kn/l) in the best cases with Python search algorithm, at each step.  A more sophisticated idea is to remove password that are composed of other passwords. Since you have , you don't need , , etc. How? You just have to apply the with as the attempt and the rest of the passwords as (I don't go into detail here). If you find a sequence of other passwords that is equal to , you don't need and can remove it from the list. It should be done once at the beginning.  The challenge is solvable using only these techniques and the increase of recursion limit, keeping you cache.  6,94211 gold badge1414 silver badges3131 bronze badges  1  1  Excellent advice. For the record, the "minor tweaks" I referred to included a quick sanity check and sorting the passwords in descending order of length , both performed before calling . Meanwhile, in the function, remember to invalidate positions where no valid break could be found (i.e., if the loop completes without returning, then mark this position as "impossible" and don't check it again.  Here's some passing code. We don't necessarily need to check supersets or use clever preprocessing heuristics. One trick is that, although there could be an inordinate number of possibilities, it's enough to return one of them. Meaning, if we have a solution up to index , we are free to ignore all other possibilities for forming the same length prefix of . This Python code uses two lists, one for starting indexes we already visited and one for saving the chosen sequence of passwords that form the prefix up to the next starting index we'll check.  22.4k33 gold badges2020 silver badges5858 bronze badges  3  The OP didn't ask for the code. This is a spoiler! Beyond that, I agree that an iterative DFS is better than a recursive one, and that your equivalent of the original memoization is great, but I feel that every time you are doing an exhaustive research, pruning the tree is the first thing to do. For this problem, it was enough.  @jferard thanks for commenting. The OP asked to "suggest a better alternative solution." In that case I figured it might be OK to show code since it would be instructive for the OP, considering that it includes various programming aspects that might be quick and easier to show than to explain.  No worries. It's indeed instructive for the OP. I thought giving some guidelines was better than code, but if the OP asked that question, he was aware he might got some code as answer. In addition to my previous comment: a good memoization is also a way to "prune" the tree, since you merge some subtrees.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  