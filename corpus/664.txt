 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Edit: The real case is: I'm writing a linux kernel module and I'm calling kernel functions. Some of these functions are pointers and I want to inspect the code of that function in the kernel source. But I don't know which function it is pointing to. I thought it could be done because, when the system fails (kernel panic) it prints out in the screen the current callstack with function's names. But, I guess I was wrong... am I?  38.6k3535 gold badges9797 silver badges120120 bronze badges  3  1  Perhaps if you explain why you need the function's name, someone could suggest an alternate way to get what you need.  Something which is mentioned and not elaborated on is using debug symbols. However you get this to work the result is almost certainly going to be doing lookups into some source of debug symbols... as mentioned by one answer libdwarf is probably the way to go for linux kernelly things.  13 Answers 13  I'm surprised why everybody says it is not possible. It is possible on Linux for non-static functions.  I know at least two ways to achieve this.  There are GNU functions for backtrace printing: and (See ). In your case you don't need as you already have function pointer, you just pass it to .  Example (working code):  Compile with  Output:  It gives you binary name, function name, pointer offset from function start and pointer value so you can parse it.  Another way is to use (another extension), I guess uses . returns structure that has function name in field. I don't provide code example here but it is obvious - see for details.  NB! Both approaches require function to be non-static!  Well, there is one more way - use debug information using but it would require unstripped binary and not very easy to do so I don't recommend it.  32.2k1313 gold badges5454 silver badges8484 bronze badges  1  1  For the non-kernel case, the dladdr method should be the accepted answer. You should split it out from the backtrace stuff.  That's not directly possible without additional assistance.  You could:  maintain a table in your program mapping function pointers to names  examine the executable's symbol table, if it has one.  The latter, however, is hard, and is not portable. The method will depend on the operating system's binary format (ELF, a.out, .exe, etc), and also on any relocation done by the linker.  EDIT: Since you've now explained what your real use case is, the answer is actually not that hard. The kernel symbol table is available in , and there's an API for accessing it:  For simple debug purposes the latter will probably do exactly what you need - it takes the address, formats it, and sends it to , or you can use with the format specifier.  321k7070 gold badges389389 silver badges475475 bronze badges  6  I don't think I can call kallsyms_lookup from a kernel module. When I compile, I get "kallsyms_lookup undefined"  If you're getting a compile time error then you need to make sure that you've got the kernel headers available and in your include-path.  ok, that suggests that your module compile stuff is wrong somewhere. Modules need to call symbols that are in the kernel, so by definition the symbol can't be resolved completely at link time.  p.s. sample Makefiles for compiling Linux kernel modules is probably a good candidate for another question. My reference stuff for this is at work where I can't get it at the moment.  @QiZhang it's an extension of the format specifier, which is used to print raw pointer addresses. this specifier prints function names. see the printk kernel docs for more info.  It works only if the function in question is in the same program (not in a dynamically linked library or something).  If you can find out the load addresses of the loaded shared libraries, you can subtract the address from the printed number, and use nm on the library to find out the function name.  You can't diectly but you can implement a different approach to this problem if you want. You can make a struct pointer instead pointing to a function as well as a descriptive string you can set to whatever you want. I also added a debugging posebilety since you problably do not want these vars to be printet forever.  If the list of functions that can be pointed to is not too big or if you already suspect of a small group of functions you can print the addresses and compare them to the one used during execution. Ex:  If you compile the corresponding code into a DLL/Shared Library, you should be able to enlist all entry points and compare with the pointer you've got. Haven't tried it yet, but I've got some experience with DLLs/Shared Libs and would expect it to work. This could even be implemented to work cross-plarform.  Someone else mentioned already to compile with debug symbols, then you could try to find a way to analyse these from the running application, similiar to what a debugger would do. But this is absolutely proprietary and not portable.  Check out Visual Leak Detector to see how they get their callstack printing working. This assumes you are using Windows, though.  Not exactly what the question is asking for but after reading the answers here I though of this solution to a similar problem of mine:  If your program needs this a lot you could define the method names along with a string in an XMacro and use in the code to get the corresponding string from the function name.  Alnitak's answer is very helpful to me when I was looking for a workaround to print out function's name in kernel module. But there is one thing I want to supplyment, which is that you might want to use %pS instead of %pF to print function's name, becasue %pF not works anymore at some newer verions of kernel, for example 5.10.x.  You can't. The function name isn't attached to the function by the time it's compiled and linked. It's all by memory address at that point, not name.  Just because its not apart of the C spec, doesn't mean the system specific methods cant be used.  You wouldn't know how you look like without a reflecting mirror. You'll have to use a reflection-capable language like C#.  You can do it in C. It just won't look as pretty as in most languages that do some compilation at runtime (and therefore need more data on the function calls).  i downvote because reflection is always a sledgehammer solution to problems. it enables nothing you can't do with pure C or assembler (by necessity of having to work on some machine this is fundamentally true). it has a convenience when it is there, but relying on it in general is bad practice.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  