 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I want to create a linked list using recursion. After executing the code, I get only the value of the first node and rest are not being printed.  I think the problem is when i call , but I am not sure. Is my logic correct? Can someone pin-point my mistake?  Standard warning: Do not cast as returned by & friends. C isn not C++! Note also: do not use all-uppercase identifiers for types/variables. They should only be used for macros and _enum-constants_This is one of the few widely accepted naming conventions in C.  Creating a linked list with recursion sounds like quite a dumb requirement - sorry, but I cannot say it more politely. Simply, because you will create/append (or prepend) one element after the other. There is no loop required.  90011 gold badge99 silver badges2222 bronze badges  1  1  Standard warning: Do not cast as returned by & friends. C isn not C++! Note also: do not use all-uppercase identifiers for types/variables. They should only be used for macros and _enum-constants_This is one of the few widely accepted naming conventions in C. You should not copy the flaws of OP.  The significant error leading to your problem was your assignment of pointers in . You were assigning the first pointer correctly, but then assigning to all remaining pointers. There are several ways to handle this, but a clean and straightforward way is to only advance within the block as follows:  You are dynamically allocating memory, so this means you are responsible for tracking its use, preserving a pointer to the starting block of each allocation, and finally freeing the memory when it is no longer in use. Start now. Get in the habit of handling your memory cleanup whenever you allocate, and don't simply rely on the program exit to do it for you. While it may seem trivial now, when you begin handling functions with multiple allocations, etc., if you have not developed good habits in this regard, your code will likely leak memory like a sieve. A simple cleanup function could be nothing more than:  The issue. returns the starting address for the block of memory allocated, there is no need to cast the return in C. When you are allocating memory for data types you have just declared, use the variable with instead of the datatype. e.g.:  instead of  This will become apparent when dealing with pointers to pointers, etc. It makes far more sense to operate on your variable than it does to remember whether you are allocating for or . This is especially true when the allocation is many lines below the declaration in your code or when receiving the pointer in a function argument list.  Additionally, you need to validate the return from each time you allocate memory to insure you haven't exhausted the available memory. e.g.:  Finally, putting it all together, one approach to your problem would be:  Example  Use a Memory Checker  Regardless of your platform, it is good to use a memory checker, like on Linux to check for memory errors and insure you have freed all the memory you have allocated. A memory checker, not only provides a confirmation that all memory has been freed, it will also report on subtle errors in the way you attempt to access the memory you have allocated which can alert you to issues that can bite you later. It is simple to use, simply:  That should get you started, and if you learn the good habits early, managing memory will be a whole lot easier as you get further into programming in C.  You're loosing your reference to the tail of the list, and therefore not adding to the list. You should be doing this:  This points the pointer of the current tail to the new node, then moves down to the new tail.  Also, the at the end of the loop is unnecessary, since is now the same as , and you already did .  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  