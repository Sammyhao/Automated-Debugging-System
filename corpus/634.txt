 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a JSON data structure. Every object has a field called .  And I want to convert this into an object tree composed of the following classes  I can unpack a simple json object into a dataclass quite easily using the operator: e.g  But how can I extend this to work with nested objects?  I want it to create this data class instance:  Here is my best attempt. It doesn't really make sense, but it might be a starting point. I realise this logic doesn't make sense, but I cannot come up with a function that does make sense.  1,35644 gold badges2222 silver badges4343 bronze badges  4  1  I don't see the point of using dumb data class objects here. Eventually, you are going to want intelligence in these classes, right? So rather than come up with a complicated over-general import, just let each class do its own import. It knows what it wants. I'll do up an example.  This is just a piece of example code. The real thing I want to know how to do is turn json data into a dataclass python object tree, ideally with some data validation steps. "Eventually, you are going to want intelligence in these classes, right?" - Not always. I have been exerimenting with functional programming and using single / multiple dispatch, instead of using instance methods or abstract methods etc. in order for single / multiple dispatch to work, I need to convert my json data into a python object, so it encodes the type information inside itself.  3 Answers 3  Here is an example of how do this export in an object-oriented way. In my personal opinion, converting this to pure dataclass objects brings you no benefit over just keeping everything in a dictionary. Here, each object can have its own behavior.  (I've now modified this to start adding repr handlers, so you can print the whole tree at once.)  24.9k33 gold badges1616 silver badges2020 bronze badges  4  This is quite nice. But one of the motivations for keeping the GameObjects dumb is to make it super easy to define new types. This method requires some parsing of the json in each class, and I wanted to create one generic function that will work for any object in the game_object_registry, and it will give a fairly sensible error if the json does not have the correct fields (which the "**args" method does). In this example, you would have to put data validation in every single class as they all are directly looking at the json. For classes with lots of fields, this will be annoying.  I also wanted my GameObjects part of the application to be completely seperate from the json part, and have the option to construct these clases without using a json obj (well, a dict), if I wanted to. Also your example only works for this particular example. I would like a function that will work with any set of classes, as long as it has the correct json to go along with it.  Given all that, then I don't see any point in making these classes. A dict has the same functionality.  Assuming you have control over the JSON / dict structure. You can use a framework like dacite.  It will let you map the data into your dataclasses.  20.1k66 gold badges2828 silver badges4242 bronze badges  1  Amazing, this is very close to what I am trying to do! The only downfall with this is that if I have two dataclasses with identical structure, this will not know which one to use. E.g, my Wizard and Archer. That is why I had the type field in my json. I might be able to investigate the sourcecode of dacite and reverse engineer a solution though.  As an alternative, you could also use the dataclass-wizard library for this.  This should support dataclasses in types as of a recent version, and note that as of v0.19.0, you can pass in the Meta config for the main dataclass, to configure the tag field name in the JSON object that maps to the dataclass in each type - which in your case defaults to the field.  I've also removed this field entirely in cases where it was not really needed -- note that you'd only need such a tag field when you have a field that maps to one or more dataclass types, via a declaration. The one main benefit of using a custom tag for each class, is that if you later decide to rename the class for instance, any existing JSON data can still be de-serialized into the nested dataclass model as expected.  The below example should work for Python 3.7+ with the included import. This allows you to use PEP 585 and PEP 604- style annotations, for a more convenient shorthand syntax.  Output:  If you want to save yourself some time and not have to manually define a for each dataclass in a type, you can also automate this process by enabling the flag on the main dataclass; this will default to assign the class name as the for each nested class. This also allows you to remove the usage from the nested dataclasses, so that you only have it on the main dataclass, as shown below.  The only caveat with this approach, is if you later decide to rename a dataclass such as the class, any existing JSON data can't be de-serialized without manually specifying a for the class.  The output should be the same as in the first example, where we explicitly specified a for each dataclass in a declaration.  If you need data validation or if you want to retain the field in the JSON object, I'd also suggest pydantic as another solution. In addition, you can use pydantic drop-in dataclasses and retain the usage for the rest of the model classes, as shown below.  The output in this case is slightly different - note that when you print the of the object, you also see the fields printed out, since technically it is a dataclass field.  3,95233 gold badges1010 silver badges2323 bronze badges  1  @Blue7 Just a note that I added some updates so that a field can be supported as the tag field. I updated my answer to reflect these changes.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  