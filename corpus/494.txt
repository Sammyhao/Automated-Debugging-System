 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  EDIT: Sorry guys, I forgot to mention that this is coded in VS2013.  I have a globally declared struct:  I then allocate my memory:  I then initialize all the elements:  And lastly, I wish to free the memory (which FAILS). I have unsuccessfully tried following some of the answers given on SO already.  A heap corruption detected error is given at the first free statement. Any suggestions?  (Your other problem) Your order of calls to is wrong. You cannot free an outer array and then go free its elements. It's too late, there are no elements any more.  3 Answers 3  There are multiple mistakes in your code. logically wrong how to allocate memory for two dimension array as well as some typos.  From comment in your code "outer array size - value/key index" it looks like you wants to allocate memory for "2 * HASH_TABLE_SIZE" size 2D array, whereas from your code in for loop breaking condition "i < HASH_TABLE_SIZE;" it seems you wants to create an array of size "HASH_TABLE_SIZE * 2".  Allocate memory:  Lets I assume you wants to allocate memory for "2 * HASH_TABLE_SIZE", you can apply same concept for different dimensions.  The dimension "2 * HASH_TABLE_SIZE" means two rows and HASH_TABLE_SIZE columns. Correct allocation steps for this would be as follows:  step-1: First create an array of int pointers of lenght equals to number of rows.  this will create an array of int pointers () of two size, In your code in outer-array allocation you have allocated memory for two objects as whereas you need memory to store addresses. total memory bytes you need to allocate should be (this is poor typo mistake).  You can picture above allocation as:  ? - means garbage value, malloc don't initialize allocate memory  It has allocated two memory cells each can store address of  In picture I have assumed that size of int* is 4 bytes.  Additionally, you should notice I didn't typecast returned address from malloc function because it is implicitly typecast void* is generic and can be assigned to any other types of pointer type (in fact in C we should avoid typecasting you should read more from Do I cast the result of malloc?).  Now step -2: Allocate memory for each rows as an array of length number of columns you need in array that is = HASH_TABLE_SIZE. So you need loop for number of rows(not for HASH_TABLE_SIZE) to allocate array for each rows, as below:  Now in each rows you are going to store for array of ints of length you need memory bytes = . You can picture it as:  Diagram  In picture I assuming HASH_TABLE_SIZE = 4 and size of int= 4 bytes, note address's valuea  Now these are correct allocation steps.  Deallocate memory:  Other then allocation your deallocation steps are wrong!  Remember once you have called free on some pointer you can't access that pointer ( pr memory via other pointer also), doing this calls undefined behavior—it is an illegal memory instruction that can be detected at runtime that may causes—a segmentation fault as well or Heap Corruption Detected.  Correct deallocation steps are reverse of allocation as below:  Further more this is one way to allocate memory for two dimension array something like you were trying to do. But there is better way to allocate memory for complete 2D array continuously for this you should read "Allocate memory 2d array in function C" (to this linked answer I have also given links how to allocate memory for 3D arrays).  54.3k1919 gold badges131131 silver badges196196 bronze badges  1  @GeorgeLoman Your welcome. You should also learn how to allocate continuous memory.  Your "outer array" has space for two integers, not two pointers to integer.  Is HASH_TABLE_SIZE equal to 2? Otherwise, your first for loop will write outside the array you just allocated.  26.1k88 gold badges4949 silver badges7474 bronze badges  4  actually there are multiple mistakes. OP don't know how to allocate memory for 2D arrays.  Thanks for the advice it makes sense, and it now works. I didn't realize I had to declare space for pointers to an integer, but the incorrect scope of the arrays were an obvious mistake. Also I found the following link useful: annigeri.in/2011/11/dynamic-two-dimensioned-arrays-in-c.html  Welcome to "Stack Overflow", We teach and help here, not just do other's work. An unexplained code is not very helpful and good answer.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  