 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  When I compile my program in visual studio 2003, my program behaves well and good. but when i do the same in 2010, then while closing the application i get some error like  and when i press to ignore this i get  Does any one has any idea what is going on here: I will extremely indebted for any suggestions by anyone. Tons of thanks and warm wishes.  2 Answers 2  If is the only element in the list, you will overrun the end of the list.  After you remove from the list, you reset . This is fine. Then the loop expression is evaluated (the from the statement), which causes to be advanced past the end of the range.  Advancing an iterator past the end of the container causes the program to exhibit undefined behavior. Recent versions of Visual C++ helpfully detect many common iterator errors in debug builds of your program and raise assertions to help you to solve them.  You can resolve the problem by removing loop expression and moving it into an statement:  Though, restarting iteration every time you remove an element is rather wasteful. Consider instead using using the iterator returned by the call to :  335k7272 gold badges892892 silver badges963963 bronze badges  5  Good recommendation of erase/remove. In this particular case m_DriverList is apparently a container of pairs or is a map of some kind, since the test is on it->second. Instead of std::remove it will require std::remove_if with a lambda or comparison function.  If the container is a map (question title, access to member ) then I don't think the erase-remove idiom can be applied. The idiomatic is similar to the while loop that you have, but instead of restarting the iteration you copy and advance the iterator and then erase the current position.  @DavidRodríguez-dribeas @MarkTaylor: Good catch; I was distracted by "List" in the variable name. In C++11, returns the iterator to the next element (or to one-past-the-end if there is no next element), and Visual C++ 2010 supports this.  @JamesMcNellis, yes that was missing from c++03, where the erase function returned the next iterator only for sequences, but not for associative containers. For associative containers that work has to be manually done in C++03  You don't need to restart the loop with begin. Instead POST-increment it++ in the erase() call. The reason that works can be thought of that it's value is written down for erase() to use, but it's incremented BEFORE erase is actually called and you delete the thing it's pointing to.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  