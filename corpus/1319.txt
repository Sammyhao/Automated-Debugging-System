 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a program that read urls in a file and does a on each URL host. This call is quite consuming. I want to cache them.  Is there a very simple map-base code snippet in C out there that I could use to do the caching? (I just don't want to reinvent the wheel).  It has to have the following points :  Open-source with a permissive license (think BSD or public domain).  Very simple : ideally less than 100 LOC  Keys are and values . No need to copy them.  No real need to implement , but is either needed or should replace the value.  PS: I tagged it homework, since it could be. I'm just being very lazy and do want to avoid all the common pitfalls I could encounter while reimplementing.  4,44944 gold badges3737 silver badges5252 bronze badges  1  @Sinan & Meredith : I accepted the code snipped since it was exactly what I was looking for.  212k5454 gold badges394394 silver badges484484 bronze badges  1  +1: Exactly what I was searching for. I edited the code a little to cope with correct const-ness (key & value). Now my apps starts in less than a sec, instead of the 2 minutes @ 100% cpu :-)  in C++ is a red-black tree under the hood; what about using an existing red-black tree implementation in C? The one I linked is more like 700 LOC, but it's pretty well commented and looks sane from the cursory glance I took at it. You can probably find others; this one was the first hit on Google for "C red-black tree".  If you're not picky about performance you could also use an unbalanced binary tree or a min-heap or something like that. With a balanced binary tree, you're guaranteed O(log n) lookup; with an unbalanced tree the worst case for lookup is O(n) (for the pathological case where nodes are inserted in-order, so you end up with one really long branch that acts like a linked-list), but (if my rusty memory is correct) the average case is still O(log n).  234k3838 gold badges398398 silver badges527527 bronze badges  1  -1: I do want to avoid a syscall (), so I don't really think that memcached fits the bill here.  Not lazy, deeply sensible to avoid writing this stuff.  How's this library never used it myself but it seems to claim to do what you ask for.  53.3k1111 gold badges7171 silver badges111111 bronze badges  2  The library seems interesting, but the last update to the website was 2005. It would be OK for a few code lines, but a little too old for a full blown library.  Well, fundamental algorithms well implemented should not become dated. I would have no concern about using 4 year old libraries of this kind - assuming that they actually worked in the first place. If you ahve the code, then maintenance should not be too much of an issue.  Dave Hanson's C Interfaces and Implementations includes a nice hash table, as well as many other useful modules. The hash table clocks in at 150 lines, but that's including memory management, a higher-order mapping function, and conversion to array. The software is free, and the book is worth buying.  Found an implementation here : c file and h file that's fairly close to what you asked. W3C license  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  