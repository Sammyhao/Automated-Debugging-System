 Binary Search  Given a sorted array arr[] of n elements, write a function to search a given element x in arr[]. A simple approach is to do a linear search. The time complexity of the above algorithm is O(n). Another approach to perform the same task is using Binary Search. Binary Search: Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty.  Example :  The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(Log n).  We basically ignore half of the elements just after one comparison.  Compare x with the middle element.  If x matches with the middle element, we return the mid index.  Else If x is greater than the mid element, then x can only lie in the right half subarray after the mid element. So we recur for the right half.  Else (x is smaller) recur for the left half.  Recursive implementation of Binary Search  C++  C  Java  Python3  C#  PHP  Javascript  Output :  Here you can create a check function for easier implementation.  Here is recursive implementation with check function which I feel is a much easier implementation:  C++  Iterative implementation of Binary Search  C++  C  Java  Python3  C#  PHP  Javascript  76 = 64 + 8 + 4  10 = 8 + 2  7 = 4 + 2 + 1  Compute the first power of 2 that is greater or equal then the size of the array.  Initialize an index as 0.  Loop while the computed power is greater than 0 and each time divide it by 2.  Each time the element at position [index + power] <= target we add to the index variable the respective power value. (Build the sum)  After the for loops check if the element at position [index] == target. If so the target element is present in the array, else not.  (no division needed only addition and bitwise shifting)  C++  Java  Time Complexity:  The time complexity of Binary Search can be written as:  The above recurrence can be solved either using the Recurrence Tree method or the Master method. It falls in case II of the Master Method and the solution of the recurrence is . Auxiliary Space: O(1) in case of iterative implementation. In the case of recursive implementation, O(Logn) recursion call stack space. Algorithmic Paradigm: Decrease and Conquer.  Note:  Here we are using  int mid = low + (high – low)/2;  Maybe, you wonder why we are calculating the middle index this way, we can simply add the lower and higher index and divide it by 2.  int mid = (low + high)/2;  But if we calculate the middle index like this means our code is not 100% correct, it contains bugs.  That is, it fails for larger values of int variables low and high. Specifically, it fails if the sum of low and high is greater than the maximum positive int value(231 – 1 ).  The sum overflows to a negative value and the value stays negative when divided by 2. In java, it throws ArrayIndexOutOfBoundException.  int mid = low + (high – low)/2;  So it’s better to use it like this. This bug applies equally to merge sort and other divide and conquer algorithms.  1. Language Foundation Courses [C++ / JAVA / Python ] Learn any programming language from scratch and understand all its fundamentals concepts for a strong programming foundation in the easiest possible manner with help of GeeksforGeeks Language Foundation Courses – Java Foundation | Python Foundation | C++ Foundation 2. Geeks Classes Live Get interview-centric live online classes on Data Structure and Algorithms from any geographical location to learn and master DSA concepts for enhancing your problem-solving & programming skills and to crack the interview of any product-based company – Geeks Classes: Live Session 3. Complete Interview Preparation Get fulfilled all your interview preparation needs at a single place with the Complete Interview Preparation Course that provides you all the required stuff to prepare for any product-based, service-based, or start-up company at the most affordable prices. 4. DSA Self Paced Start learning Data Structures and Algorithms to prepare for the interviews of top IT giants like Microsoft, Amazon, Adobe, etc. with DSA Self-Paced Course where you will get to learn and master DSA from basic to advanced level and that too at your own pace and convenience. 5. Company Specific Courses – Amazon, Microsoft, TCS & Wipro Crack the interview of any product-based giant company by specifically preparing with the questions that these companies usually ask in their coding interview round. Refer GeeksforGeeks Company Specific Courses: Amazon SDE Test Series, etc.  Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here.  We use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy Got It !  