 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a function that has the following signature...  I'm trying to find a way to convert the "expression" parameter back to something resembling the original source code (or at least a c# representation of the original souce code). So, if someone calls the function like this...  ...I'd like to be able to convert the expression to this...  2,24722 gold badges3030 silver badges4343 bronze badges  2  I'm experimenting with some ideas for a unit testing framework. My idea is that if you test against a lambda and the test fails, you could actually show the code that failed. For example, instead of getting "expected: 4 actual: 5", you could get a message more like "expected: user.Age == 4 actual: user.Age == 5"  You ask for a C#-like string representation, but I've written a library that outputs other representations: Visual Basic - like, factory methods needed to create a similar expression; object/collection initialization syntax.  2 Answers 2  I've just happened across this; I've written a free, open-source library which provides an extension method to create a source-code-like string from an Expression:  6,98533 gold badges2828 silver badges3131 bronze badges  3  Well, looking at the nuget download count, this is way more in demand than I expected.  I have a mapper project which depends on it - that will have increased the download count. AutoMapper have recommended my library for examining their mapping execution plans, too! :)  Here's an interesting article, with code, discussing the conversion of expression trees back into something that resembles (roughly) the original source:  249k5353 gold badges356356 silver badges403403 bronze badges  2  1  I have tried using ToString(), but it gives me something pretty nasty looking... (Convert(((value(LambdaToStringSpike.Program+<>c__DisplayClass0).i + value(LambdaToStringSpike.Program+<>c__DisplayClass0).j) * 9)) = Round((Convert(value(LambdaToStringSpike.Program+<>c__DisplayClass0).j) / Convert((value(LambdaToStringSpike.Program+<>c__DisplayClass0).i - 3))), 4))  Yep, I think the output you're seeing is what's generated behind-the-scenes by the C# compiler to handle the captured variables and . In my examples, and are locals, so the output is much closer to the original source code.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  