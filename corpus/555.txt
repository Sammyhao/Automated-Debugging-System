 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I got a little problem which i cannot really solve. I want to map a function over a tree. However, while it compiles it gives out various errors when i want to use it. My idea is that I run "mapTree (+1) someTree" and it adds 1 to every value  My data structure:  My function:  If someone could give me a hint what I am doing wrong...  there is also an error in your second line - not a compile-time error, but a logical error that will stop the function working as intended. I'll leave you to figure that one out :)  Oh thanks a lot! Yeah i found the logical error too, had to run the function over the value too of course...  – user11783767  Jun 14 '20 at 10:22  3  As a general suggestion, when defining a top-level function always start from writing its type. That will make GHC know what you intend to do, and consequently produce better error messages.  3 Answers 3  In addition to my first answer I want to say, that, if you want to apply some function with type to some value with type (in our example equals ), usually you might want to implement instance for your type (but just a function in small tasks is also fine). Here is implementation for :  As you can see, is like your , but now you have type class, it's more suitable way to do things like that, because instance may be useful in future to implement another type classes. Examaple of usage:  Or you can just write after the data declaration, and the compiler will write your code for you ;). (It's good to do it yourself a few times like this first, until you start getting bored)  As chi indicated, it's almost always best to start with a type signature:  If you'd done so, you'd have gotten two type errors, each of which points to a different mistake in your code. The first one:  This one comes about because the first case is supposed to produce a , but applying to an argument can only produce something of type .  The second one:  This happens because you apply to a list of some type when is expecting an argument of type .  Suppose you fix these errors by changing the first case to  (I've prefixed with an underscore. By convention, this suggests that it's intentionally unused in this case. If you enable compiler warnings, which you should, this will prevent GHC from warning you about the unused variable binding.)  Now you'll get a new and different error:  This is because you forgot to apply to the value stored in the node. You needed to turn an into a and you forgot.  For your type of tree such function will look this:  Your mistake is that you can't apply such function as (+1) to the empty list. Function has to be type. When you meet a , you can't do anything with it, because in your implementation Leaf doesn't contain any value, so we just return the . The single place, where we can apply our function is the center of the , that's why I added applying this function to the value in the  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  