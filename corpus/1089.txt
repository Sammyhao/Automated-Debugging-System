 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  The following code works fine when head is sent as a parameter to it. As I am new to C, I couldn't understand how it works. Help me out please.  I dont know how the links are provided using those recursive calls. ie) if the links are as,  Think about the solution in generic and most basic terms. The smallest would be a list of 2 nodes . To make it generic, we will always refer to other nodes from the node. To reverse this, set making it and then will result in . Use this rule recursively.  422k8181 gold badges479479 silver badges522522 bronze badges  3  It took some time for me to understand it. But nevertheless, it is very good solution.  Basically you go to the the last node and you keep returning a pointer to it, at the same time you switch the links between nodes. Did I got it right?  this is needlessly recursive and can be fully iterative instead - more efficient and also much clearer.  A more elegant way to call it probably is wrapping it in another function, which would just take head.  now running the function for the linked list 1-> 2-> 3 -> 4  inside reverse(&1) the code runs until rev_head=reverse(&2); // here &1 is address of 1.  list of function is 1(first)->2(second) -> 3 -> 4  inside reverse(&2) code runs until rev_head=reverse(&3); list of function 2(first)->3 (second)-> 4  inside reverse(&3) code runs until rev_head=reverse (&4); list if function 3(first)-> 4 (second)  inside reverse(&4) terminating condition second==NULL is true so return is executed and address of 4 is returned.  list of function  4(first)-> NULL(second)  back to reverse(&3) list of function is NULL<-3(first) 4 (second) and the value of rev_head=&4 which was returned  after executing second->next=first; list becomes  NULL<- 3(first) <-4 (second)  return (rev_head ); is executed which passes &4 because rev_head=&4  NULL<-1(first) 2(second)<-3<-4  and value of rev_head is &4 which was passed by reverse(&3)  now second->next =first is executed and list becomes  NULL<-1(first) <- 2(second)<-3<-4  return(rev_head); is executed // rev_head=&4 which was returned by reverse(&2) and the value of rev_head is passesd to the main function.  hope this helps. It took me quite a lot of time to understand this and also to write this answer.  6,36144 gold badges3838 silver badges5454 bronze badges  1  "beautiful" is highly debatable. by adding just one temp variable to save the curr->next value, you can swap the two code lines making the recursive call be in tail position, which is far more important. and the code becomes much clearer and more understandable: .  It seems to me that nobody has suggested an algorithm that is tail-recursive. In principle, a tail-recursive algorithm can be compiled without a stack (provided that the compiler is smart enough), thus producing code that consumes less memory.  Assume is a custom data-type for single-linked list, it is a pointer to a structure that as a field for accessing the next element in the list.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  