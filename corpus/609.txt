 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  This is what I have. I thought pre-order was the same and mixed it up with depth first!  Can you be more specific about what exactly you want, if you're not looking for an answer?  well I cant seem to find out how to do a breadth first traversal in my book....it is practice...not homework. point in the right direction...  10 Answers 10  1,14911 gold badge77 silver badges22 bronze badges  2  28  Why is the queue declared outside of the method? This will fail if breadth() is called twice concurrently. I can't see any downside of moving it inside as a local variable.  @Jonah in the case that is called twice concurrently, there is only one queue so it will have the elements added twice and randomly pulled by either of the two invocations, not to mention the fact that is not thread-safe.  For breadth first, add all children to the queue, then pull the head and do a breadth first search on it, using the same queue.  For depth first, add all children to the stack, then pop and do a depth first on that node, using the same stack.  LaValle, Sec.2.2 provides an excellent unified treatment of BFS, DFS, as well as other search methods.  It doesn't seem like you're asking for an implementation, so I'll try to explain the process.  Use a Queue. Add the root node to the Queue. Have a loop run until the queue is empty. Inside the loop dequeue the first element and print it out. Then add all its children to the back of the queue (usually going from left to right).  When the queue is empty every element should have been printed out.  This code which you have written, is not producing correct BFS traversal: (This is the code you claimed is BFS, but in fact this is DFS!)  @Kreisquadratur, did you read my comment above the code? I meant "your code, which I copied below is not BFS". No one mentioned that. But this code is not BFS, it is DFS. (I updated a little to be more clear)  For implementing the breadth first search, you should use a queue. You should push the children of a node to the queue (left then right) and then visit the node (print data). Then, yo should remove the node from the queue. You should continue this process till the queue becomes empty. You can see my implementation of the BFS here: https://github.com/m-vahidalizadeh/foundations/blob/master/src/algorithms/TreeTraverse.java  Use the following algorithm to traverse in breadth first search-  First add the root node into the queue with the put method.  Iterate while the queue is not empty.  Get the first node in the queue, and then print its value.  Add both left and right children into the queue (if the current nodehas children).  Done. We will print the value of each node, level by level,by poping/removing the element  The following is a simple BFS implementation for BinaryTree with java 8 syntax.  Then invoke this with root node and a Java Queue implementation  Even better if it is regular tree, could use following line instead as there is not only left and right nodes.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  