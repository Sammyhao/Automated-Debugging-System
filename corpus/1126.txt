 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I recently tackled a coding problem. I came up with a solution to the following problem.  A non-empty zero-indexed array A consisting of N integers is given. Array A represents numbers on a tape. Any integer P, such that 0 < P < N, splits this tape into two non-empty parts: A[0], A[1], ..., A[P − 1] and A[P], A[P + 1], ..., A[N − 1]. The difference between the two parts is the value of: |(A[0] + A[1] + ... + A[P − 1]) − (A[P] + A[P + 1] + ... + A[N − 1])| In other words, it is the absolute difference between the sum of the first part and the sum of the second part. For example, consider array A such that: A[0] = 3 A[1] = 1 A[2] = 2 A[3] = 4 A[4] = 3 We can split this tape in four places: P = 1, difference = |3 − 10| = 7 P = 2, difference = |4 − 9| = 5 P = 3, difference = |6 − 7| = 1 P = 4, difference = |10 − 3| = 7 Write a function: function solution(A); that, given a non-empty zero-indexed array A of N integers, returns the minimal difference that can be achieved. For example, given: A[0] = 3 A[1] = 1 A[2] = 2 A[3] = 4 A[4] = 3 the function should return 1, as explained above. Assume that: N is an integer within the range [2..100,000]; each element of array A is an integer within the range [−1,000..1,000]. Complexity: expected worst-case time complexity is O(N); expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified.  The following is the feedback I obtained from testing the solution:  CORRECTNESS: small_range range sequence, length = ~1,000 1.900 s RUNTIME ERROR tested program terminated unexpectedly PERFORMANCE: Detected time complexity: O(N * N)  So I am getting one runtime error for ranges around 1000. And most importantly, I am not getting O(n). I am getting O(n * n) as I am using nested for loops.  (1) How could I fix the runtime error? (2) How could one construct O(n) algorithm for the same problem? Any suggestions?  Thank you all very much for providing your insights. I feel that after this discussion I have become a more mature and cautious programmer.  4 Answers 4  Let me try to explain you how you can think about improving the space and time complexity of your algorithm. You realize where clearly that you're using nested for loops and it greatly increases the iterations and might also be causing the run-time error for sufficiently large inputs.  The first step should be reducing the redundancy of your operations. Now you calculate the and sums repeatedly for different values of . You don't need that at all. I'll give you an example for how the algorithm will flow:  Complexity for this algorithm  Time complexity  The only time we calculate the sum of the elements is the first time when we calculate A[1]+...A[n-1]. After that we just traverse the elements of the array one by one.  So we traverse the elements of the array at max twice. So time complexity is clearly O(N)  Space complexity  We use three extra variables i.e S1, S2 and min-diff all through this algorithm to accumulate the sum and store the minimum absolute difference along with the value of p and the n elements of the array.  So space complexity of this algorithm is again O(N)  On a side note- Although you don't require sorting for this problem at all since you're to output the minimum difference only, but whenever sorting, please don't use bubble-sort at it is clearly the least efficient sorting method. You're better off with merge sort or quick sort which have a run time of O(NlogN)  I hope I was able to explain myself. Try to code this into a simple function, shouldn't take long. It should probably fix the run-time error as well.  4,48933 gold badges2323 silver badges4343 bronze badges  2  Given the nature of the function, you will only need to iterate till the difference between the right part and the left part starts increasing. If that happens, you have hit the minimum, and it is sub-optimal to proceed through the whole array.  @Achrome, in the question he mentions that the values of the array could be negative or positive. I don't know if I can explain if there will be a trend in the absolute minimum difference of the left and right half sums in this case. I would appreciate if you could elaborate on this further.  You don't need to calculate the sum of the vector pieces when you test a new value of . If you calculated and for both parts for , when you have to calculate it for you just need to:  Remove from ; and  Add to .  This both are O(1). If you do it (n-1) times, you are still under O(n) complexity.  This only gets a 71% correctness score on Codility. It doesn't work if there are only two elements () and the small test desn't work.  Without debugging, this solution gets a 100% task score on Codility (with 100% for both correctness and performance):  With debugging:  Initially I tried starting from halfway, but this made the implementation more complicated. This is what I came up with before I ditched that approach (and I can't be bothered with hacking on a solution):  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  