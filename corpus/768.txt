 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Sorry for any inconvenience I am a beginner at C++ and was stuck with an empty set... Thank you for the helpful comments that helped me figure out what the problem was  I wrote a C++ code for a question in which I need to use Dijkstra's shortest path algorithm in n*log(n) time and so I am using set of pairs to obtain the vertex with shortest distance from source vertex. The code was not giving any errors at runtime but it wasn't giving the output either. So to see where it was getting stuck I used cout statements at certain points in the code and figured that the code is stopping execution right after the erase statement.  The statement is used in the code for erasing the first pair in the set and so the iterator pointing to of the set is given as argument. It was earlier written in the format , but after searching for this problem on stack overflow I found someone saying iterator=set.erase(iterator) will solve the problem. I tried that and it still was getting stuck at that line, neither stopping execution and returning to the terminal nor giving a runtime error. I don't know what is wrong with this so I thought I would get some help here.  I am providing my code and a screenshot of the running too I would really appreciate your help.  Image of the running code: Note that the highlighted lines are the problematic ones neither does iterator manipulation exist in the part of code that is getting stuck nor is the iterator accessed again after erasing.  It is only printing the line before the erase statement and not printing the one after...  Useful reading. Specifically The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.  Conditional or not, the problem is still the same. Your iterator is invalidated when was called in it. Same for all other iterators pending on that vector.  "erase() ing the iterator invalidates the current one, thus the next it++ is undefined behavior. That's the reason why erase() returns an iterator value, that you can use to continue the loop in place (do the it++ conditionally in cases you don't erase)" There is no it++!!  Unrelated, probably. Doesn't do what you seem to expect it to do. Check your compiler's documentation on how it initializes Variable Length Arrays. The Standard C++ array initialization rules do not apply because Variable Length Arrays are not allowed in Standard C++.  And who said can't equal ? That's exactly what you'll get if the set is empty, something you aren't testing for. Drop something like after you get the iterator and see what happens.  1 Answer 1  The problem as told by user4581301 in the comments was that the iterator was pointing to the end() of the set, which means the set was empty as it was initialized to point to begin() of the set. Thus an undereferencable iterator was dereferenced resulting in undefined behavior, (this means it may not necessarily give a runtime error but rather provide an output when dereferenced). Although the program thus gets stuck at this line as a result of this invalid accessing.  The fault in the code was that set was defined globally but then was refined by the same name inside main, this meant when the values are filled in the set inside main, they are filled in the set that was defined within main not the one defined globally. But when accessing the set in the function dij, the global set is accessed which is actually empty!  Removing the redefinition in main would resolve the issue.  The above code thus works perfectly fine. Below is the screenshot of the working code's output:  Here are some of the links provided in the comments that helped:  P.S. The code finds the path through which the shortest distance between vertex 1 and vertex n of a graph with weighted edges can be obtained, in O(n*log(n)).  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  