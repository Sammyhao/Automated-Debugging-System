 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Raw pointers can point to objects allocated on the stack or on the heap.  Heap allocation example:  Stack allocation example:  Heap allocation using auto_ptr example:  Stack allocation using auto_ptr example:  Are 'smart pointers' intended to be used to point to dynamically created objects on the heap? For C++11, are we supposed to continue using raw pointers for pointing to stack allocated objects? Thank you.  4 Answers 4  Smart pointers are usually used to point to objects allocated with and deleted with . They don't have to be used this way, but that would seem to be the intent, if we want to guess the intended use of the language constructs.  The reason your code crashes in the last example is because of the "deleted with " part. When it goes out of scope, the unique_ptr will try to the object it has a pointer to. Since it was allocated on the stack, this fails. Just as if you had written,  Since one usually uses smart pointers with heap objects, there is a function to allocate on the heap and convert to a smart pointer all in one go. will perform the actions of the first two lines of your third example. There is also a matching for shared pointers.  It is possible to use smart pointers with stack objects. What you do is specify the deleter used by the smart pointer, providing one that does not call . Since it's a stack variable and nothing need be done to delete it, the deleter could do nothing. Which makes one ask, what's the point of the smart pointer then, if all it does is call a function that does nothing? Which is why you don't commonly see smart pointers used with stack objects. But here's an example that shows some usefulness.  The runtime error is due to the fact that was called on a memory location that was never allocated with .  If an object has already been created with dynamic storage duration (typically implemented as creation on a 'heap') then a 'smart pointer' will not behave correctly as demonstrated by the runtime error.  Are 'smart pointers' intended to be used to point to dynamically created objects on the heap? For C++11, are we supposed to continue using raw pointers for pointing to stack allocated objects?  As for what one is supposed to do, well, it helps to think of the storage duration and specifically how the object was created.  If the object has automatic storage duration (stack) then avoid taking the address and use references. The ownership does not belong with the pointer and a reference makes the ownership clearer.  If the object has dynamic storage duration (heap) then a smart pointer is the way to go as it can then manage the ownership.  So for the last example, the following would be better (pointer owns the int):  The will have automatic storage duration and will call the destructor when it goes out of scope. The will have dynamic storage duration (heap) and will be ed by the smart pointer.  One could generally avoid using and and avoid using raw pointers. With and , isn't required.  Are 'smart pointers' intended to be used to point to dynamically created objects on the heap?  They are intended for heap-allocated objects to prevent leaks.  The guideline for C++ is to use plain pointers to refer to a single object (but not own it). The owner of the object holds it by value, in a container or via a smart pointer.  Are 'smart pointers' intended to be used to point to dynamically created objects on the heap?  Yes, but that's just the default. Notice that has a constructor (no (3)/(4) on that page) which takes a pointer that you have obtained somehow, and a "deleter" that you provide. In this case the unique pointer will not do anything with the heap (unless your deleter does so).  For C++11, are we supposed to continue using raw pointers for pointing to stack allocated objects? Thank you.  You should use raw pointers in code that does not "own" the pointer - does not need to concern itself with allocation or deallocation; and that is regardless of whether you're pointing into the heap or the stack or elsewhere.  Another place to use it is when you're implementing some class that has a complex ownership pattern, for protected/private members.  PS: Please, forget about ... pretend it never existed :-)  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  