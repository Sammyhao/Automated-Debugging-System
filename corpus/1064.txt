 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  34122 gold badges33 silver badges1010 bronze badges  1  1  Incidentally, doing BFS recursively would probably cause your stack to grow in the size of the state space. If your solution is at depth d, the stack space required to find the solution would be b^d where b is the branching factor.  6 Answers 6  I can't imagine why you'd want to, when you have a perfectly good iterative solution, but here you go ;)  I should add that if you really want to traverse the nodes of the tree recursively, then you could do a DFS with a parameter, and output nodes only at , then recurse up. But that's just crazy talk, because you'd revisit nodes wayyyyy too many times... Just accept that BFS is an iterative algorithm. :)  44.5k77 gold badges5757 silver badges6767 bronze badges  2  1  The DFS-with-a-level isn't actually that bad idea - it's called iterative deepening depth-first search and is very handy. See my post.  @gustafc, Thanks, yes I'm aware of iterative deepening, I should've referenced it. I hadn't realized it was only an 11% tax on node visits, that's surprising.  The BFS algorithm is not a recursive algorithm (as opposed to DFS).  One could try writing a recursive function that emulates the algorithm but that would end up quite bizzare. What would be the point in doing this ?  For Coding interviews. I know of some companies who've asked solving a question using recursive BFS. sigh!  You can use iterative deepening depth-first search, which effectively is a breadth-first algorithm that uses recursion. It's even better than BFS if you have a high branching factor, as it doesn't use much memory.  A Simple BFS and DFS recursion: Just push/offer the root node of tree in stack/queue and call these functions!  Here is an example using arraylist instead of queues, I have predefined the adjacency matrix and the visited array. Also created the edges  This is not going to be satisfying to everyone -- I am sure. With all respect to everyone. To the people who ask what is the point? The point is that we believe that every iterative algorithm has also a (easy?) recursive solution. Here is a solution by "sisis" from stackoverflow.  It has certain amount of funninest in it, but it not clear that it violates any recursive rules. If it does not violate any recursive rules, then it should be accepted. IMHO.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  