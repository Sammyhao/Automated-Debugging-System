 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I try to solve some problems in a online website. And I've a solved a problem with simple C++ it worked well but it sometime throw a "Time limit exceeded" error. How to get rid of this?  Here is the question that I solved  There are two integers A and B. You are required to compute the bitwise AND amongst all natural numbers lying between A and B, both inclusive.  i suppose the error is "Time limit exceeded" because your code takes too long. You need to find a different way to get the answer. As usual such coding challenges don't let the brute force approach pass  Either buy your own computer and install Linux (e.g. Debian...) on it, or read a good book about algorithms, e.g. Introduction to Algorithms  do the maths first. There is a way to get the answer that does not require you to carry out all the individual steps. Just a non-sense example: To find the maximum integer between a and b you also would not write a loop to check each single integer. There is a simpler and faster way to get the result. The situation here requires just a little more thought  Depending on the ranges provided, it's either 0 or some power of 2. The LSB will always AND to 0, right?  Sometimes you can use a brute force approach to analyze patterns and then rewrite to take advantage of those patterns. Most of the time if you don't already know how to solve the problem skip it and move on to the next problem. If you have time left over, go back and analyze.  1 Answer 1  1 0 0  all the bits can be computed separately, we have as many equations as many bits  in a sequence of logical statements, where AND is the operator, the result is 0 if and only if ANY of the items is 0  So, if any numbers are pair, then the last bit is 0. Otherwise, the last bit will be 1. If any number will have a 0 as the penultimate bit, then the result for that bit will be 0. Otherwise it will be 1.  As a general rule, based on the pigeonhole principle, proposed by Dirichlet, if you have enough consecutive (elements) for a given bit, then the result for that bit will be 0. For example, for the very last bit you have two variations, therefore, if you have at least two numbers in your consecutive set, then the last bit will be 0. If we take the very next bit, then you have four variations: 00, 01, 10 and 11. So, if you have at least 3 numbers in your consecutive set, then this bit is 0. For the next bit, you have 8 variations: 000, 001, 010, 011, 100, 101, 110, 111. So, if you have at least 5 numbers in your consecutive set, then this bit is 0.  Now, since we have a simple rule that determines most bits if there are many items, you will end up with a few bits that exceed in their number of variations the rule I have described above. For those bits you can check the first and the last number. If they have the same value for that bit, then that value will be the result, be it 0 or 1.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  