 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have the following C code which returns the reverse of a linked list.  Though it reverses the linked list, I never get the head of the reversed linked list because the node is getting overwritten.  How can I get the head of the reversed linked list node returned to the calling program?  2,01244 gold badges4343 silver badges9797 bronze badges  2  2  Shoot. You have to have something receiving the return from the recursive call. I'm sure that's a core problem with your code.  6 Answers 6  If you want to change the head pointer, you must pass it by reference (as a pointer). The prototype should be modified to receive the head as S **.  @Jim He's returning the pointer, right. But eyalm's suggestion still solves the problem. The return-statements are not needed - passing headref as reference will do the trick.  @krrishna The problem is, you are returning the restOfElements of the first element. Meaning you will always receive the originally 2nd element in return. You can define your function as 'S* reverseRecursive(S*& headref)' or even as 'void reverseRecursive(S*& headref)'.  @eyalm I'm not disputing you, but krrishna needs to decide how he wants to do the recursion. If he passes as a reference, then he should have a void function as sebi indicates.  The head of the reversed list is equal to the head of the reversed List starting with (because the original has to become tha last element of the reversed list). So storing the result of the recussive call should do (as Jim has already suggested in his comment):  8,56722 gold badges2020 silver badges3131 bronze badges  3  I agree that this segment is problematic because the ->next->next could run one off the rails.  @Jim, I don't think because before the part of the code I've copied, there is a check and  @Jim firstElement->next is always a not-null pointer, it's checked before, so there will be no problem with that I think.  Thanks everyone. I have modified it little bit and it works now. Let me know your comments. new_head is a global variable.  2,01244 gold badges4343 silver badges9797 bronze badges  3  1  I'm really glad you got it working. Good for you! Recursion can be tricky. You might get some flak about new_head being a global var. If you want to avoid that, you can add it as a second input parameter (init to NULL) and just carry it along that way. But great that you got something working. Congrats!  I'm surprised this compiles and you should turn up the compiler warning level. Your function is defined as returning but you have a bare statement that returns nothing and a recursive call that discards the returned value.  If he passed in a NULL pointer, I don't think it would work. (Doesn't a blank return return the top of the stack or something?). The other problems seem to cancel each other out....  Actually, since reverse is destructive (it mutates its argument), a better interface design would probably be  So there's two ways to reverse a list in place recursively.  First, some setup. Let's make it easy to load linked lists of strings and print them, so we can make sure this stuff works:  One way of reversing the list involves passing back the new head of the list once we find it. We don't need it locally (since we're just moving the current element to the new end), but we'll need it so that the caller has a pointer to the head of the list once we're done.  Another way takes a pointer to a pointer. The only difference is that we don't need to return anything, since we're directly modifying a variable the caller has. I prefer this calling method since it's much clearer that we're modifying the list, not returning a copy. It's also harder for the caller to accidentally loose the pointer to the new head this way.  But what's better than either of these is to reverse the list non-recursively. Neither of those functions is tail-recursive, so the compiler has to allocate new stack frames for each element in the list. Try to reverse a long enough list, and you'll blow your stack. Much better to just reverse the list using a while loop.  Now we can test our results just by building lists out of the command line:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  