 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a third-party C library that provides this header:  I need to create a C++/CLI class that can call CLibStart and provide a class method as the function pointer. As suggested below, this needs to be done with GetFunctionPointerForDelegate. Because the delete constructor includes 'this' and doesn't require a static method, I don't need to pass 'this' into CLibStart.  All of this compiles and runs fine using this C# tester:  Sample output:  Outstanding questions:  I have this feeling that I need to use gcroot and/or pin_ptr? If so, how? where?  1,84622 gold badges2020 silver badges3333 bronze badges  11  3  Use Marshal::GetFunctionPointerForDelegate(). It doesn't have to be a static method. You must keep the delegate object alive by storing it.  You can use the template to keep the object alive, if you use @HansPassant's suggestion.  Thanks. I have updated the 'question' with a solution that appears to be working (compiles and runs in VS2010). But I'm not sure if/where/how I need to use gcroot and/or pin_ptr. Any ideas?  How can the C++/CLI class' 'log' method access the implicit 'this' when it is invoked by the callback?  There isn't anything in this code that prevents the "mc" object from getting garbage collected. Which will also collect the delegate. It works right now because the debugger extends the lifetime of the variable to the end of the method. But in Real Life it will make a loud kaboom when that happens. Add the objects to a static List<> and remove them again when the native code is guaranteed to stop making callbacks.  It not only shouldn't, it can't. is an unmanaged type and cannot be a member of a .  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  