 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  below is the example code, if this work i can use the same logic in my business code.  Junit:  Expected o/p "mock main class" but I am getting "inside main class"  1 Answer 1  You are injecting a Mock of A but in the B's getString method you are creating a new A instance and working on it. Remove it and the mocked version will be called:  I would suggest adding a setter, so that in production you can inject that somehow.  22.9k1010 gold badges4848 silver badges5858 bronze badges  5  Thank you, However, if I do with vefify i am getting error Mockito.verify(a).getString(Mockito.any(String[].class)); error:"wanted but not invoked" but works fine when I use when  @Test public void test2Object(){ String[] bc = {"mock main class"}; Mockito.verify(a).getString(Mockito.any(String[].class)); System.out.println((b.getString())[0]); } base Class class B{ A a; public String[] getString(){ String[] ab = {"inside main class"}; String str = ""; //a= new A(); return a.getString(ab); }} error Wanted but not invoked: a.getString(<any>);  have added the test class that should work with your example.. You dont seem to need to use verify.. just straight assert. Hope it helps  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  