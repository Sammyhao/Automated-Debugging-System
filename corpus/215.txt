 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I am new in programming c++, so please don't be angry with me if my source code is not exactly brilliant.  I have to write a programm to handle with nodes and edges in a graph for my studies.  I have 2 in my source code. The first one is to store general and the other one for saving the kind class of my nodes called . In general, all elements are pointers to the created objects.  To figure out whether one object is the same in the other list I save the memory address and compare it to the elements on the second list. If there is a match the second element will be deleted.  Now I'd like to delete one element in both lists:  I can compile this, but when I call the function, my programm just exits with return 1. Actually, I figured out that the remove-command in the if-clause is the problem. Why does that not work??  If both pCurrentNode and pCurrentArticleNode point to the same object, then deleting one will remove the object, leaving nothing where the object used to be, and then deleting the other one will remove the object again, creating an anti-object where an empty place existed a moment ago. Anti-objects will annihilate violently on contact with objects, and the resulting gamma rays will erase your hard disk and may permanently damage your CPU. Or at least this could happen.  41.8k11 gold badge4141 silver badges8686 bronze badges  12  Thanks a lot! That works correctly for me :) But why does my code deletes the same object twice? I thought that i delete the object and then the pointer in the other list to that memory adress.. But i know. I have a lot to learn!  @user5223762 simply means that 2 pointers point to the same object. Actually your code did not delete the same object twice due to bug in your code (missing break in the loop) but would when you fix the first issue  @WernerErasmus how OP checked object type when populated container is outside of scope of this question. I can only assume it is done correctly, with that in mind if 2 pointers are equal - they point to the same object.  When you remove an element from object with method, all iterators pointing to that elements become invalid. In your case, after you remove an element from the list , the iterator object becomes invalid. And when you increment that iterator, you get an undefined behavior.  Pay attention that the method deletes all of the items in the list with given value. So you don't need the for-loop at all. Here is the fixed version of your function:  You have to use the method of in order to remove an element from your list while iterating over it.  12.6k11 gold badge2121 silver badges4848 bronze badges  1  That worked on the first moment correct, but after i run that function there is strange behavior with my objects. For example one element's name changend into a misterious name.. I dont' know why. And if i run it twice it will crash. But thank you very much! I think thats the fault of my code in general.  Simple issue in your code is that if you go into the if condition is met and it's body executed, you should come out of the loop. std::remove invalidates the iterator ann you will get issues in next iteration so do:  In general, there are other issues in the code. As a first step I would suggest using shared_ptr for managing your Nodes and have list of shared_ptr instead of list of pointers.  I am new in programming c++, so please don't be angry with me if my source code is not exactly brilliant.  We all start somewhere.  Now I'd like to delete one element in both lists:  OK. Quick question. Why are you deleting article node if it is already deleted (via base Node)? I'm assuming for now node is not duplicated in the list:  My solution below... I've passed the lists as arguments. See comments:  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  