 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  Ok this is my first post on Stack Overflow I have been reading for a little while and really admire the site. I am hoping this is something that will be acceptable to ask. So I have been reading through Intro to Algorithms (Cormen. MIT Press) all the way through and I am up to the graph algorithms. I have been studying the formal algorithms laid out for breadth and depth first search in very fine detail.  Here is the psuedo-code given for depth-first search:  This algorithm is recursive and it proceeds from multiple sources (will discovered every vertex in unconnected graph). It has several properties that most language specific implementations might leave out. It distinguishes between 3 different 'colors' of vertices. It initially paints all of them white, then when they are 'discovered' (visited in DFS-VISIT) they are then painted gray. The DFS-VISIT algorithm runs a loop recursively calling itself on the adjacency list of the current vertex and only paints a vertex black when it has no more edges to any white node.  Also two other attributes of each vertex are maintained u.d and u.f are the time stamps to when the vertex was discovered (painted gray) or when a vertex is finished (painted black). The first time a node is painted it has a time stamp of one and it is incremented to the next integer value for each time another is painted (whether it be grey or black). u.π is also maintained which is just a pointer to the node from which u was discovered.  * EDIT 10/31/12 * This is embarrassing that my algorithm has been incorrect for so long, it would work in most cases, but not all. I just got a popular question badge for the question and I saw where Irfy had spotted the problem in his answer below, so that is where the credit goes. I am just fixing it here for anyone that needs this in the future.  Does anyone see a flaw with the above algorithm? I am by far no expert on graph theory, but I think I have a pretty good grasp on recursion and iteration and I believe this should work the same. I am looking to make it functionally equivalent to the recursive algorithm. It should maintain all the attributes of the first algorithm even if they are not needed.  When I began writing it I did not think I would have a triply loops but that's the way it turned out. I have seen other iterative algorithms when I looked around Google that only have a doubly nested loop, however, they do not appear to proceed from multiple sources. (i.e. they will not discover every vertex of unconnected graph)  35.8k1616 gold badges6363 silver badges7878 bronze badges  8  Please correct indentation after statement in second loop in second algorithm. Ideally also the indentation after first loop  The finish times computed by the non-recursive version will be wrong. u.f <-time can only be set after all descendants have their finish time set. If one takes the same example in CLRS, then the node u would have a finish time=3, whereas the actual value should have been 8.  CLRS states that each vertex is initially white until it is first examined (discovered) at which point it is grayed and is set to the new time. It remains gray until it's adjacency list is examined completely (u.d is set on all adjacent nodes), at which point it is blackend and the finish time is set to the new time.  8 Answers 8  Both algorithms are fine. The second one is a direct translation from recursive to stack-based. All mutating state are stored in the stack. never changes during the execution of the algorithm.  The algorithms will produce a spanning tree for each disconnected region, based on the order the algorithm visited each node. The trees will be represented both with references to the parent-nodes (), and as segment trees ( and ).  A child will have a reference to its parent node (or if it is a root), as well as having it's range () contained within it's parent's range.  Edit: I found a mistake in the translation. You are not actually pushing the current state into the stack, but a future method argument. In addition, you are not coloring the popped nodes and setting the field.  Here is a rewrite of the original first algorithm:  There is probably a few places that could be optimized, but should at least work now.  82.1k1919 gold badges132132 silver badges136136 bronze badges  2  his made perfect sense to me and it is a helpful bit of information but after some thought I am not sure it is true in EVERY case, definitely most. Please correct me if I'm wrong as I am trying to learn all I can about this, but I worked out this example here: link and it seems that y's parent is t, and it does not follow the inequality you gave. (This example with vertices in the loops being picked in alphabetical order.  Markus, you have a very good point in recognizing the segment trees, which led me to realize the algorithm is incorrect. See my post above.  While this may answer the question, it may be useful to provide some information about the code you posted (either in comments or as a separate explanation).  Agree with @Hooked, it doesn't seem like author of the question asks for an implementation. If you think that it can help, it would be nice to have some text explaining how exactly.  I think I managed to write a much simpler pseudo-code.  but first a few remarks to make things a bit clear:  v.pDescendant - a pointer to a vertex descendant given by its adjacency list.  in the adjacency list, i assumed each element has a field "pNext" that points to the next element on the linked list.  I've used some C++ syntax, mainly "->" and "&" to emphasize what is a pointer and what is not.  Stack.top() returns a pointer to the first element of the stack. but unlike pop(), it does not remove it.  The algorithm is based on the following observation: a vertex is pushed into the stack when visited. and removed (popped) only when we are done examining (blackening) all its descendants.  Simple iterative DFS. You can also see the discover time and finish time. Any doubts please comment. I have included sufficient comments to understand the code.  You do have a serious flaw in your non-recursive code.  After you check whether is , you never mark it before pushing, so it may be seen as again and again from other unvisited nodes, resulting in multiple references to that node pushed to the stack. This is potentially a catastrophic flaw (could cause infinite loops or such).  Also, you don't set except for root nodes. This means that the Nested set model attributes s and s won't be correct. (If you don't know what s and s are, have a read of that article, it was very enlightening to me back in the days. The article's is your and is your .)  Your inner basically needs to be the same as the outer minus the loops, plus the parent reference. That is:  8,80811 gold badge4141 silver badges6262 bronze badges  5  This happened when I copied my algorithm over from MS Word. I thought I had fixed everything, but I can be careless when proofreading sometimes. I edited the above to what I have. Sorry about that. I am hoping it is correct now.  I added an image to the original post that clarifies how u.d and u.f will be assigned.  The field of the parent will be set to the time right after pushing all the children, not after actually visiting them. The parent will wrap the start-times of its children, but not their whole subtrees.  I just saw your update here when I got my popular question badge and I have corrected my original post, thanks so much.  In the non-recursive version we need another color that reflects the state in the recursive stack. So, we will add a color=RED to indicate all children of the node were pushed to the stack. I will also assume the stack has a peek() method(which otherwise could be simulated with pop and immediate push)  So, with that addition the updated version of original post should look like:  I believe that there is at least one case where the recursive and stack versions are not functionally equivalent. Consider the case of a Triangle - vertices A, B, and C connected to each other. Now, with the Recursive DFS, the predecessor graph that one would obtain with source A, would be either A->B->C OR A->C->B ( A->B implies A is the parent of B in depth first tree).  However, if you use the stack version of DFS, parents of both B and C, would always be recorded as A. It can never be the case that parent of B is C or vice-versa (which is always the case for recursive DFS). This is because, when exploring the adjacency list of any vertex (here A), we push all the members of adjacency list (here B and C) in one go.  This may become relevant, if you try to use DFS for finding articulation points in a graph[1]. One example would be that the following statement holds true only if we use the recursive version of DFS.  A root vertex is an articulation point if and only if it has at least two children in the depth first tree.  In a triangle, there is obviously no articulation point, but the stack-DFS still gives two children for any source vertex in the depth-first tree (A has children B and C). It's only if we create the depth first tree using recursive DFS that the above statement holds true.  [1] Introduction to Algorithms, CLRS - Problem 22-2 (Second and Third Edition)  4,15644 gold badges3232 silver badges4444 bronze badges  2  Are you saying that by nature of the algorithms this is the difference between the stack and recursive implementations? Or are you saying that these differences between the two arise from my implementations and that they could be fixed to behave the same?  My point is that the difference arises due to implementations. As I said, in the stack version we push all neighbors of a vertex in one go unlike the recursive case, where we visit each neighbor node recursively. I have not gone through this link thoroughly, but it looks like it deals with the same issue. jroller.com/bobfoster/entry/depth_first_search_with_explicit  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  