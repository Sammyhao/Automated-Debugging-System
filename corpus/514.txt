 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I have a problem in Golang whereby I need to be able to lookup string keys, from about 5,000,000 strings, each of which containing only a-z (lowercase) and 0-9 characters. Similar problem with uint32 and uint64 as keys.  A map (hash table) is perfect for this, but it uses much too much RAM.  There must be known methods for this type of thing, I've been looking into B-Tree but I'm not sure it would be the most efficient mechanism.  Some of the particularities of my problem, which could lead to a more efficient solution, are:  The keys need only be strings of a-z0-9 or simple uint values.  Once built it only needs be read-only.  Seeing as it only needs be read-only then it seems to me that having it as a pre-sorted list with a series of indexes, might work well. I thought at first I might be able to just have it in slices with a 36 (26 letters + 10 numbers) index for each level (i.e. character)... but of course that means 36^whatever which ends up being the opposite of efficient. Then I thought maybe I could put only a single index of 36 for each level, but then I end up with a load of arrays/slices that need to be intersected to get the ID of the result.  I guess I'm looking for some kind of very specific B-Tree implementation, but more tuned to my purpose (without the B.)  Does anyone know of anything that exists like I am suggesting?  12.5k1414 gold badges7272 silver badges130130 bronze badges  8  1  If the maximal size of the strings is short, you could try to use a sorted array of [n]byte.  not too familiar with Go - why can't you use a bitset or perhaps apply a bloom filter? Happy to learn if I am wrong - thanks  This problem is not GO-specific. You can inspire yourself in many textbooks on algorithms.  You have a lot of options, and it depends on stuff like how much you value minimizing RAM use vs. keeping your code simple. A variation on @FUZxxl's approach is to keep one list per word length, stored in one big /, like the first approach here but in Go. Part of why you'd use arrays or one big string is that is a pointer/length pair, 16 bytes on , which can account for a lot of your RAM use if your actual content is small. , unlike , is stored inline--no pointer/length/capacity.  4 Answers 4  I'd give a try to a Compressed Trie. It's the data structure perfectly usable in a scenario with lexicographic keys. B-Trees are mostly intended for external memories because they're minimizing the depth of a tree. A trie or a more memory efficient hashing is the right way to go.  I think it depends upon what you are trying to ultimately achieve. For example:  Do you want to (a) look up some value associated with the string (e.g. an index or cache) or (b) simply test whether the string is a member of a set of strings (e.g. an exclusion list)?  How accurate does the lookup need to be - can you live with false positives?  If the answer to question 1 is (a) then a trie is probably a good choice of data structure. If the answer to question 1 is (b) then you are probably best off using a bitset or a bloom filter. Of these two, a bloom filter will be the fastest and most memory efficient but is probabilistic and will yield some false positives (but no true negatives) which may or may not be okay for your use case depending upon your answer to question 2.  Another idea to optimize the map and memory usage if you know how many strings you're gonna use and you only need to check their existence.  Use , is guaranteed to have 0 size, unlike bool which uses at least 1 byte.  Preallocate the map : m := make(map[string]struct{}, 5000000)  Check if a key exists with  Compressed Tries are nice and all, but unless you're extremely pressed for memory, will be much faster.  85.9k1919 gold badges171171 silver badges170170 bronze badges  1  1  I've been using map[string]bool, so it's interesting to hear about map[string]struct{}. However, maps are the whole problem - they use an unreasonable amount of memory.  You should use a Trie data structure which is designed to map strings to values very efficiently. See https://en.wikipedia.org/wiki/Trie for more information.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  