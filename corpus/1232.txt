 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I faced an interesting problem called as the Great Tree-List Problem. The Problem is as follows :  In the ordered binary tree, each node contains a single data element and "small" and "large" pointers to sub-trees .All the nodes in the "small" sub-tree are less than or equal to the data in the parent node. All the nodes in the "large" sub-tree are greater than the parent node. And a circular doubly linked list consist of previous and next pointers.  The problem is to take an ordered binary tree and rearrange the internal pointers to make a circular doubly linked list out of it. The "small" pointer should play the role of "previous" and the "large" pointer should play the role of "next". The list should be arranged so that the nodes are in increasing order. I have to write a recursive function & Return the head pointer to the new list.  The operation should be done in O(n) time.  I understand that recursion will go down the tree, but how to recursively change the small and large sub-trees into lists, also i have to append those lists together with the parent node.  How should i approach the problem?.. I just need a direction to solve the problem!.  A recursive in-order traversal should work just fine. Just be sure to store the pointer to the right sub-tree before visiting (modifying) the node itself. I guess this would be O(n) but memory footprint could get pretty bad. (especially if you're using a limited stack)  3 Answers 3  The idea is to create a method that converts a tree node containing subtrees (children nodes) into a loop. And given a node that has converted children (e.g. after recursive calls came back), you create a new loop by pointing the large pointer (next) of the largest node to the smallest node, and the small pointer of the smallest node to the largest node.  May not be complete, but it will be close to this:  The key to recursive programming is to imagine you already have the solution.  So, you already have a function which receives a pointer to a tree, turns that tree into a doubly-linked circular list and returns a pointer to the list's head (leftmost) node:  Finish up with the edge cases (empty child branches etc.). :)  walk down the left and right sides, get the pointers for each node, then have  Since your tree is binary, it will be composed of 3 node "subtrees" that can recursively use this strategy.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  