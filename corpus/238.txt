 Common mistakes to be avoided in Competitive Programming in C++ | Beginners  You might get some other negative value as output. So what is the problem here? The ints are not promoted to long long before multiplication, they remain ints and their product as well. Then the product is cast to long long, but we are late now as overflow has already occurred. Having one of x or y as long long should would work, as the other would be promoted. We can also use 1LL (or 1ll). LL is the suffix for long long, which is 64-bit on most C/C++ implementations. So 1LL, is a 1 of type long long.  Here is another place where this trick can help you.  Not using cin.ignore() with getline  So what is the problem here? This has little to do with the input you provided yourself but rather with the default behavior getline() exhibits. When you provided your input for the integer n (cin >> n), you not only submitted the following, but also an implicit newline was appended to the stream:  A newline is always appended to your input when you select Enter or Return when submitting from a terminal. It is also used in files for moving toward the next line. The newline is left in the buffer after the extraction into n until the next I/O operation where it is either discarded or consumed. When the flow of control reaches getline(), the newline will be discarded, but the input will cease immediately. The reason this happens is because the default functionality of this function dictates that it should (it attempts to read a line and stops when it finds a newline).  Because this leading newline inhibits the expected functionality of your program, it follows that it must be skipped our ignored somehow. One option is to call cin.ignore() after the first extraction. It will discard the next available character so that the newline is no longer intrusive. cin.ignore(n, delim); This extracts characters from the input sequence and discards them, until either n characters have been extracted, or one compares equal to delim.  But what if we don’t know how many lines of input are going to be there? We can use this then:  A problem when taking remainders: In a lot of problems, you have to print your solution modulo some large prime (for example 10^9 + 7).  Since z + x*y might not fit into long long, the above code can cause problems. The better way is to do this:  This can save you a lot Wrong Answers so it is better to take mod after every computation that might exceed long long. The test cases are generally designed to make sure you have handled overflow cases properly. Why does this work? Because (z + x*y)%mod is the same as ((z%mod) + ((x%mod)*(y%mod))%mod)%mod.  cin and cout might cause TLE: In a lot of programs, the cause of TLE is generally based on your algorithm. For example, if n = 10^6 and your algorithm runs in O(n^2) then this won’t pass a 1 second Time Limit. But say, you have found an algorithm that runs in O(n) for n = 10^6. This should pass the 1 second Time Limit. What if this is failing? One possible reason is that you are using cin and cout for I/O over multiple test cases. You can use scanf or printf for the same. You can also use some custom Fast I/O function for the same based on something like getchar() and putchar().  scanf and printf are faster than cin and cout. See this for more details.  This article is contributed by Hemang Sarkar. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.  Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.  Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here.  We use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy Got It !  