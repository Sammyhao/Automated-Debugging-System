 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  What is the best way to implement a Stack and a Queue in JavaScript?  I'm looking to do the shunting-yard algorithm and I'm going to need these data-structures.  40.3k88 gold badges6161 silver badges7575 bronze badges  15  270  I would advise caution in using queue.shift. IIRC it is not O(1), but O(n) and might be too slow if the queue gets large.  I'd say this depends on the javascript implementation. I don't think it's defined in the javascript spec.  For Queue performance issues, see a nice comparison of three different types of stack behaviors on jsperf.com/queue-push-unshift-vs-shift-pop -- Now if only someone was nice enough to include a rev of that jsperf that would contain the JS script that @Gili mentioned...  I resurrected the blog post linked in this answer since archive.org isn't always the most performant. I updated links and images so they work but I didn't change anything else.  Javascript has push and pop methods, which operate on ordinary Javascript array objects.  Queues can be implemented in JavaScript using either the push and shift methods or unshift and pop methods of the array object. Although this is a simple way to implement queues, it is very inefficient for large queues — because of the methods operate on arrays, the shift and unshift methods move every element in the array each time they are called.  Queue.js is a simple and efficient queue implementation for JavaScript whose dequeue function runs in amortized constant time. As a result, for larger queues, it can be significantly faster than using arrays.  172k4444 gold badges320320 silver badges484484 bronze badges  4  2  With the link which you shared had a functionality of checking the benchmark results & I don't see performance gains when tested with Google Chrome version 59. Queue.js is incosistent with its speed but Chrome was preety consistent with its speed.  Also I made a demo with the queue.js, that, the dequeue function does not really remove the item from the queue, so I wonder if its suppose to be how it works? If so, how can you retrieve the new queue after dequeue the previous item? codepen.io/adamchenwei/pen/VxgNrX?editors=0001  it looks like the dequeue in queue.js also requires additional memory as it is cloning the array with slice.  Furthermore, the underlying array is getting bigger and bigger with every added element. Even though the implementation reduces the array size from time to time, the overall size increases.  41.3k1010 gold badges6161 silver badges8383 bronze badges  6  1  Array.prototype.pop does not remove the value from the top (first element) of the Array. It removes the value from the bottom (last element) of the Array.  @MichaelGeller The top of the stack is the last element of the Array. Array push and pop methods behave just like a stack.  @mrdommyg Array.prototype.pop removes the last element of the array (see developer.mozilla.org/en/docs/Web/JavaScript/Reference/…). Last in this context means the element with the highest index. An array in JS has nothing to do with a stack. It is not a stack just because it has a pop method. Pop just means "remove the last element and return it". Of course you can mimic the functionality of a stack with an array, but an array still is not a stack by definition. It is still a list (a "list like" object according to MDN).  @MichaelGeller The behavior of a stack is "first in, last out". If you implement it using an Array in JavaScript with its and methods, then problem solved. I don't really see your point here.  @MichaelGeller A stack is conceptual. A JS array is (among other things) by definition a stack by virtue of implementing stack semantics. Just because it also implements array semantics doesn't change that. You can use a JS array like a stack out of the box, and in that context what you push and pop is the "top" element.  2,20911 gold badge2121 silver badges3535 bronze badges  6  15  To avoid needing to iterate over the entire thing in order to append to the end, store a reference to the last one via this.last=node;  Never implement any Queue like this unless you have a really good reason for it... while it might seem logically correct, CPUs don't operate according to human abstractions. Iterating over a datastructure that has pointers all over the place will result in cache misses in the CPU, unlike a sequential array which is highly efficient. blog.davidecoppola.com/2014/05/… CPUs HATE pointers with a burning passion - they are probably the #1 cause of cache misses and having to access memory from RAM.  this is a tempting solution, but I don't see created s being deleted when popping/dequeuing ... won't they just sit around hogging memory until the browser crashes?  @cneuro Unlike C++, JavaScript is a garbage collected language. It has a keyword, but that is only useful to mark a property of an object as being non-present—which is different from just assigning to the property. JavaScript also has a operator, but that is just used to set to a new empty object when calling a function. In C++ you need to pair every with a , but not in JavaScript because GC. To stop using memory in JavaScript, just stop referencing the object and it will eventually be reclaimed.  Isn't it also necessary to check a stack for overflow by setting a max stack size?  Javascript array shift() is slow especially when holding many elements. I know two ways to implement queue with amortized O(1) complexity.  First is by using circular buffer and table doubling. I have implemented this before. You can see my source code here https://github.com/kevyuu/rapid-queue  The second way is by using two stack. This is the code for queue with two stack  The stack implementation is trivial as explained in the other answers.  However, I didn't find any satisfactory answers in this thread for implementing a queue in javascript, so I made my own.  There are three types of solutions in this thread:  Arrays - The worst solution, using on a large array is very inefficient.  Linked lists - It's O(1) but using an object for each element is a bit excessive, especially if there are a lot of them and they are small, like storing numbers.  Delayed shift arrays - It consists of associating an index with the array. When an element is dequeued, the index moves forward. When the index reaches the middle of the array, the array is sliced in two to remove the first half.  Delayed shift arrays are the most satisfactory solution in my mind, but they still store everything in one large contiguous array which can be problematic, and the application will stagger when the array is sliced.  I made an implementation using linked lists of small arrays (1000 elements max each). The arrays behave like delayed shift arrays, except they are never sliced: when every element in the array is removed, the array is simply discarded.  The package is on npm with basic FIFO functionality, I just pushed it recently. The code is split into two parts.  Here is the first part  And here is the main class:  Type annotations () can easily be removed to obtain ES6 javascript code.  You can use your own customize class based on the concept, here the code snippet which you can use to do the stuff  and to check this use your console and try these line one by one.  46511 gold badge44 silver badges1111 bronze badges  1  2  Downvote for a naming convention: method that starts with a capital assumed to be a constructor.  There are quite a few ways in which you can implement Stacks and Queues in Javascript. Most of the answers above are quite shallow implementations and I would try to implement something more readable (using new syntax features of es6) and robust.  To go through the complete tutorial of how these data structures have been implemented and how can these further be improved, you may want to go through the 'Playing with data structures in javascript' series at jschap.com . Here's the links for queues - http://jschap.com/playing-data-structures-javascript-queues/  Or else you can use two arrays to implement queue data structure.  If I pop the elements now then the output will be 3,2,1. But we want FIFO structure so you can do the following.  Here is a fairly simple queue implementation with two aims:  Unlike array.shift(), you know this dequeue method takes constant time (O(1)).  To improve speed, this approach uses many fewer allocations than the linked-list approach.  The stack implementation shares the second aim only.  If you understand stacks with push() and pop() functions, then queue is just to make one of these operations in the oposite sense. Oposite of push() is unshift() and oposite of pop() es shift(). Then:  A word of warning for those writing performance critical software. The method is not a proper queue implementation. It is O(n) rather than O(1), and will be slow for large queues.  Thanks @RudiKershaw, you're right. If there is need to implement a O(1) queue it can be built with a linked list.  If you're looking for ES6 OOP implementation of Stack and Queue data-structure with some basic operations (based on linked lists) then it may look like this:  Queue.js  Stack.js  And LinkedList implementation that is used for Stack and Queue in examples above may be found on GitHub here.  A little late answer but i think this answer should be here. Here is an implementation of Queue with O(1) and O(1) using the sparse Array powers.  Sparse Arrays in JS are mostly disregarded but they are in fact a gem and we should put their power in use at some critical tasks.  So here is a skeleton implementation which extends the type and does it's things in O(1) all the way.  So do we have a potential memory leak here? No i don't think so. JS sparse arrays are non contiguous. Accordingly deleted items shouln't be a part of the array's memory footprint. Let the GC do it's job for you. It's free of charge.  One potential problem is that, the property grows indefinitely as you keep enqueueing items to the queue. However still one may implement an auto refreshing (condensing) mechanism to kick in once the length reaches to a certain value.  Edit:  The above code if just fine but the operator, while still being O(1), is a slow one. Besides the modern JS engines are so optimized that for like < ~25000 items works O(1) anyways. So we need something better.  In this particular case, as the engines develop we must harness their new powers. The code below uses a linked list and i believe it is the fastest and safest modern JS Queue structure as of 2021.  This is an extremely fast Queue structure and uses Private Class Fields to hide critical variables from prying eyes.  Here is the linked list version of a queue that also includes the last node, as suggested by @perkins and as is most appropriate.  In dequeue, you should return temp.data instead. Because that is what was queued.  The regular Array structure in Javascript is a Stack (first in, last out) and can also be used as a Queue (first in, first out) depending on the calls you make.  Check this link to see how to make an Array act like a Queue:  Seems to me that the built in array is fine for a stack. If you want a Queue in TypeScript here is an implementation  I like to think that the cleanest way to implement stack and queues should be to use a container that allows addition and deletion from both ends and then limit its capabilities for one end which can be done through a simple array in Javascript.  // STATEMENTS USED IN STACK CONTAINER WHILE ENCAPSULATING  // STATEMENTS USED IN QUEUE CONTAINER WHILE ENCAPSULATING  Create a pair of classes that provide the various methods that each of these data structures has (push, pop, peek, etc). Now implement the methods. If you're familiar with the concepts behind stack/queue, this should be pretty straightforward. You can implement the stack with an array, and a queue with a linked list, although there are certainly other ways to go about it. Javascript will make this easy, because it is weakly typed, so you don't even have to worry about generic types, which you'd have to do if you were implementing it in Java or C#.  you can use WeakMaps for implementing private property in ES6 class and benefits of String propeties and methods in JavaScript language like below:  Dequeue is O(n) for this implementation. If you queue 5 items and then dequeue 1, the while loop will need to run through all 5 items pushing them into s2.  The O(1) measurement is for every element in average. Because every element will be in/out for stack 1&2 only once.  I was always taught that big O is for the worst case scenario as described here medium.com/omarelgabrys-blog/… . It's an assumption that items will be dequeued at the same rate as they are queued. It depends on the implementation scenario. Without knowing the implementation scenario I don't think you can make this assumption IMHO.  Yes, you are right. For this specific operation, the time complexity is O(n). But let's put this into a real-world engineering environment. The reason to use or the value of using Queue is when you have multiple in&out operations for this data structure, like doing BFS, etc. In this case, measuring the average performance makes more sense. If you want to implement a definite O(1) solution, use LinkedList is good choice.  In Javascript the implementation of stacks and queues is as follows:  Stack: A stack is a container of objects that are inserted and removed according to the last-in-first-out (LIFO) principle.  Push: Method adds one or more elements to the end of an array and returns the new length of the array.  Pop: Method removes the last element from an array and returns that element.  Queue: A queue is a container of objects (a linear collection) that are inserted and removed according to the first-in-first-out (FIFO) principle.  Unshift: Method adds one or more elements to the beginning of an array.  Shift: The method removes the first element from an array.  Here is a queue using a map. Since insertion order is guaranteed, you can iterate it like an array. Other than that the idea is very similar to Queue.js.  I've made some simple tests, but haven't tested it extensively. I also added some features that I thought were nice (constructing via an array) or easy to implement (e.g. and ).  The simple version / intuition behind it is below:  The issue with the simple version is that memory needs to be remapped when it has indexed over about 9 quadrillion (the value of ). Moreover, I think it might be nice to have array construction and it is nice to see the values being enqueued and dequeued being returned. One could account for this by writing the following code:  I did some testing in the Chrome developer console with the following calls on the full version.  Sorry to bump this topic but I scrolled over the many answers and did not see any implementation of an Object based Queue, which can perform enqueue AND dequeue with O(1) AND no wasted memory.  It only misses a 0 length check, which is trivial to add.  the big and only problem of this solution is the ever growing index wich could hit some Number limit at one point, if the queue runs for a long time and/or at high speed (my intent is to process audio = high speed).  There is no perfect solution for this... the easy way can be resetting the index to 0 whenever the queue is empty.  At Last, I added a method which costly shifts all the indexes back to the beginning, to use in the case the queue is never empty.  The performance is with no doubt better (the number is time in miliseconds for enqueuing 10 000 numbers then dequeuing them) :  I ran into this thread while implementing a BFS. After wondering why the performance was so poor I did some research. array.shift() typically runs in O(n) which increases my BFS runtime from O(V+E) to O(V^2+E).  Instead of implementing a queue from scratch I used the npm package double-ended-queue which is compatible to the previously used array methods and works like a charm. The deque can be used as stack or queue.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  