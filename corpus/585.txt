 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I'm requesting data from a server which returns data in the JSON format. Casting a HashMap into JSON when making the request wasn't hard at all but the other way seems to be a little tricky. The JSON response looks like this:  What way would be easiest to access this data? I'm using the GSON module.  1,36811 gold badge99 silver badges66 bronze badges  4  3  This will convert ints to floats before it turns them into strings, but it will work to convert JSON into maps for comparison purposes.  works great for me, but I changed the map to because if the json is not only strings you get an error  This gives the wrong impression. The correct solution for parameterized types is .  I know this is a fairly old question, but I was searching for a solution to generically deserialize nested JSON to a , and found nothing.  The way my yaml deserializer works, it defaults JSON objects to when you don't specify a type, but gson doesn't seem to do this. Luckily you can accomplish it with a custom deserializer.  I used the following deserializer to naturally deserialize anything, defaulting s to and s to s, where all the children are similarly deserialized.  The messiness inside the method is for making sure you only ever get a Double or an Integer or a Long, and probably could be better, or at least simplified if you're okay with getting BigDecimals, which I believe is the default.  You can register this adapter like:  And then call it like:  I'm not sure why this is not the default behavior in gson, since it is in most other semi-structured serialization libraries...  4,61433 gold badges3131 silver badges4646 bronze badges  10  1  ... although I'm not quite sure what to do now with the Objects I get back. Can't seem to cast them as String even though I know they're strings  Aha! The trick was the call the deserializer recursively instead of the context.deserialize() call.  Would you have some code Matt? I'm trying to make the changes on the deserializer but I can't really see your point  Gson now by default appears to have the behavior that Kevin Dolan is going for in his code snippet.  With google's Gson 2.7 (probably earlier versions too, but I tested with the current version 2.7) it's as simple as:  Which returns a of type and works recursively on nested objects, arrays, etc.  I ran the OP example like so (simply replaced double- with single-quotes and removed whitespace):  Update for new Gson lib: You now can parse nested Json to Map directly, but you should be aware in case you try to parse Json to type: it will raise exception. To fix this, just declare the result as type. Example below:  For me what worked (thanks to advice above!) is convert nested (because the TypeToken trick didn't work for me on nested) was to return them just as LinkedTreeMap objects. From there I just iterated over the LinkedTreeMap keys and populated new HashMaps in the loop, as they have the same methods. Don't know why you can't straight cast but met my level of need.  I had the exact same question and ended up here. I had a different approach that seems much simpler (maybe newer versions of gson?).  with the following json  The following  outputs  You could dynamically check using instanceof when navigating your jsonObject. Something like  4,74999 gold badges5050 silver badges103103 bronze badges  1  yes it is one line but keep in mind that will create a new inline sub-class, and all linters will raise a warning at least I guess  I have overcome a similar problem with a Custom JsonDeSerializer. I tried to make it a bit generic but still not enough. It is a solution though that fits my needs.  First of all you need to implement a new JsonDeserializer for Map objects.  And the deserialize method will look similar to this:  The con with this solution, is that my Map's key is always of Type "String". However by chaning some things someone can make it generic. In addition, i need to say, that the value's class should be passed in the constructor. So the method in my code returns the type of the Map's values, which was passed in the constructor.  This is more of addendum to Kevin Dolan's answer than a complete answer, but I was having trouble extracting the type from the Number. This is my solution:  JSONObject typically uses internally to store the data. So, you can use it as Map in your code.  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  