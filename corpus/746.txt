 your communities  Find centralized, trusted content and collaborate around the technologies you use most.  Connect and share knowledge within a single location that is structured and easy to search.  I would like to ask you if you can give me an advice about a task that is based on a graph algorithm - either DFS or BFS. There is a story behind the task. In the universe, there are a lot of planets. Some of these planets are infected by a dangerous virus that kills everyone. The task is to find a path from one planet to a planet where is a medicine and so it is possible there to cure people from the virus. To find the path is quite dangerous because of the virus. The crew may go to the planet where the virus is (they know in what planets the virus is), but they go there because they have no other option, since they have to find the medicine. On the planet that is infected the crew become infected and has some time to live (the time is a way from one planet to another planet). The result of this task should be a path from the start planet to a planet where there is the medicine. It should work for any map of known universe.  An example of a known universe with the planets. The starting planet is 0 and ending planet is 13. As you can see, the planets 1, 2, 4 are infected. In this specific example, there is one day to live after the crew become infected. So if the crew goes to the planet 1, they become infected and then on the next planet (4 or 6) dies. If they go to the planet 2, they become infected and they have just one day to live, so on the next planet dies... The result of this is the path 0 3 10 11 12 5 13.  An another example of a known universe with the planets. The starting planet is 0 and ending planet is 9. As you can see, the planets 4, 6, 7 are infected. In this specific example, there are two days to live after the crew become infected. So if the crew goes to the planet 4, they become infected and then after two days (one day = one way from one planet to another planet) dies. The result of this is either the path 0 1 2 3 5 7 6 9 or 0 1 2 3 5 7 8 9. As you can see, in some cases there might be more paths. The task is to find just one and it does not have to be the shortest one. Just one right path where the crew gets from start to end.  I have used the itterative DFS algorithm, but I do not know how to implement the part that if the crew would die on one path, the algorithm should find out another path. You can get it from the pictures of the graphs.  Hi, for each example it is the same number. So I have give you here two examples - two maps. On each map, there are planets with viruses. On the specific map the number is same for the case. On other example, the number is different.  4 Answers 4  You can do a modified BFS to solve this problem. While doing the BFS, maintain the number of days infected as a part of the state. Then, while traversing, accept traversing to a previously visited node if we would be visiting with a better number of infected days (i.e. less).  This will also be the shortest-path, since BFS will produce shortest path in a non-weighted graph.  Here's a quick sketch in Python, applied to your second example:  Thank you very much. It works fine in python. Unfortunately it does not work 100% in C++ when I tried to reprogram it there :( I got the good result in my C++ code when on the second example, but bad result when I tried the first example.  The easiest way to solve this problem is with BFS, but you start from the end.  Lets say the time to live after infection is TTL days.  Run BFS from the destination, but you can only consider going to infected planets on paths less than TTL long. Once the BFS hits a path with TTL length, then you can only use clean planets from then on, all the way to the start.  This is especially easy if you do the BFS level-by-level. Then you only need to check if level < TTL.  If you don't care if it is shortest path you can use DFS with some adjustments to incorporate time to die feature. JSFiddle and code in javascript:  3,12422 gold badges1111 silver badges1414 bronze badges  1  Thank you very much for the example. As I see the results in the JSFiddle, they are correct.  You can use use a shortest path algorithm like Dijkstra's algorithm for finding the shortest path between two nodes.  The edge weight is just the weight of the node you could be going to. In this case, all edges going to non-virus nodes would have a weight of . While edges going to a virus node would have a weight of . Visiting any virus planet should be easily more costly than visiting all other planets. This way the virus planets are only chosen if there is no other choice.  It also handles the case where you have to visit multiple virus planets, by preferring paths with the least amount of virus planets, not that it exactly matters in this case. Though if you want to list all equally valid solutions you could consider any additional virus planet as having a weight of 1 if the path already includes a virus planet. Then just display it as an another valid solution if it has the same weight as the best solution.  As for time to live, let's call it , just check the current path. If the current node in the search is not the end node, and it has been planets since the first virus planet crossed. Then reject the path as invalid.  An alternative handling for time to live would be to use an array weight, . This means, given the same path weight, it will expand the path with the lowest virus age. Virus age is just .  The algorithm mostly just avoids virus planets as much as possible. If a virus planet was reached during the path (because no other option was available) you can determine if you want to accept or reject the path. Updated the answer though to handle that along the way (though you could also check the completed candidate shortest path to see if the crew would have died along the way, that that isn't as efficent.  I think Zarif is right. Here is a counter-example for this algorithm: Suppose there are two paths from source to destination , and is a normal node and is virus infected. The two paths are and . Your algo sees both having the same total distance travelled, and does not consider that in one you'd survive (assuming 1 day travel possible post-infection), while in the other you wouldn't.  I already added in the answer above that you should reject the path if the crew would have died. This is code added within the shortest path algorithm. IE: at this point the node has died. if you want to include this in the prioritize queue instead of adding path rejection logic, you could use an array as the weight instead. IE: . This would consider the (0 days) as a shorter path than (1 day) if they have the same path weight. In this case, if the shortest path is more than days, then the crew doesn't make it.  Here is my idea for the problem . Once you hit a virus , you have to go to your destination from that place using the shortest path (If i correctly understand the statement , it doesn't matter if there are more virus nodes on the way) . If this distance is <= (the time to live) we have found a path . There is one thing we need to consider in the first place , we need to check if there is virus free path from the source node to the virus node we are currently considering  By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our Cookie Policy.  